//antialias: !0
//this.screenSpacePanning = !0,
!function(e) {
    var t = {};
    function r(i) {
        if (t[i])
            return t[i].exports;
        var n = t[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return e[i].call(n.exports, n, n.exports, r),
        n.l = !0,
        n.exports
    }
    r.m = e,
    r.c = t,
    r.d = function(e, t, i) {
        r.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: i
        })
    }
    ,
    r.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    r.t = function(e, t) {
        if (1 & t && (e = r(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var i = Object.create(null);
        if (r.r(i),
        Object.defineProperty(i, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var n in e)
                r.d(i, n, function(t) {
                    return e[t]
                }
                .bind(null, n));
        return i
    }
    ,
    r.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return r.d(t, "a", t),
        t
    }
    ,
    r.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    r.p = "",
    r(r.s = 114)
}([function(e, t, r) {
    "use strict";
    r.d(t, "b", function() {
        return n
    }),
    r.d(t, "a", function() {
        return s
    }),
    r.d(t, "c", function() {
        return a
    }),
    r.d(t, "d", function() {
        return o
    });
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
    var i = function(e, t) {
        return (i = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(e, t) {
            e.__proto__ = t
        }
        || function(e, t) {
            for (var r in t)
                t.hasOwnProperty(r) && (e[r] = t[r])
        }
        )(e, t)
    };
    function n(e, t) {
        function r() {
            this.constructor = e
        }
        i(e, t),
        e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype,
        new r)
    }
    var s = function() {
        return (s = Object.assign || function(e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
                for (var n in t = arguments[r])
                    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e
        }
        ).apply(this, arguments)
    };
    function a(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r)
            return e;
        var i, n, s = r.call(e), a = [];
        try {
            for (; (void 0 === t || 0 < t--) && !(i = s.next()).done; )
                a.push(i.value)
        } catch (e) {
            n = {
                error: e
            }
        } finally {
            try {
                i && !i.done && (r = s.return) && r.call(s)
            } finally {
                if (n)
                    throw n.error
            }
        }
        return a
    }
    function o() {
        for (var e = [], t = 0; t < arguments.length; t++)
            e = e.concat(a(arguments[t]));
        return e
    }
}
, , function(e, t, r) {
    "use strict";
    (function(e, i) {
        function n(e, t) {
            return e.require(t)
        }
        r.d(t, "c", function() {
            return n
        }),
        r.d(t, "e", function() {
            return a
        }),
        r.d(t, "g", function() {
            return o
        }),
        r.d(t, "f", function() {
            return c
        }),
        r.d(t, "d", function() {
            return l
        }),
        r.d(t, "b", function() {
            return p
        }),
        r.d(t, "a", function() {
            return h
        });
        var s = {};
        function a() {
            return "[object process]" === Object.prototype.toString.call(void 0 === e ? 0 : e) ? i : "undefined" == typeof window ? "undefined" == typeof self ? s : self : window
        }
        function o() {
            var e = a()
              , t = e.crypto || e.msCrypto;
            if (void 0 !== t && t.getRandomValues) {
                var r = new Uint16Array(8);
                t.getRandomValues(r),
                r[3] = 16384 | 4095 & r[3],
                r[4] = 32768 | 16383 & r[4];
                var i = function(e) {
                    for (var t = e.toString(16); 4 > t.length; )
                        t = "0" + t;
                    return t
                };
                return i(r[0]) + i(r[1]) + i(r[2]) + i(r[3]) + i(r[4]) + i(r[5]) + i(r[6]) + i(r[7])
            }
            return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(e) {
                var t = 0 | 16 * Math.random();
                return ("x" === e ? t : 8 | 3 & t).toString(16)
            })
        }
        function c(e) {
            if (!e)
                return {};
            var t = e.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
            if (!t)
                return {};
            var r = t[6] || ""
              , i = t[8] || "";
            return {
                host: t[4],
                path: t[5],
                protocol: t[2],
                relative: t[5] + r + i
            }
        }
        function l(e) {
            if (e.message)
                return e.message;
            if (e.exception && e.exception.values && e.exception.values[0]) {
                var t = e.exception.values[0];
                return t.type && t.value ? t.type + ": " + t.value : t.type || t.value || e.event_id || "<unknown>"
            }
            return e.event_id || "<unknown>"
        }
        function p(e) {
            var t = a();
            if (!("console"in t))
                return e();
            var r = t.console
              , i = {};
            ["debug", "info", "warn", "error", "log", "assert"].forEach(function(e) {
                e in t.console && r[e].__sentry__ && (i[e] = r[e].__sentry_wrapped__,
                r[e] = r[e].__sentry_original__)
            });
            var n = e();
            return Object.keys(i).forEach(function(e) {
                r[e] = i[e]
            }),
            n
        }
        function h(e, t, r, i) {
            void 0 === i && (i = {
                handled: !0,
                type: "generic"
            }),
            e.exception = e.exception || {},
            e.exception.values = e.exception.values || [],
            e.exception.values[0] = e.exception.values[0] || {},
            e.exception.values[0].value = e.exception.values[0].value || t || "",
            e.exception.values[0].type = e.exception.values[0].type || r || "Error",
            e.exception.values[0].mechanism = e.exception.values[0].mechanism || i
        }
    }
    ).call(this, r(14), r(22))
}
, function(e, t, r) {
    var i = t.global = r(40)
      , n = t.hasBuffer = i && !!i.isBuffer
      , s = t.hasArrayBuffer = "undefined" != typeof ArrayBuffer
      , a = t.isArray = r(11);
    t.isArrayBuffer = s ? function(e) {
        return e instanceof ArrayBuffer || f(e)
    }
    : g;
    var o = t.isBuffer = n ? i.isBuffer : g
      , c = t.isView = s ? ArrayBuffer.isView || v("ArrayBuffer", "buffer") : g;
    t.alloc = d,
    t.concat = function(e, r) {
        r || (r = 0,
        Array.prototype.forEach.call(e, function(e) {
            r += e.length
        }));
        var i = this !== t && this || e[0]
          , n = d.call(i, r)
          , s = 0;
        return Array.prototype.forEach.call(e, function(e) {
            s += u.copy.call(e, n, s)
        }),
        n
    }
    ,
    t.from = function(e) {
        return "string" == typeof e ? function(e) {
            var t = 3 * e.length
              , r = d.call(this, t)
              , i = u.write.call(r, e);
            return t !== i && (r = u.slice.call(r, 0, i)),
            r
        }
        .call(this, e) : m(this).from(e)
    }
    ;
    var l = t.Array = r(42)
      , p = t.Buffer = r(43)
      , h = t.Uint8Array = r(44)
      , u = t.prototype = r(18);
    function d(e) {
        return m(this).alloc(e)
    }
    var f = v("ArrayBuffer");
    function m(e) {
        return o(e) ? p : c(e) ? h : a(e) ? l : n ? p : s ? h : l
    }
    function g() {
        return !1
    }
    function v(e, t) {
        return e = "[object " + e + "]",
        function(r) {
            return null != r && {}.toString.call(t ? r[t] : r) === e
        }
    }
}
, function(e, t, r) {
    "use strict";
    function i() {}
    r.r(t),
    r.d(t, "ACESFilmicToneMapping", function() {
        return pe
    }),
    r.d(t, "AddEquation", function() {
        return L
    }),
    r.d(t, "AddOperation", function() {
        return ne
    }),
    r.d(t, "AdditiveBlending", function() {
        return P
    }),
    r.d(t, "AlphaFormat", function() {
        return Fe
    }),
    r.d(t, "AlwaysDepth", function() {
        return q
    }),
    r.d(t, "AmbientLight", function() {
        return Pc
    }),
    r.d(t, "AmbientLightProbe", function() {
        return rl
    }),
    r.d(t, "AnimationClip", function() {
        return Bo
    }),
    r.d(t, "AnimationLoader", function() {
        return Vo
    }),
    r.d(t, "AnimationMixer", function() {
        return Ll
    }),
    r.d(t, "AnimationObjectGroup", function() {
        return Rl
    }),
    r.d(t, "AnimationUtils", function() {
        return So
    }),
    r.d(t, "ArcCurve", function() {
        return Qo
    }),
    r.d(t, "ArrayCamera", function() {
        return bs
    }),
    r.d(t, "ArrowHelper", function() {
        return sp
    }),
    r.d(t, "Audio", function() {
        return ll
    }),
    r.d(t, "AudioAnalyser", function() {
        return hl
    }),
    r.d(t, "AudioContext", function() {
        return Kc
    }),
    r.d(t, "AudioListener", function() {
        return cl
    }),
    r.d(t, "AudioLoader", function() {
        return Qc
    }),
    r.d(t, "AxesHelper", function() {
        return ap
    }),
    r.d(t, "AxisHelper", function() {
        return Lp
    }),
    r.d(t, "BackSide", function() {
        return b
    }),
    r.d(t, "BasicDepthPacking", function() {
        return Nt
    }),
    r.d(t, "BasicShadowMap", function() {
        return m
    }),
    r.d(t, "BinaryTextureLoader", function() {
        return Bp
    }),
    r.d(t, "Bone", function() {
        return Gs
    }),
    r.d(t, "BooleanKeyframeTrack", function() {
        return Ro
    }),
    r.d(t, "BoundingBoxHelper", function() {
        return Ip
    }),
    r.d(t, "Box2", function() {
        return Fl
    }),
    r.d(t, "Box3", function() {
        return mr
    }),
    r.d(t, "Box3Helper", function() {
        return ip
    }),
    r.d(t, "BoxBufferGeometry", function() {
        return li
    }),
    r.d(t, "BoxGeometry", function() {
        return ci
    }),
    r.d(t, "BoxHelper", function() {
        return rp
    }),
    r.d(t, "BufferAttribute", function() {
        return Xr
    }),
    r.d(t, "BufferGeometry", function() {
        return oi
    }),
    r.d(t, "BufferGeometryLoader", function() {
        return kc
    }),
    r.d(t, "ByteType", function() {
        return Oe
    }),
    r.d(t, "Cache", function() {
        return jo
    }),
    r.d(t, "Camera", function() {
        return vs
    }),
    r.d(t, "CameraHelper", function() {
        return tp
    }),
    r.d(t, "CanvasRenderer", function() {
        return jp
    }),
    r.d(t, "CanvasTexture", function() {
        return Ks
    }),
    r.d(t, "CatmullRomCurve3", function() {
        return nc
    }),
    r.d(t, "CineonToneMapping", function() {
        return le
    }),
    r.d(t, "CircleBufferGeometry", function() {
        return po
    }),
    r.d(t, "CircleGeometry", function() {
        return lo
    }),
    r.d(t, "ClampToEdgeWrapping", function() {
        return we
    }),
    r.d(t, "Clock", function() {
        return ol
    }),
    r.d(t, "ClosedSplineCurve3", function() {
        return Op
    }),
    r.d(t, "Color", function() {
        return Pr
    }),
    r.d(t, "ColorKeyframeTrack", function() {
        return Co
    }),
    r.d(t, "CompressedTexture", function() {
        return Js
    }),
    r.d(t, "CompressedTextureLoader", function() {
        return Wo
    }),
    r.d(t, "ConeBufferGeometry", function() {
        return co
    }),
    r.d(t, "ConeGeometry", function() {
        return oo
    }),
    r.d(t, "CubeCamera", function() {
        return al
    }),
    r.d(t, "CubeGeometry", function() {
        return ci
    }),
    r.d(t, "CubeReflectionMapping", function() {
        return ue
    }),
    r.d(t, "CubeRefractionMapping", function() {
        return de
    }),
    r.d(t, "CubeTexture", function() {
        return Vi
    }),
    r.d(t, "CubeTextureLoader", function() {
        return Xo
    }),
    r.d(t, "CubeUVReflectionMapping", function() {
        return ve
    }),
    r.d(t, "CubeUVRefractionMapping", function() {
        return ye
    }),
    r.d(t, "CubicBezierCurve", function() {
        return cc
    }),
    r.d(t, "CubicBezierCurve3", function() {
        return lc
    }),
    r.d(t, "CubicInterpolant", function() {
        return Eo
    }),
    r.d(t, "CullFaceBack", function() {
        return p
    }),
    r.d(t, "CullFaceFront", function() {
        return h
    }),
    r.d(t, "CullFaceFrontBack", function() {
        return u
    }),
    r.d(t, "CullFaceNone", function() {
        return l
    }),
    r.d(t, "Curve", function() {
        return Jo
    }),
    r.d(t, "CurvePath", function() {
        return gc
    }),
    r.d(t, "CustomBlending", function() {
        return C
    }),
    r.d(t, "CylinderBufferGeometry", function() {
        return ao
    }),
    r.d(t, "CylinderGeometry", function() {
        return so
    }),
    r.d(t, "Cylindrical", function() {
        return jl
    }),
    r.d(t, "DataTexture", function() {
        return fr
    }),
    r.d(t, "DataTexture2DArray", function() {
        return Wi
    }),
    r.d(t, "DataTexture3D", function() {
        return Yi
    }),
    r.d(t, "DataTextureLoader", function() {
        return Yo
    }),
    r.d(t, "DefaultLoadingManager", function() {
        return Uo
    }),
    r.d(t, "DepthFormat", function() {
        return Ye
    }),
    r.d(t, "DepthStencilFormat", function() {
        return Ze
    }),
    r.d(t, "DepthTexture", function() {
        return Qs
    }),
    r.d(t, "DirectionalLight", function() {
        return Ac
    }),
    r.d(t, "DirectionalLightHelper", function() {
        return ep
    }),
    r.d(t, "DirectionalLightShadow", function() {
        return Ec
    }),
    r.d(t, "DiscreteInterpolant", function() {
        return Po
    }),
    r.d(t, "DodecahedronBufferGeometry", function() {
        return ha
    }),
    r.d(t, "DodecahedronGeometry", function() {
        return pa
    }),
    r.d(t, "DoubleSide", function() {
        return w
    }),
    r.d(t, "DstAlphaFactor", function() {
        return H
    }),
    r.d(t, "DstColorFactor", function() {
        return W
    }),
    r.d(t, "DynamicBufferAttribute", function() {
        return bp
    }),
    r.d(t, "EdgesGeometry", function() {
        return no
    }),
    r.d(t, "EdgesHelper", function() {
        return kp
    }),
    r.d(t, "EllipseCurve", function() {
        return Ko
    }),
    r.d(t, "EqualDepth", function() {
        return Q
    }),
    r.d(t, "EquirectangularReflectionMapping", function() {
        return fe
    }),
    r.d(t, "EquirectangularRefractionMapping", function() {
        return me
    }),
    r.d(t, "Euler", function() {
        return Dr
    }),
    r.d(t, "EventDispatcher", function() {
        return i
    }),
    r.d(t, "ExtrudeBufferGeometry", function() {
        return Va
    }),
    r.d(t, "ExtrudeGeometry", function() {
        return Ha
    }),
    r.d(t, "Face3", function() {
        return kr
    }),
    r.d(t, "Face4", function() {
        return op
    }),
    r.d(t, "FaceColors", function() {
        return S
    }),
    r.d(t, "FaceNormalsHelper", function() {
        return $l
    }),
    r.d(t, "FileLoader", function() {
        return Ho
    }),
    r.d(t, "FlatShading", function() {
        return x
    }),
    r.d(t, "Float32Attribute", function() {
        return Ap
    }),
    r.d(t, "Float32BufferAttribute", function() {
        return ri
    }),
    r.d(t, "Float64Attribute", function() {
        return Pp
    }),
    r.d(t, "Float64BufferAttribute", function() {
        return ii
    }),
    r.d(t, "FloatType", function() {
        return ke
    }),
    r.d(t, "Fog", function() {
        return Is
    }),
    r.d(t, "FogExp2", function() {
        return Ls
    }),
    r.d(t, "Font", function() {
        return Zc
    }),
    r.d(t, "FontLoader", function() {
        return qc
    }),
    r.d(t, "FrontFaceDirectionCCW", function() {
        return f
    }),
    r.d(t, "FrontFaceDirectionCW", function() {
        return d
    }),
    r.d(t, "FrontSide", function() {
        return y
    }),
    r.d(t, "Frustum", function() {
        return yr
    }),
    r.d(t, "GammaEncoding", function() {
        return Lt
    }),
    r.d(t, "Geometry", function() {
        return Zr
    }),
    r.d(t, "GeometryUtils", function() {
        return Np
    }),
    r.d(t, "GreaterDepth", function() {
        return ee
    }),
    r.d(t, "GreaterEqualDepth", function() {
        return $
    }),
    r.d(t, "GridHelper", function() {
        return Jl
    }),
    r.d(t, "Group", function() {
        return gs
    }),
    r.d(t, "HalfFloatType", function() {
        return De
    }),
    r.d(t, "HemisphereLight", function() {
        return wc
    }),
    r.d(t, "HemisphereLightHelper", function() {
        return Xl
    }),
    r.d(t, "HemisphereLightProbe", function() {
        return tl
    }),
    r.d(t, "IcosahedronBufferGeometry", function() {
        return la
    }),
    r.d(t, "IcosahedronGeometry", function() {
        return ca
    }),
    r.d(t, "ImageBitmapLoader", function() {
        return Wc
    }),
    r.d(t, "ImageLoader", function() {
        return Zo
    }),
    r.d(t, "ImageUtils", function() {
        return or
    }),
    r.d(t, "ImmediateRenderObject", function() {
        return Gl
    }),
    r.d(t, "InstancedBufferAttribute", function() {
        return Ic
    }),
    r.d(t, "InstancedBufferGeometry", function() {
        return Lc
    }),
    r.d(t, "InstancedInterleavedBuffer", function() {
        return kl
    }),
    r.d(t, "Int16Attribute", function() {
        return _p
    }),
    r.d(t, "Int16BufferAttribute", function() {
        return Qr
    }),
    r.d(t, "Int32Attribute", function() {
        return Tp
    }),
    r.d(t, "Int32BufferAttribute", function() {
        return ei
    }),
    r.d(t, "Int8Attribute", function() {
        return wp
    }),
    r.d(t, "Int8BufferAttribute", function() {
        return qr
    }),
    r.d(t, "IntType", function() {
        return Le
    }),
    r.d(t, "InterleavedBuffer", function() {
        return Ds
    }),
    r.d(t, "InterleavedBufferAttribute", function() {
        return zs
    }),
    r.d(t, "Interpolant", function() {
        return To
    }),
    r.d(t, "InterpolateDiscrete", function() {
        return xt
    }),
    r.d(t, "InterpolateLinear", function() {
        return Mt
    }),
    r.d(t, "InterpolateSmooth", function() {
        return _t
    }),
    r.d(t, "JSONLoader", function() {
        return Fp
    }),
    r.d(t, "KeyframeTrack", function() {
        return Oo
    }),
    r.d(t, "LOD", function() {
        return js
    }),
    r.d(t, "LatheBufferGeometry", function() {
        return eo
    }),
    r.d(t, "LatheGeometry", function() {
        return $a
    }),
    r.d(t, "Layers", function() {
        return zr
    }),
    r.d(t, "LensFlare", function() {
        return Gp
    }),
    r.d(t, "LessDepth", function() {
        return J
    }),
    r.d(t, "LessEqualDepth", function() {
        return K
    }),
    r.d(t, "Light", function() {
        return bc
    }),
    r.d(t, "LightProbe", function() {
        return el
    }),
    r.d(t, "LightProbeHelper", function() {
        return ql
    }),
    r.d(t, "LightShadow", function() {
        return xc
    }),
    r.d(t, "Line", function() {
        return Vs
    }),
    r.d(t, "Line3", function() {
        return Ul
    }),
    r.d(t, "LineBasicMaterial", function() {
        return Hs
    }),
    r.d(t, "LineCurve", function() {
        return pc
    }),
    r.d(t, "LineCurve3", function() {
        return hc
    }),
    r.d(t, "LineDashedMaterial", function() {
        return Mo
    }),
    r.d(t, "LineLoop", function() {
        return Ys
    }),
    r.d(t, "LinePieces", function() {
        return lp
    }),
    r.d(t, "LineSegments", function() {
        return Ws
    }),
    r.d(t, "LineStrip", function() {
        return cp
    }),
    r.d(t, "LinearEncoding", function() {
        return Rt
    }),
    r.d(t, "LinearFilter", function() {
        return Te
    }),
    r.d(t, "LinearInterpolant", function() {
        return Ao
    }),
    r.d(t, "LinearMipMapLinearFilter", function() {
        return Ae
    }),
    r.d(t, "LinearMipMapNearestFilter", function() {
        return Ee
    }),
    r.d(t, "LinearToneMapping", function() {
        return ae
    }),
    r.d(t, "Loader", function() {
        return Jc
    }),
    r.d(t, "LoaderUtils", function() {
        return Cc
    }),
    r.d(t, "LoadingManager", function() {
        return Fo
    }),
    r.d(t, "LogLuvEncoding", function() {
        return kt
    }),
    r.d(t, "LoopOnce", function() {
        return yt
    }),
    r.d(t, "LoopPingPong", function() {
        return wt
    }),
    r.d(t, "LoopRepeat", function() {
        return bt
    }),
    r.d(t, "LuminanceAlphaFormat", function() {
        return Ve
    }),
    r.d(t, "LuminanceFormat", function() {
        return He
    }),
    r.d(t, "MOUSE", function() {
        return c
    }),
    r.d(t, "Material", function() {
        return di
    }),
    r.d(t, "MaterialLoader", function() {
        return Rc
    }),
    r.d(t, "Math", function() {
        return Gt
    }),
    r.d(t, "Matrix3", function() {
        return Yt
    }),
    r.d(t, "Matrix4", function() {
        return br
    }),
    r.d(t, "MaxEquation", function() {
        return z
    }),
    r.d(t, "Mesh", function() {
        return Li
    }),
    r.d(t, "MeshBasicMaterial", function() {
        return Ci
    }),
    r.d(t, "MeshDepthMaterial", function() {
        return ps
    }),
    r.d(t, "MeshDistanceMaterial", function() {
        return hs
    }),
    r.d(t, "MeshFaceMaterial", function() {
        return pp
    }),
    r.d(t, "MeshLambertMaterial", function() {
        return wo
    }),
    r.d(t, "MeshMatcapMaterial", function() {
        return xo
    }),
    r.d(t, "MeshNormalMaterial", function() {
        return bo
    }),
    r.d(t, "MeshPhongMaterial", function() {
        return vo
    }),
    r.d(t, "MeshPhysicalMaterial", function() {
        return go
    }),
    r.d(t, "MeshStandardMaterial", function() {
        return mo
    }),
    r.d(t, "MeshToonMaterial", function() {
        return yo
    }),
    r.d(t, "MinEquation", function() {
        return D
    }),
    r.d(t, "MirroredRepeatWrapping", function() {
        return xe
    }),
    r.d(t, "MixOperation", function() {
        return ie
    }),
    r.d(t, "MultiMaterial", function() {
        return hp
    }),
    r.d(t, "MultiplyBlending", function() {
        return R
    }),
    r.d(t, "MultiplyOperation", function() {
        return re
    }),
    r.d(t, "NearestFilter", function() {
        return Me
    }),
    r.d(t, "NearestMipMapLinearFilter", function() {
        return Se
    }),
    r.d(t, "NearestMipMapNearestFilter", function() {
        return _e
    }),
    r.d(t, "NeverDepth", function() {
        return X
    }),
    r.d(t, "NoBlending", function() {
        return E
    }),
    r.d(t, "NoColors", function() {
        return _
    }),
    r.d(t, "NoToneMapping", function() {
        return se
    }),
    r.d(t, "NormalBlending", function() {
        return A
    }),
    r.d(t, "NotEqualDepth", function() {
        return te
    }),
    r.d(t, "NumberKeyframeTrack", function() {
        return Lo
    }),
    r.d(t, "Object3D", function() {
        return Hr
    }),
    r.d(t, "ObjectLoader", function() {
        return zc
    }),
    r.d(t, "ObjectSpaceNormalMap", function() {
        return Ut
    }),
    r.d(t, "OctahedronBufferGeometry", function() {
        return oa
    }),
    r.d(t, "OctahedronGeometry", function() {
        return aa
    }),
    r.d(t, "OneFactor", function() {
        return N
    }),
    r.d(t, "OneMinusDstAlphaFactor", function() {
        return V
    }),
    r.d(t, "OneMinusDstColorFactor", function() {
        return Y
    }),
    r.d(t, "OneMinusSrcAlphaFactor", function() {
        return G
    }),
    r.d(t, "OneMinusSrcColorFactor", function() {
        return F
    }),
    r.d(t, "OrthographicCamera", function() {
        return Tc
    }),
    r.d(t, "PCFShadowMap", function() {
        return g
    }),
    r.d(t, "PCFSoftShadowMap", function() {
        return v
    }),
    r.d(t, "ParametricBufferGeometry", function() {
        return ta
    }),
    r.d(t, "ParametricGeometry", function() {
        return ea
    }),
    r.d(t, "Particle", function() {
        return dp
    }),
    r.d(t, "ParticleBasicMaterial", function() {
        return gp
    }),
    r.d(t, "ParticleSystem", function() {
        return fp
    }),
    r.d(t, "ParticleSystemMaterial", function() {
        return vp
    }),
    r.d(t, "Path", function() {
        return vc
    }),
    r.d(t, "PerspectiveCamera", function() {
        return ys
    }),
    r.d(t, "Plane", function() {
        return vr
    }),
    r.d(t, "PlaneBufferGeometry", function() {
        return hi
    }),
    r.d(t, "PlaneGeometry", function() {
        return pi
    }),
    r.d(t, "PlaneHelper", function() {
        return np
    }),
    r.d(t, "PointCloud", function() {
        return up
    }),
    r.d(t, "PointCloudMaterial", function() {
        return mp
    }),
    r.d(t, "PointLight", function() {
        return Sc
    }),
    r.d(t, "PointLightHelper", function() {
        return Yl
    }),
    r.d(t, "Points", function() {
        return Xs
    }),
    r.d(t, "PointsMaterial", function() {
        return Zs
    }),
    r.d(t, "PolarGridHelper", function() {
        return Kl
    }),
    r.d(t, "PolyhedronBufferGeometry", function() {
        return ia
    }),
    r.d(t, "PolyhedronGeometry", function() {
        return ra
    }),
    r.d(t, "PositionalAudio", function() {
        return pl
    }),
    r.d(t, "PositionalAudioHelper", function() {
        return Ql
    }),
    r.d(t, "PropertyBinding", function() {
        return Ol
    }),
    r.d(t, "PropertyMixer", function() {
        return ul
    }),
    r.d(t, "QuadraticBezierCurve", function() {
        return uc
    }),
    r.d(t, "QuadraticBezierCurve3", function() {
        return dc
    }),
    r.d(t, "Quaternion", function() {
        return Vt
    }),
    r.d(t, "QuaternionKeyframeTrack", function() {
        return ko
    }),
    r.d(t, "QuaternionLinearInterpolant", function() {
        return Io
    }),
    r.d(t, "REVISION", function() {
        return o
    }),
    r.d(t, "RGBADepthPacking", function() {
        return jt
    }),
    r.d(t, "RGBAFormat", function() {
        return Ge
    }),
    r.d(t, "RGBA_ASTC_10x10_Format", function() {
        return mt
    }),
    r.d(t, "RGBA_ASTC_10x5_Format", function() {
        return ut
    }),
    r.d(t, "RGBA_ASTC_10x6_Format", function() {
        return dt
    }),
    r.d(t, "RGBA_ASTC_10x8_Format", function() {
        return ft
    }),
    r.d(t, "RGBA_ASTC_12x10_Format", function() {
        return gt
    }),
    r.d(t, "RGBA_ASTC_12x12_Format", function() {
        return vt
    }),
    r.d(t, "RGBA_ASTC_4x4_Format", function() {
        return nt
    }),
    r.d(t, "RGBA_ASTC_5x4_Format", function() {
        return st
    }),
    r.d(t, "RGBA_ASTC_5x5_Format", function() {
        return at
    }),
    r.d(t, "RGBA_ASTC_6x5_Format", function() {
        return ot
    }),
    r.d(t, "RGBA_ASTC_6x6_Format", function() {
        return ct
    }),
    r.d(t, "RGBA_ASTC_8x5_Format", function() {
        return lt
    }),
    r.d(t, "RGBA_ASTC_8x6_Format", function() {
        return pt
    }),
    r.d(t, "RGBA_ASTC_8x8_Format", function() {
        return ht
    }),
    r.d(t, "RGBA_PVRTC_2BPPV1_Format", function() {
        return rt
    }),
    r.d(t, "RGBA_PVRTC_4BPPV1_Format", function() {
        return tt
    }),
    r.d(t, "RGBA_S3TC_DXT1_Format", function() {
        return Je
    }),
    r.d(t, "RGBA_S3TC_DXT3_Format", function() {
        return Ke
    }),
    r.d(t, "RGBA_S3TC_DXT5_Format", function() {
        return Qe
    }),
    r.d(t, "RGBDEncoding", function() {
        return Bt
    }),
    r.d(t, "RGBEEncoding", function() {
        return It
    }),
    r.d(t, "RGBEFormat", function() {
        return We
    }),
    r.d(t, "RGBFormat", function() {
        return Ue
    }),
    r.d(t, "RGBM16Encoding", function() {
        return zt
    }),
    r.d(t, "RGBM7Encoding", function() {
        return Dt
    }),
    r.d(t, "RGB_ETC1_Format", function() {
        return it
    }),
    r.d(t, "RGB_PVRTC_2BPPV1_Format", function() {
        return et
    }),
    r.d(t, "RGB_PVRTC_4BPPV1_Format", function() {
        return $e
    }),
    r.d(t, "RGB_S3TC_DXT1_Format", function() {
        return qe
    }),
    r.d(t, "RawShaderMaterial", function() {
        return fo
    }),
    r.d(t, "Ray", function() {
        return Oi
    }),
    r.d(t, "Raycaster", function() {
        return Dl
    }),
    r.d(t, "RectAreaLight", function() {
        return Oc
    }),
    r.d(t, "RectAreaLightHelper", function() {
        return Zl
    }),
    r.d(t, "RedFormat", function() {
        return Xe
    }),
    r.d(t, "ReinhardToneMapping", function() {
        return oe
    }),
    r.d(t, "RepeatWrapping", function() {
        return be
    }),
    r.d(t, "ReverseSubtractEquation", function() {
        return k
    }),
    r.d(t, "RingBufferGeometry", function() {
        return Qa
    }),
    r.d(t, "RingGeometry", function() {
        return Ka
    }),
    r.d(t, "Scene", function() {
        return ks
    }),
    r.d(t, "SceneUtils", function() {
        return Up
    }),
    r.d(t, "ShaderChunk", function() {
        return wr
    }),
    r.d(t, "ShaderLib", function() {
        return Cr
    }),
    r.d(t, "ShaderMaterial", function() {
        return Pi
    }),
    r.d(t, "ShadowMaterial", function() {
        return uo
    }),
    r.d(t, "Shape", function() {
        return yc
    }),
    r.d(t, "ShapeBufferGeometry", function() {
        return ro
    }),
    r.d(t, "ShapeGeometry", function() {
        return to
    }),
    r.d(t, "ShapePath", function() {
        return Yc
    }),
    r.d(t, "ShapeUtils", function() {
        return Fa
    }),
    r.d(t, "ShortType", function() {
        return Re
    }),
    r.d(t, "Skeleton", function() {
        return Us
    }),
    r.d(t, "SkeletonHelper", function() {
        return Wl
    }),
    r.d(t, "SkinnedMesh", function() {
        return Fs
    }),
    r.d(t, "SmoothShading", function() {
        return M
    }),
    r.d(t, "Sphere", function() {
        return gr
    }),
    r.d(t, "SphereBufferGeometry", function() {
        return Ja
    }),
    r.d(t, "SphereGeometry", function() {
        return qa
    }),
    r.d(t, "Spherical", function() {
        return Nl
    }),
    r.d(t, "SphericalHarmonics3", function() {
        return $c
    }),
    r.d(t, "SphericalReflectionMapping", function() {
        return ge
    }),
    r.d(t, "Spline", function() {
        return Cp
    }),
    r.d(t, "SplineCurve", function() {
        return fc
    }),
    r.d(t, "SplineCurve3", function() {
        return Rp
    }),
    r.d(t, "SpotLight", function() {
        return _c
    }),
    r.d(t, "SpotLightHelper", function() {
        return Vl
    }),
    r.d(t, "SpotLightShadow", function() {
        return Mc
    }),
    r.d(t, "Sprite", function() {
        return Ns
    }),
    r.d(t, "SpriteMaterial", function() {
        return Bs
    }),
    r.d(t, "SrcAlphaFactor", function() {
        return U
    }),
    r.d(t, "SrcAlphaSaturateFactor", function() {
        return Z
    }),
    r.d(t, "SrcColorFactor", function() {
        return j
    }),
    r.d(t, "StereoCamera", function() {
        return il
    }),
    r.d(t, "StringKeyframeTrack", function() {
        return Do
    }),
    r.d(t, "SubtractEquation", function() {
        return I
    }),
    r.d(t, "SubtractiveBlending", function() {
        return O
    }),
    r.d(t, "TangentSpaceNormalMap", function() {
        return Ft
    }),
    r.d(t, "TetrahedronBufferGeometry", function() {
        return sa
    }),
    r.d(t, "TetrahedronGeometry", function() {
        return na
    }),
    r.d(t, "TextBufferGeometry", function() {
        return Xa
    }),
    r.d(t, "TextGeometry", function() {
        return Za
    }),
    r.d(t, "Texture", function() {
        return lr
    }),
    r.d(t, "TextureLoader", function() {
        return qo
    }),
    r.d(t, "TorusBufferGeometry", function() {
        return va
    }),
    r.d(t, "TorusGeometry", function() {
        return ga
    }),
    r.d(t, "TorusKnotBufferGeometry", function() {
        return ma
    }),
    r.d(t, "TorusKnotGeometry", function() {
        return fa
    }),
    r.d(t, "Triangle", function() {
        return Ri
    }),
    r.d(t, "TriangleFanDrawMode", function() {
        return Ot
    }),
    r.d(t, "TriangleStripDrawMode", function() {
        return Pt
    }),
    r.d(t, "TrianglesDrawMode", function() {
        return At
    }),
    r.d(t, "TubeBufferGeometry", function() {
        return da
    }),
    r.d(t, "TubeGeometry", function() {
        return ua
    }),
    r.d(t, "UVMapping", function() {
        return he
    }),
    r.d(t, "Uint16Attribute", function() {
        return Sp
    }),
    r.d(t, "Uint16BufferAttribute", function() {
        return $r
    }),
    r.d(t, "Uint32Attribute", function() {
        return Ep
    }),
    r.d(t, "Uint32BufferAttribute", function() {
        return ti
    }),
    r.d(t, "Uint8Attribute", function() {
        return xp
    }),
    r.d(t, "Uint8BufferAttribute", function() {
        return Jr
    }),
    r.d(t, "Uint8ClampedAttribute", function() {
        return Mp
    }),
    r.d(t, "Uint8ClampedBufferAttribute", function() {
        return Kr
    }),
    r.d(t, "Uncharted2ToneMapping", function() {
        return ce
    }),
    r.d(t, "Uniform", function() {
        return Il
    }),
    r.d(t, "UniformsLib", function() {
        return Rr
    }),
    r.d(t, "UniformsUtils", function() {
        return Er
    }),
    r.d(t, "UnsignedByteType", function() {
        return Pe
    }),
    r.d(t, "UnsignedInt248Type", function() {
        return je
    }),
    r.d(t, "UnsignedIntType", function() {
        return Ie
    }),
    r.d(t, "UnsignedShort4444Type", function() {
        return ze
    }),
    r.d(t, "UnsignedShort5551Type", function() {
        return Be
    }),
    r.d(t, "UnsignedShort565Type", function() {
        return Ne
    }),
    r.d(t, "UnsignedShortType", function() {
        return Ce
    }),
    r.d(t, "Vector2", function() {
        return Ht
    }),
    r.d(t, "Vector3", function() {
        return Wt
    }),
    r.d(t, "Vector4", function() {
        return pr
    }),
    r.d(t, "VectorKeyframeTrack", function() {
        return zo
    }),
    r.d(t, "Vertex", function() {
        return yp
    }),
    r.d(t, "VertexColors", function() {
        return T
    }),
    r.d(t, "VertexNormalsHelper", function() {
        return Hl
    }),
    r.d(t, "VideoTexture", function() {
        return qs
    }),
    r.d(t, "WebGLMultisampleRenderTarget", function() {
        return ur
    }),
    r.d(t, "WebGLRenderTarget", function() {
        return hr
    }),
    r.d(t, "WebGLRenderTargetCube", function() {
        return dr
    }),
    r.d(t, "WebGLRenderer", function() {
        return Cs
    }),
    r.d(t, "WebGLUtils", function() {
        return ms
    }),
    r.d(t, "WireframeGeometry", function() {
        return $s
    }),
    r.d(t, "WireframeHelper", function() {
        return Dp
    }),
    r.d(t, "WrapAroundEnding", function() {
        return Et
    }),
    r.d(t, "XHRLoader", function() {
        return zp
    }),
    r.d(t, "ZeroCurvatureEnding", function() {
        return St
    }),
    r.d(t, "ZeroFactor", function() {
        return B
    }),
    r.d(t, "ZeroSlopeEnding", function() {
        return Tt
    }),
    r.d(t, "sRGBEncoding", function() {
        return Ct
    }),
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }
    ),
    void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }
    ),
    "name"in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), r = 1; r < arguments.length; r++) {
            var i = arguments[r];
            if (null != i)
                for (var n in i)
                    Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
        }
        return t
    }
    ),
    Object.assign(i.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var r = this._listeners;
            void 0 === r[e] && (r[e] = []),
            -1 === r[e].indexOf(t) && r[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            var r = this._listeners;
            return void 0 !== r[e] && -1 !== r[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var r = this._listeners[e];
                if (void 0 !== r) {
                    var i = r.indexOf(t);
                    -1 !== i && r.splice(i, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var r = t.slice(0), i = 0, n = r.length; i < n; i++)
                        r[i].call(this, e)
                }
            }
        }
    });
    var n, s, a, o = "105", c = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, l = 0, p = 1, h = 2, u = 3, d = 0, f = 1, m = 0, g = 1, v = 2, y = 0, b = 1, w = 2, x = 1, M = 2, _ = 0, S = 1, T = 2, E = 0, A = 1, P = 2, O = 3, R = 4, C = 5, L = 100, I = 101, k = 102, D = 103, z = 104, B = 200, N = 201, j = 202, F = 203, U = 204, G = 205, H = 206, V = 207, W = 208, Y = 209, Z = 210, X = 0, q = 1, J = 2, K = 3, Q = 4, $ = 5, ee = 6, te = 7, re = 0, ie = 1, ne = 2, se = 0, ae = 1, oe = 2, ce = 3, le = 4, pe = 5, he = 300, ue = 301, de = 302, fe = 303, me = 304, ge = 305, ve = 306, ye = 307, be = 1e3, we = 1001, xe = 1002, Me = 1003, _e = 1004, Se = 1005, Te = 1006, Ee = 1007, Ae = 1008, Pe = 1009, Oe = 1010, Re = 1011, Ce = 1012, Le = 1013, Ie = 1014, ke = 1015, De = 1016, ze = 1017, Be = 1018, Ne = 1019, je = 1020, Fe = 1021, Ue = 1022, Ge = 1023, He = 1024, Ve = 1025, We = Ge, Ye = 1026, Ze = 1027, Xe = 1028, qe = 33776, Je = 33777, Ke = 33778, Qe = 33779, $e = 35840, et = 35841, tt = 35842, rt = 35843, it = 36196, nt = 37808, st = 37809, at = 37810, ot = 37811, ct = 37812, lt = 37813, pt = 37814, ht = 37815, ut = 37816, dt = 37817, ft = 37818, mt = 37819, gt = 37820, vt = 37821, yt = 2200, bt = 2201, wt = 2202, xt = 2300, Mt = 2301, _t = 2302, St = 2400, Tt = 2401, Et = 2402, At = 0, Pt = 1, Ot = 2, Rt = 3e3, Ct = 3001, Lt = 3007, It = 3002, kt = 3003, Dt = 3004, zt = 3005, Bt = 3006, Nt = 3200, jt = 3201, Ft = 0, Ut = 1, Gt = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var e = [], t = 0; t < 256; t++)
                e[t] = (t < 16 ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & r] + e[r >> 8 & 255] + "-" + e[r >> 16 & 15 | 64] + e[r >> 24 & 255] + "-" + e[63 & i | 128] + e[i >> 8 & 255] + "-" + e[i >> 16 & 255] + e[i >> 24 & 255] + e[255 & n] + e[n >> 8 & 255] + e[n >> 16 & 255] + e[n >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, r) {
            return Math.max(t, Math.min(r, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, r, i, n) {
            return i + (e - t) * (n - i) / (r - t)
        },
        lerp: function(e, t, r) {
            return (1 - r) * e + r * t
        },
        smoothstep: function(e, t, r) {
            return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, r) {
            return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * Gt.DEG2RAD
        },
        radToDeg: function(e) {
            return e * Gt.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    function Ht(e, t) {
        this.x = e || 0,
        this.y = t || 0
    }
    function Vt(e, t, r, i) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = r || 0,
        this._w = void 0 !== i ? i : 1
    }
    function Wt(e, t, r) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = r || 0
    }
    function Yt() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(Ht.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }),
    Object.assign(Ht.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        },
        multiply: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x
              , r = this.y
              , i = e.elements;
            return this.x = i[0] * t + i[3] * r + i[6],
            this.y = i[1] * t + i[4] * r + i[7],
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        },
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI),
            e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y;
            return t * t + r * r
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        },
        rotateAround: function(e, t) {
            var r = Math.cos(t)
              , i = Math.sin(t)
              , n = this.x - e.x
              , s = this.y - e.y;
            return this.x = n * r - s * i + e.x,
            this.y = n * i + s * r + e.y,
            this
        }
    }),
    Object.assign(Vt, {
        slerp: function(e, t, r, i) {
            return r.copy(e).slerp(t, i)
        },
        slerpFlat: function(e, t, r, i, n, s, a) {
            var o = r[i + 0]
              , c = r[i + 1]
              , l = r[i + 2]
              , p = r[i + 3]
              , h = n[s + 0]
              , u = n[s + 1]
              , d = n[s + 2]
              , f = n[s + 3];
            if (p !== f || o !== h || c !== u || l !== d) {
                var m = 1 - a
                  , g = o * h + c * u + l * d + p * f
                  , v = g >= 0 ? 1 : -1
                  , y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var b = Math.sqrt(y)
                      , w = Math.atan2(b, g * v);
                    m = Math.sin(m * w) / b,
                    a = Math.sin(a * w) / b
                }
                var x = a * v;
                if (o = o * m + h * x,
                c = c * m + u * x,
                l = l * m + d * x,
                p = p * m + f * x,
                m === 1 - a) {
                    var M = 1 / Math.sqrt(o * o + c * c + l * l + p * p);
                    o *= M,
                    c *= M,
                    l *= M,
                    p *= M
                }
            }
            e[t] = o,
            e[t + 1] = c,
            e[t + 2] = l,
            e[t + 3] = p
        }
    }),
    Object.defineProperties(Vt.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(Vt.prototype, {
        isQuaternion: !0,
        set: function(e, t, r, i) {
            return this._x = e,
            this._y = t,
            this._z = r,
            this._w = i,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var r = e._x
              , i = e._y
              , n = e._z
              , s = e.order
              , a = Math.cos
              , o = Math.sin
              , c = a(r / 2)
              , l = a(i / 2)
              , p = a(n / 2)
              , h = o(r / 2)
              , u = o(i / 2)
              , d = o(n / 2);
            return "XYZ" === s ? (this._x = h * l * p + c * u * d,
            this._y = c * u * p - h * l * d,
            this._z = c * l * d + h * u * p,
            this._w = c * l * p - h * u * d) : "YXZ" === s ? (this._x = h * l * p + c * u * d,
            this._y = c * u * p - h * l * d,
            this._z = c * l * d - h * u * p,
            this._w = c * l * p + h * u * d) : "ZXY" === s ? (this._x = h * l * p - c * u * d,
            this._y = c * u * p + h * l * d,
            this._z = c * l * d + h * u * p,
            this._w = c * l * p - h * u * d) : "ZYX" === s ? (this._x = h * l * p - c * u * d,
            this._y = c * u * p + h * l * d,
            this._z = c * l * d - h * u * p,
            this._w = c * l * p + h * u * d) : "YZX" === s ? (this._x = h * l * p + c * u * d,
            this._y = c * u * p + h * l * d,
            this._z = c * l * d - h * u * p,
            this._w = c * l * p - h * u * d) : "XZY" === s && (this._x = h * l * p - c * u * d,
            this._y = c * u * p - h * l * d,
            this._z = c * l * d + h * u * p,
            this._w = c * l * p + h * u * d),
            !1 !== t && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(e, t) {
            var r = t / 2
              , i = Math.sin(r);
            return this._x = e.x * i,
            this._y = e.y * i,
            this._z = e.z * i,
            this._w = Math.cos(r),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e) {
            var t, r = e.elements, i = r[0], n = r[4], s = r[8], a = r[1], o = r[5], c = r[9], l = r[2], p = r[6], h = r[10], u = i + o + h;
            return u > 0 ? (t = .5 / Math.sqrt(u + 1),
            this._w = .25 / t,
            this._x = (p - c) * t,
            this._y = (s - l) * t,
            this._z = (a - n) * t) : i > o && i > h ? (t = 2 * Math.sqrt(1 + i - o - h),
            this._w = (p - c) / t,
            this._x = .25 * t,
            this._y = (n + a) / t,
            this._z = (s + l) / t) : o > h ? (t = 2 * Math.sqrt(1 + o - i - h),
            this._w = (s - l) / t,
            this._x = (n + a) / t,
            this._y = .25 * t,
            this._z = (c + p) / t) : (t = 2 * Math.sqrt(1 + h - i - o),
            this._w = (a - n) / t,
            this._x = (s + l) / t,
            this._y = (c + p) / t,
            this._z = .25 * t),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function(e, t) {
            var r = e.dot(t) + 1;
            return r < 1e-6 ? (r = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = r) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = r),
            this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(Gt.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var r = this.angleTo(e);
            if (0 === r)
                return this;
            var i = Math.min(1, t / r);
            return this.slerp(e, i),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this.onChangeCallback(),
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var r = e._x
              , i = e._y
              , n = e._z
              , s = e._w
              , a = t._x
              , o = t._y
              , c = t._z
              , l = t._w;
            return this._x = r * l + s * a + i * c - n * o,
            this._y = i * l + s * o + n * a - r * c,
            this._z = n * l + s * c + r * o - i * a,
            this._w = s * l - r * a - i * o - n * c,
            this.onChangeCallback(),
            this
        },
        slerp: function(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            var r = this._x
              , i = this._y
              , n = this._z
              , s = this._w
              , a = s * e._w + r * e._x + i * e._y + n * e._z;
            if (a < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a) : this.copy(e),
            a >= 1)
                return this._w = s,
                this._x = r,
                this._y = i,
                this._z = n,
                this;
            var o = 1 - a * a;
            if (o <= Number.EPSILON) {
                var c = 1 - t;
                return this._w = c * s + t * this._w,
                this._x = c * r + t * this._x,
                this._y = c * i + t * this._y,
                this._z = c * n + t * this._z,
                this.normalize()
            }
            var l = Math.sqrt(o)
              , p = Math.atan2(l, a)
              , h = Math.sin((1 - t) * p) / l
              , u = Math.sin(t * p) / l;
            return this._w = s * h + this._w * u,
            this._x = r * h + this._x * u,
            this._y = i * h + this._y * u,
            this._z = n * h + this._z * u,
            this.onChangeCallback(),
            this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Wt.prototype, {
        isVector3: !0,
        set: function(e, t, r) {
            return this.x = e,
            this.y = t,
            this.z = r,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        },
        applyEuler: (s = new Vt,
        function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(s.setFromEuler(e))
        }
        ),
        applyAxisAngle: function() {
            var e = new Vt;
            return function(t, r) {
                return this.applyQuaternion(e.setFromAxisAngle(t, r))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements;
            return this.x = n[0] * t + n[3] * r + n[6] * i,
            this.y = n[1] * t + n[4] * r + n[7] * i,
            this.z = n[2] * t + n[5] * r + n[8] * i,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements
              , s = 1 / (n[3] * t + n[7] * r + n[11] * i + n[15]);
            return this.x = (n[0] * t + n[4] * r + n[8] * i + n[12]) * s,
            this.y = (n[1] * t + n[5] * r + n[9] * i + n[13]) * s,
            this.z = (n[2] * t + n[6] * r + n[10] * i + n[14]) * s,
            this
        },
        applyQuaternion: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.x
              , s = e.y
              , a = e.z
              , o = e.w
              , c = o * t + s * i - a * r
              , l = o * r + a * t - n * i
              , p = o * i + n * r - s * t
              , h = -n * t - s * r - a * i;
            return this.x = c * o + h * -n + l * -a - p * -s,
            this.y = l * o + h * -s + p * -n - c * -a,
            this.z = p * o + h * -a + c * -s - l * -n,
            this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements;
            return this.x = n[0] * t + n[4] * r + n[8] * i,
            this.y = n[1] * t + n[5] * r + n[9] * i,
            this.z = n[2] * t + n[6] * r + n[10] * i,
            this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        },
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , s = t.x
              , a = t.y
              , o = t.z;
            return this.x = i * o - n * a,
            this.y = n * s - r * o,
            this.z = r * a - i * s,
            this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: (n = new Wt,
        function(e) {
            return n.copy(this).projectOnVector(e),
            this.sub(n)
        }
        ),
        reflect: function() {
            var e = new Wt;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(Gt.clamp(t, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y
              , i = this.z - e.z;
            return t * t + r * r + i * i
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, r) {
            var i = Math.sin(t) * e;
            return this.x = i * Math.sin(r),
            this.y = Math.cos(t) * e,
            this.z = i * Math.cos(r),
            this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, r) {
            return this.x = e * Math.sin(t),
            this.y = r,
            this.z = e * Math.cos(t),
            this
        },
        setFromMatrixPosition: function(e) {
            var t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , r = this.setFromMatrixColumn(e, 1).length()
              , i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = r,
            this.z = i,
            this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
    }),
    Object.assign(Yt.prototype, {
        isMatrix3: !0,
        set: function(e, t, r, i, n, s, a, o, c) {
            var l = this.elements;
            return l[0] = e,
            l[1] = i,
            l[2] = a,
            l[3] = t,
            l[4] = n,
            l[5] = o,
            l[6] = r,
            l[7] = s,
            l[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        applyToBufferAttribute: function() {
            var e = new Wt;
            return function(t) {
                for (var r = 0, i = t.count; r < i; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.applyMatrix3(this),
                    t.setXYZ(r, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var r = e.elements
              , i = t.elements
              , n = this.elements
              , s = r[0]
              , a = r[3]
              , o = r[6]
              , c = r[1]
              , l = r[4]
              , p = r[7]
              , h = r[2]
              , u = r[5]
              , d = r[8]
              , f = i[0]
              , m = i[3]
              , g = i[6]
              , v = i[1]
              , y = i[4]
              , b = i[7]
              , w = i[2]
              , x = i[5]
              , M = i[8];
            return n[0] = s * f + a * v + o * w,
            n[3] = s * m + a * y + o * x,
            n[6] = s * g + a * b + o * M,
            n[1] = c * f + l * v + p * w,
            n[4] = c * m + l * y + p * x,
            n[7] = c * g + l * b + p * M,
            n[2] = h * f + u * v + d * w,
            n[5] = h * m + u * y + d * x,
            n[8] = h * g + u * b + d * M,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , r = e[1]
              , i = e[2]
              , n = e[3]
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , c = e[7]
              , l = e[8];
            return t * s * l - t * a * c - r * n * l + r * a * o + i * n * c - i * s * o
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var r = e.elements
              , i = this.elements
              , n = r[0]
              , s = r[1]
              , a = r[2]
              , o = r[3]
              , c = r[4]
              , l = r[5]
              , p = r[6]
              , h = r[7]
              , u = r[8]
              , d = u * c - l * h
              , f = l * p - u * o
              , m = h * o - c * p
              , g = n * d + s * f + a * m;
            if (0 === g) {
                var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t)
                    throw new Error(v);
                return console.warn(v),
                this.identity()
            }
            var y = 1 / g;
            return i[0] = d * y,
            i[1] = (a * h - u * s) * y,
            i[2] = (l * s - a * c) * y,
            i[3] = f * y,
            i[4] = (u * n - a * p) * y,
            i[5] = (a * o - l * n) * y,
            i[6] = m * y,
            i[7] = (s * p - h * n) * y,
            i[8] = (c * n - s * o) * y,
            this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        },
        setUvTransform: function(e, t, r, i, n, s, a) {
            var o = Math.cos(n)
              , c = Math.sin(n);
            this.set(r * o, r * c, -r * (o * s + c * a) + s + e, -i * c, i * o, -i * (-c * s + o * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var r = this.elements;
            return r[0] *= e,
            r[3] *= e,
            r[6] *= e,
            r[1] *= t,
            r[4] *= t,
            r[7] *= t,
            this
        },
        rotate: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e)
              , i = this.elements
              , n = i[0]
              , s = i[3]
              , a = i[6]
              , o = i[1]
              , c = i[4]
              , l = i[7];
            return i[0] = t * n + r * o,
            i[3] = t * s + r * c,
            i[6] = t * a + r * l,
            i[1] = -r * n + t * o,
            i[4] = -r * s + t * c,
            i[7] = -r * a + t * l,
            this
        },
        translate: function(e, t) {
            var r = this.elements;
            return r[0] += e * r[2],
            r[3] += e * r[5],
            r[6] += e * r[8],
            r[1] += t * r[2],
            r[4] += t * r[5],
            r[7] += t * r[8],
            this
        },
        equals: function(e) {
            for (var t = this.elements, r = e.elements, i = 0; i < 9; i++)
                if (t[i] !== r[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 9; r++)
                this.elements[r] = e[r + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e
        }
    });
    var Zt, Xt, qt, Jt, Kt, Qt, $t, er, tr, rr, ir, nr, sr, ar, or = {
        getDataURL: function(e) {
            var t;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === a && (a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                a.width = e.width,
                a.height = e.height;
                var r = a.getContext("2d");
                e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
                t = a
            }
            return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }, cr = 0;
    function lr(e, t, r, i, n, s, a, o, c, l) {
        Object.defineProperty(this, "id", {
            value: cr++
        }),
        this.uuid = Gt.generateUUID(),
        this.name = "",
        this.image = void 0 !== e ? e : lr.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== t ? t : lr.DEFAULT_MAPPING,
        this.wrapS = void 0 !== r ? r : we,
        this.wrapT = void 0 !== i ? i : we,
        this.magFilter = void 0 !== n ? n : Te,
        this.minFilter = void 0 !== s ? s : Ae,
        this.anisotropy = void 0 !== c ? c : 1,
        this.format = void 0 !== a ? a : Ge,
        this.type = void 0 !== o ? o : Pe,
        this.offset = new Ht(0,0),
        this.repeat = new Ht(1,1),
        this.center = new Ht(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Yt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== l ? l : Rt,
        this.version = 0,
        this.onUpdate = null
    }
    function pr(e, t, r, i) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = r || 0,
        this.w = void 0 !== i ? i : 1
    }
    function hr(e, t, r) {
        this.width = e,
        this.height = t,
        this.scissor = new pr(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new pr(0,0,e,t),
        r = r || {},
        this.texture = new lr(void 0,void 0,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),
        this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps,
        this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : Te,
        this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer,
        this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer,
        this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null
    }
    function ur(e, t, r) {
        hr.call(this, e, t, r),
        this.samples = 4
    }
    function dr(e, t, r) {
        hr.call(this, e, t, r)
    }
    function fr(e, t, r, i, n, s, a, o, c, l, p, h) {
        lr.call(this, null, s, a, o, c, l, i, n, p, h),
        this.image = {
            data: e,
            width: t,
            height: r
        },
        this.magFilter = void 0 !== c ? c : Me,
        this.minFilter = void 0 !== l ? l : Me,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
    function mr(e, t) {
        this.min = void 0 !== e ? e : new Wt(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Wt(-1 / 0,-1 / 0,-1 / 0)
    }
    function gr(e, t) {
        this.center = void 0 !== e ? e : new Wt,
        this.radius = void 0 !== t ? t : 0
    }
    function vr(e, t) {
        this.normal = void 0 !== e ? e : new Wt(1,0,0),
        this.constant = void 0 !== t ? t : 0
    }
    function yr(e, t, r, i, n, s) {
        this.planes = [void 0 !== e ? e : new vr, void 0 !== t ? t : new vr, void 0 !== r ? r : new vr, void 0 !== i ? i : new vr, void 0 !== n ? n : new vr, void 0 !== s ? s : new vr]
    }
    function br() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    lr.DEFAULT_IMAGE = void 0,
    lr.DEFAULT_MAPPING = he,
    lr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: lr,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = Gt.generateUUID()),
                !t && void 0 === e.images[i.uuid]) {
                    var n;
                    if (Array.isArray(i)) {
                        n = [];
                        for (var s = 0, a = i.length; s < a; s++)
                            n.push(or.getDataURL(i[s]))
                    } else
                        n = or.getDataURL(i);
                    e.images[i.uuid] = {
                        uuid: i.uuid,
                        url: n
                    }
                }
                r.image = i.uuid
            }
            return t || (e.textures[this.uuid] = r),
            r
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (this.mapping !== he)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case be:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case we:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case xe:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case be:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case we:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case xe:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
    }),
    Object.defineProperty(lr.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(pr.prototype, {
        isVector4: !0,
        set: function(e, t, r, i) {
            return this.x = e,
            this.y = t,
            this.z = r,
            this.w = i,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setW: function(e) {
            return this.w = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = this.w
              , s = e.elements;
            return this.x = s[0] * t + s[4] * r + s[8] * i + s[12] * n,
            this.y = s[1] * t + s[5] * r + s[9] * i + s[13] * n,
            this.z = s[2] * t + s[6] * r + s[10] * i + s[14] * n,
            this.w = s[3] * t + s[7] * r + s[11] * i + s[15] * n,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, r, i, n, s = e.elements, a = s[0], o = s[4], c = s[8], l = s[1], p = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
            if (Math.abs(o - l) < .01 && Math.abs(c - u) < .01 && Math.abs(h - d) < .01) {
                if (Math.abs(o + l) < .1 && Math.abs(c + u) < .1 && Math.abs(h + d) < .1 && Math.abs(a + p + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                var m = (a + 1) / 2
                  , g = (p + 1) / 2
                  , v = (f + 1) / 2
                  , y = (o + l) / 4
                  , b = (c + u) / 4
                  , w = (h + d) / 4;
                return m > g && m > v ? m < .01 ? (r = 0,
                i = .707106781,
                n = .707106781) : (i = y / (r = Math.sqrt(m)),
                n = b / r) : g > v ? g < .01 ? (r = .707106781,
                i = 0,
                n = .707106781) : (r = y / (i = Math.sqrt(g)),
                n = w / i) : v < .01 ? (r = .707106781,
                i = .707106781,
                n = 0) : (r = b / (n = Math.sqrt(v)),
                i = w / n),
                this.set(r, i, n, t),
                this
            }
            var x = Math.sqrt((d - h) * (d - h) + (c - u) * (c - u) + (l - o) * (l - o));
            return Math.abs(x) < .001 && (x = 1),
            this.x = (d - h) / x,
            this.y = (c - u) / x,
            this.z = (l - o) / x,
            this.w = Math.acos((a + p + f - 1) / 2),
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        },
        clampScalar: function(e, t) {
            return void 0 === Zt && (Zt = new pr,
            Xt = new pr),
            Zt.set(e, e, e, e),
            Xt.set(t, t, t, t),
            this.clamp(Zt, Xt)
        },
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
    }),
    hr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: hr,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    ur.prototype = Object.assign(Object.create(hr.prototype), {
        constructor: ur,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return hr.prototype.copy.call(this, e),
            this.samples = e.samples,
            this
        }
    }),
    dr.prototype = Object.create(hr.prototype),
    dr.prototype.constructor = dr,
    dr.prototype.isWebGLRenderTargetCube = !0,
    fr.prototype = Object.create(lr.prototype),
    fr.prototype.constructor = fr,
    fr.prototype.isDataTexture = !0,
    Object.assign(mr.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, r = 1 / 0, i = 1 / 0, n = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, c = e.length; o < c; o += 3) {
                var l = e[o]
                  , p = e[o + 1]
                  , h = e[o + 2];
                l < t && (t = l),
                p < r && (r = p),
                h < i && (i = h),
                l > n && (n = l),
                p > s && (s = p),
                h > a && (a = h)
            }
            return this.min.set(t, r, i),
            this.max.set(n, s, a),
            this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, r = 1 / 0, i = 1 / 0, n = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, c = e.count; o < c; o++) {
                var l = e.getX(o)
                  , p = e.getY(o)
                  , h = e.getZ(o);
                l < t && (t = l),
                p < r && (r = p),
                h < i && (i = h),
                l > n && (n = l),
                p > s && (s = p),
                h > a && (a = h)
            }
            return this.min.set(t, r, i),
            this.max.set(n, s, a),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new Wt;
            return function(t, r) {
                var i = e.copy(r).multiplyScalar(.5);
                return this.min.copy(t).sub(i),
                this.max.copy(t).add(i),
                this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
            e = new Wt),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
            e = new Wt),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        expandByObject: function() {
            var e, t, r, i = new Wt;
            function n(n) {
                var s = n.geometry;
                if (void 0 !== s)
                    if (s.isGeometry) {
                        var a = s.vertices;
                        for (t = 0,
                        r = a.length; t < r; t++)
                            i.copy(a[t]),
                            i.applyMatrix4(n.matrixWorld),
                            e.expandByPoint(i)
                    } else if (s.isBufferGeometry) {
                        var o = s.attributes.position;
                        if (void 0 !== o)
                            for (t = 0,
                            r = o.count; t < r; t++)
                                i.fromBufferAttribute(o, t).applyMatrix4(n.matrixWorld),
                                e.expandByPoint(i)
                    }
            }
            return function(t) {
                return e = this,
                t.updateMatrixWorld(!0),
                t.traverse(n),
                this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
            t = new Wt),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: (Jt = new Wt,
        function(e) {
            return this.clampPoint(e.center, Jt),
            Jt.distanceToSquared(e.center) <= e.radius * e.radius
        }
        ),
        intersectsPlane: function(e) {
            var t, r;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            r = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            r += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            r += e.normal.z * this.min.z),
            t <= -e.constant && r >= -e.constant
        },
        intersectsTriangle: function() {
            var e = new Wt
              , t = new Wt
              , r = new Wt
              , i = new Wt
              , n = new Wt
              , s = new Wt
              , a = new Wt
              , o = new Wt
              , c = new Wt
              , l = new Wt;
            function p(i) {
                var n, s;
                for (n = 0,
                s = i.length - 3; n <= s; n += 3) {
                    a.fromArray(i, n);
                    var o = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z)
                      , l = e.dot(a)
                      , p = t.dot(a)
                      , h = r.dot(a);
                    if (Math.max(-Math.max(l, p, h), Math.min(l, p, h)) > o)
                        return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(o),
                c.subVectors(this.max, o),
                e.subVectors(a.a, o),
                t.subVectors(a.b, o),
                r.subVectors(a.c, o),
                i.subVectors(t, e),
                n.subVectors(r, t),
                s.subVectors(e, r);
                var h = [0, -i.z, i.y, 0, -n.z, n.y, 0, -s.z, s.y, i.z, 0, -i.x, n.z, 0, -n.x, s.z, 0, -s.x, -i.y, i.x, 0, -n.y, n.x, 0, -s.y, s.x, 0];
                return !!p(h) && (!!p(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(i, n),
                p(h = [l.x, l.y, l.z])))
            }
        }(),
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            t = new Wt),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new Wt;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new Wt;
            return function(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
                this.getCenter(t.center),
                t.radius = .5 * this.getSize(e).length(),
                t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        applyMatrix4: (qt = [new Wt, new Wt, new Wt, new Wt, new Wt, new Wt, new Wt, new Wt],
        function(e) {
            return this.isEmpty() ? this : (qt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            qt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            qt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            qt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            qt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            qt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            qt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            qt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(qt),
            this)
        }
        ),
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(gr.prototype, {
        set: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        },
        setFromPoints: (Kt = new mr,
        function(e, t) {
            var r = this.center;
            void 0 !== t ? r.copy(t) : Kt.setFromPoints(e).getCenter(r);
            for (var i = 0, n = 0, s = e.length; n < s; n++)
                i = Math.max(i, r.distanceToSquared(e[n]));
            return this.radius = Math.sqrt(i),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var r = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            t = new Wt),
            t.copy(e),
            r > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            e = new mr),
            e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        },
        translate: function(e) {
            return this.center.add(e),
            this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }),
    Object.assign(vr.prototype, {
        set: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        },
        setComponents: function(e, t, r, i) {
            return this.normal.set(e, t, r),
            this.constant = i,
            this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function() {
            var e = new Wt
              , t = new Wt;
            return function(r, i, n) {
                var s = e.subVectors(n, i).cross(t.subVectors(r, i)).normalize();
                return this.setFromNormalAndCoplanarPoint(s, r),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            t = new Wt),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function() {
            var e = new Wt;
            return function(t, r) {
                void 0 === r && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                r = new Wt);
                var i = t.delta(e)
                  , n = this.normal.dot(i);
                if (0 === n)
                    return 0 === this.distanceToPoint(t.start) ? r.copy(t.start) : void 0;
                var s = -(t.start.dot(this.normal) + this.constant) / n;
                return s < 0 || s > 1 ? void 0 : r.copy(i).multiplyScalar(s).add(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start)
              , r = this.distanceToPoint(e.end);
            return t < 0 && r > 0 || r < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            e = new Wt),
            e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new Wt
              , t = new Yt;
            return function(r, i) {
                var n = i || t.getNormalMatrix(r)
                  , s = this.coplanarPoint(e).applyMatrix4(r)
                  , a = this.normal.applyMatrix3(n).normalize();
                return this.constant = -s.dot(a),
                this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }),
    Object.assign(yr.prototype, {
        set: function(e, t, r, i, n, s) {
            var a = this.planes;
            return a[0].copy(e),
            a[1].copy(t),
            a[2].copy(r),
            a[3].copy(i),
            a[4].copy(n),
            a[5].copy(s),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                t[r].copy(e.planes[r]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes
              , r = e.elements
              , i = r[0]
              , n = r[1]
              , s = r[2]
              , a = r[3]
              , o = r[4]
              , c = r[5]
              , l = r[6]
              , p = r[7]
              , h = r[8]
              , u = r[9]
              , d = r[10]
              , f = r[11]
              , m = r[12]
              , g = r[13]
              , v = r[14]
              , y = r[15];
            return t[0].setComponents(a - i, p - o, f - h, y - m).normalize(),
            t[1].setComponents(a + i, p + o, f + h, y + m).normalize(),
            t[2].setComponents(a + n, p + c, f + u, y + g).normalize(),
            t[3].setComponents(a - n, p - c, f - u, y - g).normalize(),
            t[4].setComponents(a - s, p - l, f - d, y - v).normalize(),
            t[5].setComponents(a + s, p + l, f + d, y + v).normalize(),
            this
        },
        intersectsObject: ($t = new gr,
        function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            $t.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere($t)
        }
        ),
        intersectsSprite: function() {
            var e = new gr;
            return function(t) {
                return e.center.set(0, 0, 0),
                e.radius = .7071067811865476,
                e.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            for (var t = this.planes, r = e.center, i = -e.radius, n = 0; n < 6; n++) {
                if (t[n].distanceToPoint(r) < i)
                    return !1
            }
            return !0
        },
        intersectsBox: (Qt = new Wt,
        function(e) {
            for (var t = this.planes, r = 0; r < 6; r++) {
                var i = t[r];
                if (Qt.x = i.normal.x > 0 ? e.max.x : e.min.x,
                Qt.y = i.normal.y > 0 ? e.max.y : e.min.y,
                Qt.z = i.normal.z > 0 ? e.max.z : e.min.z,
                i.distanceToPoint(Qt) < 0)
                    return !1
            }
            return !0
        }
        ),
        containsPoint: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                if (t[r].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    }),
    Object.assign(br.prototype, {
        isMatrix4: !0,
        set: function(e, t, r, i, n, s, a, o, c, l, p, h, u, d, f, m) {
            var g = this.elements;
            return g[0] = e,
            g[4] = t,
            g[8] = r,
            g[12] = i,
            g[1] = n,
            g[5] = s,
            g[9] = a,
            g[13] = o,
            g[2] = c,
            g[6] = l,
            g[10] = p,
            g[14] = h,
            g[3] = u,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new br).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            t[9] = r[9],
            t[10] = r[10],
            t[11] = r[11],
            t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            t[15] = r[15],
            this
        },
        copyPosition: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            this
        },
        extractBasis: function(e, t, r) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            r.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(e, t, r) {
            return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function() {
            var e = new Wt;
            return function(t) {
                var r = this.elements
                  , i = t.elements
                  , n = 1 / e.setFromMatrixColumn(t, 0).length()
                  , s = 1 / e.setFromMatrixColumn(t, 1).length()
                  , a = 1 / e.setFromMatrixColumn(t, 2).length();
                return r[0] = i[0] * n,
                r[1] = i[1] * n,
                r[2] = i[2] * n,
                r[3] = 0,
                r[4] = i[4] * s,
                r[5] = i[5] * s,
                r[6] = i[6] * s,
                r[7] = 0,
                r[8] = i[8] * a,
                r[9] = i[9] * a,
                r[10] = i[10] * a,
                r[11] = 0,
                r[12] = 0,
                r[13] = 0,
                r[14] = 0,
                r[15] = 1,
                this
            }
        }(),
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements
              , r = e.x
              , i = e.y
              , n = e.z
              , s = Math.cos(r)
              , a = Math.sin(r)
              , o = Math.cos(i)
              , c = Math.sin(i)
              , l = Math.cos(n)
              , p = Math.sin(n);
            if ("XYZ" === e.order) {
                var h = s * l
                  , u = s * p
                  , d = a * l
                  , f = a * p;
                t[0] = o * l,
                t[4] = -o * p,
                t[8] = c,
                t[1] = u + d * c,
                t[5] = h - f * c,
                t[9] = -a * o,
                t[2] = f - h * c,
                t[6] = d + u * c,
                t[10] = s * o
            } else if ("YXZ" === e.order) {
                var m = o * l
                  , g = o * p
                  , v = c * l
                  , y = c * p;
                t[0] = m + y * a,
                t[4] = v * a - g,
                t[8] = s * c,
                t[1] = s * p,
                t[5] = s * l,
                t[9] = -a,
                t[2] = g * a - v,
                t[6] = y + m * a,
                t[10] = s * o
            } else if ("ZXY" === e.order) {
                m = o * l,
                g = o * p,
                v = c * l,
                y = c * p;
                t[0] = m - y * a,
                t[4] = -s * p,
                t[8] = v + g * a,
                t[1] = g + v * a,
                t[5] = s * l,
                t[9] = y - m * a,
                t[2] = -s * c,
                t[6] = a,
                t[10] = s * o
            } else if ("ZYX" === e.order) {
                h = s * l,
                u = s * p,
                d = a * l,
                f = a * p;
                t[0] = o * l,
                t[4] = d * c - u,
                t[8] = h * c + f,
                t[1] = o * p,
                t[5] = f * c + h,
                t[9] = u * c - d,
                t[2] = -c,
                t[6] = a * o,
                t[10] = s * o
            } else if ("YZX" === e.order) {
                var b = s * o
                  , w = s * c
                  , x = a * o
                  , M = a * c;
                t[0] = o * l,
                t[4] = M - b * p,
                t[8] = x * p + w,
                t[1] = p,
                t[5] = s * l,
                t[9] = -a * l,
                t[2] = -c * l,
                t[6] = w * p + x,
                t[10] = b - M * p
            } else if ("XZY" === e.order) {
                b = s * o,
                w = s * c,
                x = a * o,
                M = a * c;
                t[0] = o * l,
                t[4] = -p,
                t[8] = c * l,
                t[1] = b * p + M,
                t[5] = s * l,
                t[9] = w * p - x,
                t[2] = x * p - w,
                t[6] = a * l,
                t[10] = M * p + b
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        },
        makeRotationFromQuaternion: (sr = new Wt(0,0,0),
        ar = new Wt(1,1,1),
        function(e) {
            return this.compose(sr, e, ar)
        }
        ),
        lookAt: (rr = new Wt,
        ir = new Wt,
        nr = new Wt,
        function(e, t, r) {
            var i = this.elements;
            return nr.subVectors(e, t),
            0 === nr.lengthSq() && (nr.z = 1),
            nr.normalize(),
            rr.crossVectors(r, nr),
            0 === rr.lengthSq() && (1 === Math.abs(r.z) ? nr.x += 1e-4 : nr.z += 1e-4,
            nr.normalize(),
            rr.crossVectors(r, nr)),
            rr.normalize(),
            ir.crossVectors(nr, rr),
            i[0] = rr.x,
            i[4] = ir.x,
            i[8] = nr.x,
            i[1] = rr.y,
            i[5] = ir.y,
            i[9] = nr.y,
            i[2] = rr.z,
            i[6] = ir.z,
            i[10] = nr.z,
            this
        }
        ),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var r = e.elements
              , i = t.elements
              , n = this.elements
              , s = r[0]
              , a = r[4]
              , o = r[8]
              , c = r[12]
              , l = r[1]
              , p = r[5]
              , h = r[9]
              , u = r[13]
              , d = r[2]
              , f = r[6]
              , m = r[10]
              , g = r[14]
              , v = r[3]
              , y = r[7]
              , b = r[11]
              , w = r[15]
              , x = i[0]
              , M = i[4]
              , _ = i[8]
              , S = i[12]
              , T = i[1]
              , E = i[5]
              , A = i[9]
              , P = i[13]
              , O = i[2]
              , R = i[6]
              , C = i[10]
              , L = i[14]
              , I = i[3]
              , k = i[7]
              , D = i[11]
              , z = i[15];
            return n[0] = s * x + a * T + o * O + c * I,
            n[4] = s * M + a * E + o * R + c * k,
            n[8] = s * _ + a * A + o * C + c * D,
            n[12] = s * S + a * P + o * L + c * z,
            n[1] = l * x + p * T + h * O + u * I,
            n[5] = l * M + p * E + h * R + u * k,
            n[9] = l * _ + p * A + h * C + u * D,
            n[13] = l * S + p * P + h * L + u * z,
            n[2] = d * x + f * T + m * O + g * I,
            n[6] = d * M + f * E + m * R + g * k,
            n[10] = d * _ + f * A + m * C + g * D,
            n[14] = d * S + f * P + m * L + g * z,
            n[3] = v * x + y * T + b * O + w * I,
            n[7] = v * M + y * E + b * R + w * k,
            n[11] = v * _ + y * A + b * C + w * D,
            n[15] = v * S + y * P + b * L + w * z,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        },
        applyToBufferAttribute: function() {
            var e = new Wt;
            return function(t) {
                for (var r = 0, i = t.count; r < i; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.applyMatrix4(this),
                    t.setXYZ(r, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , r = e[4]
              , i = e[8]
              , n = e[12]
              , s = e[1]
              , a = e[5]
              , o = e[9]
              , c = e[13]
              , l = e[2]
              , p = e[6]
              , h = e[10]
              , u = e[14];
            return e[3] * (+n * o * p - i * c * p - n * a * h + r * c * h + i * a * u - r * o * u) + e[7] * (+t * o * u - t * c * h + n * s * h - i * s * u + i * c * l - n * o * l) + e[11] * (+t * c * p - t * a * u - n * s * p + r * s * u + n * a * l - r * c * l) + e[15] * (-i * a * l - t * o * p + t * a * h + i * s * p - r * s * h + r * o * l)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(e, t, r) {
            var i = this.elements;
            return e.isVector3 ? (i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z) : (i[12] = e,
            i[13] = t,
            i[14] = r),
            this
        },
        getInverse: function(e, t) {
            var r = this.elements
              , i = e.elements
              , n = i[0]
              , s = i[1]
              , a = i[2]
              , o = i[3]
              , c = i[4]
              , l = i[5]
              , p = i[6]
              , h = i[7]
              , u = i[8]
              , d = i[9]
              , f = i[10]
              , m = i[11]
              , g = i[12]
              , v = i[13]
              , y = i[14]
              , b = i[15]
              , w = d * y * h - v * f * h + v * p * m - l * y * m - d * p * b + l * f * b
              , x = g * f * h - u * y * h - g * p * m + c * y * m + u * p * b - c * f * b
              , M = u * v * h - g * d * h + g * l * m - c * v * m - u * l * b + c * d * b
              , _ = g * d * p - u * v * p - g * l * f + c * v * f + u * l * y - c * d * y
              , S = n * w + s * x + a * M + o * _;
            if (0 === S) {
                var T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t)
                    throw new Error(T);
                return console.warn(T),
                this.identity()
            }
            var E = 1 / S;
            return r[0] = w * E,
            r[1] = (v * f * o - d * y * o - v * a * m + s * y * m + d * a * b - s * f * b) * E,
            r[2] = (l * y * o - v * p * o + v * a * h - s * y * h - l * a * b + s * p * b) * E,
            r[3] = (d * p * o - l * f * o - d * a * h + s * f * h + l * a * m - s * p * m) * E,
            r[4] = x * E,
            r[5] = (u * y * o - g * f * o + g * a * m - n * y * m - u * a * b + n * f * b) * E,
            r[6] = (g * p * o - c * y * o - g * a * h + n * y * h + c * a * b - n * p * b) * E,
            r[7] = (c * f * o - u * p * o + u * a * h - n * f * h - c * a * m + n * p * m) * E,
            r[8] = M * E,
            r[9] = (g * d * o - u * v * o - g * s * m + n * v * m + u * s * b - n * d * b) * E,
            r[10] = (c * v * o - g * l * o + g * s * h - n * v * h - c * s * b + n * l * b) * E,
            r[11] = (u * l * o - c * d * o - u * s * h + n * d * h + c * s * m - n * l * m) * E,
            r[12] = _ * E,
            r[13] = (u * v * a - g * d * a + g * s * f - n * v * f - u * s * y + n * d * y) * E,
            r[14] = (g * l * a - c * v * a - g * s * p + n * v * p + c * s * y - n * l * y) * E,
            r[15] = (c * d * a - u * l * a + u * s * p - n * d * p - c * s * f + n * l * f) * E,
            this
        },
        scale: function(e) {
            var t = this.elements
              , r = e.x
              , i = e.y
              , n = e.z;
            return t[0] *= r,
            t[4] *= i,
            t[8] *= n,
            t[1] *= r,
            t[5] *= i,
            t[9] *= n,
            t[2] *= r,
            t[6] *= i,
            t[10] *= n,
            t[3] *= r,
            t[7] *= i,
            t[11] *= n,
            this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, r, i))
        },
        makeTranslation: function(e, t, r) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(e, t) {
            var r = Math.cos(t)
              , i = Math.sin(t)
              , n = 1 - r
              , s = e.x
              , a = e.y
              , o = e.z
              , c = n * s
              , l = n * a;
            return this.set(c * s + r, c * a - i * o, c * o + i * a, 0, c * a + i * o, l * a + r, l * o - i * s, 0, c * o - i * a, l * o + i * s, n * o * o + r, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(e, t, r) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(e, t, r) {
            return this.set(1, t, r, 0, e, 1, r, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(e, t, r) {
            var i = this.elements
              , n = t._x
              , s = t._y
              , a = t._z
              , o = t._w
              , c = n + n
              , l = s + s
              , p = a + a
              , h = n * c
              , u = n * l
              , d = n * p
              , f = s * l
              , m = s * p
              , g = a * p
              , v = o * c
              , y = o * l
              , b = o * p
              , w = r.x
              , x = r.y
              , M = r.z;
            return i[0] = (1 - (f + g)) * w,
            i[1] = (u + b) * w,
            i[2] = (d - y) * w,
            i[3] = 0,
            i[4] = (u - b) * x,
            i[5] = (1 - (h + g)) * x,
            i[6] = (m + v) * x,
            i[7] = 0,
            i[8] = (d + y) * M,
            i[9] = (m - v) * M,
            i[10] = (1 - (h + f)) * M,
            i[11] = 0,
            i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z,
            i[15] = 1,
            this
        },
        decompose: (er = new Wt,
        tr = new br,
        function(e, t, r) {
            var i = this.elements
              , n = er.set(i[0], i[1], i[2]).length()
              , s = er.set(i[4], i[5], i[6]).length()
              , a = er.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (n = -n),
            e.x = i[12],
            e.y = i[13],
            e.z = i[14],
            tr.copy(this);
            var o = 1 / n
              , c = 1 / s
              , l = 1 / a;
            return tr.elements[0] *= o,
            tr.elements[1] *= o,
            tr.elements[2] *= o,
            tr.elements[4] *= c,
            tr.elements[5] *= c,
            tr.elements[6] *= c,
            tr.elements[8] *= l,
            tr.elements[9] *= l,
            tr.elements[10] *= l,
            t.setFromRotationMatrix(tr),
            r.x = n,
            r.y = s,
            r.z = a,
            this
        }
        ),
        makePerspective: function(e, t, r, i, n, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements
              , o = 2 * n / (t - e)
              , c = 2 * n / (r - i)
              , l = (t + e) / (t - e)
              , p = (r + i) / (r - i)
              , h = -(s + n) / (s - n)
              , u = -2 * s * n / (s - n);
            return a[0] = o,
            a[4] = 0,
            a[8] = l,
            a[12] = 0,
            a[1] = 0,
            a[5] = c,
            a[9] = p,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = h,
            a[14] = u,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(e, t, r, i, n, s) {
            var a = this.elements
              , o = 1 / (t - e)
              , c = 1 / (r - i)
              , l = 1 / (s - n)
              , p = (t + e) * o
              , h = (r + i) * c
              , u = (s + n) * l;
            return a[0] = 2 * o,
            a[4] = 0,
            a[8] = 0,
            a[12] = -p,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -h,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * l,
            a[14] = -u,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(e) {
            for (var t = this.elements, r = e.elements, i = 0; i < 16; i++)
                if (t[i] !== r[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 16; r++)
                this.elements[r] = e[r + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e[t + 9] = r[9],
            e[t + 10] = r[10],
            e[t + 11] = r[11],
            e[t + 12] = r[12],
            e[t + 13] = r[13],
            e[t + 14] = r[14],
            e[t + 15] = r[15],
            e
        }
    });
    var wr = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    };
    function xr(e) {
        var t = {};
        for (var r in e)
            for (var i in t[r] = {},
            e[r]) {
                var n = e[r][i];
                n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture) ? t[r][i] = n.clone() : Array.isArray(n) ? t[r][i] = n.slice() : t[r][i] = n
            }
        return t
    }
    function Mr(e) {
        for (var t = {}, r = 0; r < e.length; r++) {
            var i = xr(e[r]);
            for (var n in i)
                t[n] = i[n]
        }
        return t
    }
    var _r, Sr, Tr, Er = {
        clone: xr,
        merge: Mr
    }, Ar = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function Pr(e, t, r) {
        return void 0 === t && void 0 === r ? this.set(e) : this.setRGB(e, t, r)
    }
    Object.assign(Pr.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        },
        setScalar: function(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        },
        setHex: function(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        },
        setRGB: function(e, t, r) {
            return this.r = e,
            this.g = t,
            this.b = r,
            this
        },
        setHSL: function() {
            function e(e, t, r) {
                return r < 0 && (r += 1),
                r > 1 && (r -= 1),
                r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - r) : e
            }
            return function(t, r, i) {
                if (t = Gt.euclideanModulo(t, 1),
                r = Gt.clamp(r, 0, 1),
                i = Gt.clamp(i, 0, 1),
                0 === r)
                    this.r = this.g = this.b = i;
                else {
                    var n = i <= .5 ? i * (1 + r) : i + r - i * r
                      , s = 2 * i - n;
                    this.r = e(s, n, t + 1 / 3),
                    this.g = e(s, n, t),
                    this.b = e(s, n, t - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var r;
            if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var i, n = r[1], s = r[2];
                switch (n) {
                case "rgb":
                case "rgba":
                    if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s))
                        return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                        t(i[5]),
                        this;
                    if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s))
                        return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                        t(i[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) {
                        var a = parseFloat(i[1]) / 360
                          , o = parseInt(i[2], 10) / 100
                          , c = parseInt(i[3], 10) / 100;
                        return t(i[5]),
                        this.setHSL(a, o, c)
                    }
                }
            } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var l, p = (l = r[1]).length;
                if (3 === p)
                    return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255,
                    this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255,
                    this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255,
                    this;
                if (6 === p)
                    return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255,
                    this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255,
                    this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255,
                    this
            }
            e && e.length > 0 && (void 0 !== (l = Ar[e]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e));
            return this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2),
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var r = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, r),
            this.g = Math.pow(e.g, r),
            this.b = Math.pow(e.b, r),
            this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e),
            this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e),
            this
        },
        copySRGBToLinear: function() {
            function e(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        copyLinearToSRGB: function() {
            function e(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
            e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, r, i = this.r, n = this.g, s = this.b, a = Math.max(i, n, s), o = Math.min(i, n, s), c = (o + a) / 2;
            if (o === a)
                t = 0,
                r = 0;
            else {
                var l = a - o;
                switch (r = c <= .5 ? l / (a + o) : l / (2 - a - o),
                a) {
                case i:
                    t = (n - s) / l + (n < s ? 6 : 0);
                    break;
                case n:
                    t = (s - i) / l + 2;
                    break;
                case s:
                    t = (i - n) / l + 4
                }
                t /= 6
            }
            return e.h = t,
            e.s = r,
            e.l = c,
            e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: (Tr = {},
        function(e, t, r) {
            return this.getHSL(Tr),
            Tr.h += e,
            Tr.s += t,
            Tr.l += r,
            this.setHSL(Tr.h, Tr.s, Tr.l),
            this
        }
        ),
        add: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        },
        addScalar: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        },
        multiply: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        },
        multiplyScalar: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        },
        lerpHSL: (_r = {
            h: 0,
            s: 0,
            l: 0
        },
        Sr = {
            h: 0,
            s: 0,
            l: 0
        },
        function(e, t) {
            this.getHSL(_r),
            e.getHSL(Sr);
            var r = Gt.lerp(_r.h, Sr.h, t)
              , i = Gt.lerp(_r.s, Sr.s, t)
              , n = Gt.lerp(_r.l, Sr.l, t);
            return this.setHSL(r, i, n),
            this
        }
        ),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Or, Rr = {
        common: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Yt
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Ht(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Pr(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Yt
            }
        },
        sprite: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ht(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Yt
            }
        }
    }, Cr = {
        basic: {
            uniforms: Mr([Rr.common, Rr.specularmap, Rr.envmap, Rr.aomap, Rr.lightmap, Rr.fog]),
            vertexShader: wr.meshbasic_vert,
            fragmentShader: wr.meshbasic_frag
        },
        lambert: {
            uniforms: Mr([Rr.common, Rr.specularmap, Rr.envmap, Rr.aomap, Rr.lightmap, Rr.emissivemap, Rr.fog, Rr.lights, {
                emissive: {
                    value: new Pr(0)
                }
            }]),
            vertexShader: wr.meshlambert_vert,
            fragmentShader: wr.meshlambert_frag
        },
        phong: {
            uniforms: Mr([Rr.common, Rr.specularmap, Rr.envmap, Rr.aomap, Rr.lightmap, Rr.emissivemap, Rr.bumpmap, Rr.normalmap, Rr.displacementmap, Rr.gradientmap, Rr.fog, Rr.lights, {
                emissive: {
                    value: new Pr(0)
                },
                specular: {
                    value: new Pr(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: wr.meshphong_vert,
            fragmentShader: wr.meshphong_frag
        },
        standard: {
            uniforms: Mr([Rr.common, Rr.envmap, Rr.aomap, Rr.lightmap, Rr.emissivemap, Rr.bumpmap, Rr.normalmap, Rr.displacementmap, Rr.roughnessmap, Rr.metalnessmap, Rr.fog, Rr.lights, {
                emissive: {
                    value: new Pr(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: wr.meshphysical_vert,
            fragmentShader: wr.meshphysical_frag
        },
        matcap: {
            uniforms: Mr([Rr.common, Rr.bumpmap, Rr.normalmap, Rr.displacementmap, Rr.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: wr.meshmatcap_vert,
            fragmentShader: wr.meshmatcap_frag
        },
        points: {
            uniforms: Mr([Rr.points, Rr.fog]),
            vertexShader: wr.points_vert,
            fragmentShader: wr.points_frag
        },
        dashed: {
            uniforms: Mr([Rr.common, Rr.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: wr.linedashed_vert,
            fragmentShader: wr.linedashed_frag
        },
        depth: {
            uniforms: Mr([Rr.common, Rr.displacementmap]),
            vertexShader: wr.depth_vert,
            fragmentShader: wr.depth_frag
        },
        normal: {
            uniforms: Mr([Rr.common, Rr.bumpmap, Rr.normalmap, Rr.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: wr.normal_vert,
            fragmentShader: wr.normal_frag
        },
        sprite: {
            uniforms: Mr([Rr.sprite, Rr.fog]),
            vertexShader: wr.sprite_vert,
            fragmentShader: wr.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Yt
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: wr.background_vert,
            fragmentShader: wr.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: wr.cube_vert,
            fragmentShader: wr.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: wr.equirect_vert,
            fragmentShader: wr.equirect_frag
        },
        distanceRGBA: {
            uniforms: Mr([Rr.common, Rr.displacementmap, {
                referencePosition: {
                    value: new Wt
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: wr.distanceRGBA_vert,
            fragmentShader: wr.distanceRGBA_frag
        },
        shadow: {
            uniforms: Mr([Rr.lights, Rr.fog, {
                color: {
                    value: new Pr(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: wr.shadow_vert,
            fragmentShader: wr.shadow_frag
        }
    };
    function Lr() {
        var e = null
          , t = !1
          , r = null;
        function i(n, s) {
            !1 !== t && (r(n, s),
            e.requestAnimationFrame(i))
        }
        return {
            start: function() {
                !0 !== t && null !== r && (e.requestAnimationFrame(i),
                t = !0)
            },
            stop: function() {
                t = !1
            },
            setAnimationLoop: function(e) {
                r = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function Ir(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                t.get(e)
            },
            remove: function(r) {
                r.isInterleavedBufferAttribute && (r = r.data);
                var i = t.get(r);
                i && (e.deleteBuffer(i.buffer),
                t.delete(r))
            },
            update: function(r, i) {
                r.isInterleavedBufferAttribute && (r = r.data);
                var n = t.get(r);
                void 0 === n ? t.set(r, function(t, r) {
                    var i = t.array
                      , n = t.dynamic ? 35048 : 35044
                      , s = e.createBuffer();
                    e.bindBuffer(r, s),
                    e.bufferData(r, i, n),
                    t.onUploadCallback();
                    var a = 5126;
                    return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121),
                    {
                        buffer: s,
                        type: a,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(r, i)) : n.version < r.version && (function(t, r, i) {
                    var n = r.array
                      , s = r.updateRange;
                    e.bindBuffer(i, t),
                    !1 === r.dynamic ? e.bufferData(i, n, 35044) : -1 === s.count ? e.bufferSubData(i, 0, n) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(i, s.offset * n.BYTES_PER_ELEMENT, n.subarray(s.offset, s.offset + s.count)),
                    s.count = -1)
                }(n.buffer, r, i),
                n.version = r.version)
            }
        }
    }
    function kr(e, t, r, i, n, s) {
        this.a = e,
        this.b = t,
        this.c = r,
        this.normal = i && i.isVector3 ? i : new Wt,
        this.vertexNormals = Array.isArray(i) ? i : [],
        this.color = n && n.isColor ? n : new Pr,
        this.vertexColors = Array.isArray(n) ? n : [],
        this.materialIndex = void 0 !== s ? s : 0
    }
    function Dr(e, t, r, i) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = r || 0,
        this._order = i || Dr.DefaultOrder
    }
    function zr() {
        this.mask = 1
    }
    Cr.physical = {
        uniforms: Mr([Cr.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: wr.meshphysical_vert,
        fragmentShader: wr.meshphysical_frag
    },
    Object.assign(kr.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            this.materialIndex = e.materialIndex;
            for (var t = 0, r = e.vertexNormals.length; t < r; t++)
                this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0,
            r = e.vertexColors.length; t < r; t++)
                this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }),
    Dr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    Dr.DefaultOrder = "XYZ",
    Object.defineProperties(Dr.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(Dr.prototype, {
        isEuler: !0,
        set: function(e, t, r, i) {
            return this._x = e,
            this._y = t,
            this._z = r,
            this._order = i || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e, t, r) {
            var i = Gt.clamp
              , n = e.elements
              , s = n[0]
              , a = n[4]
              , o = n[8]
              , c = n[1]
              , l = n[5]
              , p = n[9]
              , h = n[2]
              , u = n[6]
              , d = n[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(i(o, -1, 1)),
            Math.abs(o) < .99999 ? (this._x = Math.atan2(-p, d),
            this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(u, l),
            this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(p, -1, 1)),
            Math.abs(p) < .99999 ? (this._y = Math.atan2(o, d),
            this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, s),
            this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(u, -1, 1)),
            Math.abs(u) < .99999 ? (this._y = Math.atan2(-h, d),
            this._z = Math.atan2(-a, l)) : (this._y = 0,
            this._z = Math.atan2(c, s))) : "ZYX" === t ? (this._y = Math.asin(-i(h, -1, 1)),
            Math.abs(h) < .99999 ? (this._x = Math.atan2(u, d),
            this._z = Math.atan2(c, s)) : (this._x = 0,
            this._z = Math.atan2(-a, l))) : "YZX" === t ? (this._z = Math.asin(i(c, -1, 1)),
            Math.abs(c) < .99999 ? (this._x = Math.atan2(-p, l),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(o, d))) : "XZY" === t ? (this._z = Math.asin(-i(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(u, l),
            this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-p, d),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t),
            this._order = t,
            !1 !== r && this.onChangeCallback(),
            this
        },
        setFromQuaternion: function() {
            var e = new br;
            return function(t, r, i) {
                return e.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(e, r, i)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: (Or = new Vt,
        function(e) {
            return Or.setFromEuler(this),
            this.setFromQuaternion(Or, e)
        }
        ),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new Wt(this._x,this._y,this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(zr.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var Br, Nr, jr, Fr, Ur, Gr = 0;
    function Hr() {
        Object.defineProperty(this, "id", {
            value: Gr++
        }),
        this.uuid = Gt.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Hr.DefaultUp.clone();
        var e = new Wt
          , t = new Dr
          , r = new Vt
          , i = new Wt(1,1,1);
        t.onChange(function() {
            r.setFromEuler(t, !1)
        }),
        r.onChange(function() {
            t.setFromQuaternion(r, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new br
            },
            normalMatrix: {
                value: new Yt
            }
        }),
        this.matrix = new br,
        this.matrixWorld = new br,
        this.matrixAutoUpdate = Hr.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new zr,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    Hr.DefaultUp = new Wt(0,1,0),
    Hr.DefaultMatrixAutoUpdate = !0,
    Hr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Hr,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: (Ur = new Vt,
        function(e, t) {
            return Ur.setFromAxisAngle(e, t),
            this.quaternion.multiply(Ur),
            this
        }
        ),
        rotateOnWorldAxis: function() {
            var e = new Vt;
            return function(t, r) {
                return e.setFromAxisAngle(t, r),
                this.quaternion.premultiply(e),
                this
            }
        }(),
        rotateX: function() {
            var e = new Wt(1,0,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new Wt(0,1,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new Wt(0,0,1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new Wt;
            return function(t, r) {
                return e.copy(t).applyQuaternion(this.quaternion),
                this.position.add(e.multiplyScalar(r)),
                this
            }
        }(),
        translateX: function() {
            var e = new Wt(1,0,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new Wt(0,1,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new Wt(0,0,1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: (Fr = new br,
        function(e) {
            return e.applyMatrix4(Fr.getInverse(this.matrixWorld))
        }
        ),
        lookAt: function() {
            var e = new Vt
              , t = new br
              , r = new Wt
              , i = new Wt;
            return function(n, s, a) {
                n.isVector3 ? r.copy(n) : r.set(n, s, a);
                var o = this.parent;
                this.updateWorldMatrix(!0, !1),
                i.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? t.lookAt(i, r, this.up) : t.lookAt(r, i, this.up),
                this.quaternion.setFromRotationMatrix(t),
                o && (t.extractRotation(o.matrixWorld),
                e.setFromRotationMatrix(t),
                this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            e.dispatchEvent({
                type: "added"
            }),
            this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            var r = this.children.indexOf(e);
            return -1 !== r && (e.parent = null,
            e.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(r, 1)),
            this
        },
        attach: (jr = new br,
        function(e) {
            return this.updateWorldMatrix(!0, !1),
            jr.getInverse(this.matrixWorld),
            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
            jr.multiply(e.parent.matrixWorld)),
            e.applyMatrix(jr),
            e.updateWorldMatrix(!1, !1),
            this.add(e),
            this
        }
        ),
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (var r = 0, i = this.children.length; r < i; r++) {
                var n = this.children[r].getObjectByProperty(e, t);
                if (void 0 !== n)
                    return n
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            e = new Wt),
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: (Br = new Wt,
        Nr = new Wt,
        function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            e = new Vt),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(Br, e, Nr),
            e
        }
        ),
        getWorldScale: function() {
            var e = new Wt
              , t = new Vt;
            return function(r) {
                return void 0 === r && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                r = new Wt),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(e, t, r),
                r
            }
        }(),
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            e = new Wt),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, r = 0, i = t.length; r < i; r++)
                t[r].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, r = 0, i = t.length; r < i; r++)
                    t[r].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            for (var t = this.children, r = 0, i = t.length; r < i; r++)
                t[r].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var r = this.parent;
            if (!0 === e && null !== r && r.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (var i = this.children, n = 0, s = i.length; n < s; n++)
                    i[n].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e
              , r = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var i = {};
            function n(t, r) {
                return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)),
                r.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isMesh && this.drawMode !== At && (i.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints) {
                i.geometry = n(e.geometries, this.geometry);
                var s = this.geometry.parameters;
                if (void 0 !== s && void 0 !== s.shapes) {
                    var a = s.shapes;
                    if (Array.isArray(a))
                        for (var o = 0, c = a.length; o < c; o++) {
                            var l = a[o];
                            n(e.shapes, l)
                        }
                    else
                        n(e.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var p = [];
                    for (o = 0,
                    c = this.material.length; o < c; o++)
                        p.push(n(e.materials, this.material[o]));
                    i.material = p
                } else
                    i.material = n(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (o = 0; o < this.children.length; o++)
                    i.children.push(this.children[o].toJSON(e).object)
            }
            if (t) {
                var h = m(e.geometries)
                  , u = m(e.materials)
                  , d = m(e.textures)
                  , f = m(e.images);
                a = m(e.shapes);
                h.length > 0 && (r.geometries = h),
                u.length > 0 && (r.materials = u),
                d.length > 0 && (r.textures = d),
                f.length > 0 && (r.images = f),
                a.length > 0 && (r.shapes = a)
            }
            return r.object = i,
            r;
            function m(e) {
                var t = [];
                for (var r in e) {
                    var i = e[r];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0),
            this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (var r = 0; r < e.children.length; r++) {
                    var i = e.children[r];
                    this.add(i.clone())
                }
            return this
        }
    });
    var Vr, Wr, Yr = 0;
    function Zr() {
        Object.defineProperty(this, "id", {
            value: Yr += 2
        }),
        this.uuid = Gt.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function Xr(e, t, r) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === r,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function qr(e, t, r) {
        Xr.call(this, new Int8Array(e), t, r)
    }
    function Jr(e, t, r) {
        Xr.call(this, new Uint8Array(e), t, r)
    }
    function Kr(e, t, r) {
        Xr.call(this, new Uint8ClampedArray(e), t, r)
    }
    function Qr(e, t, r) {
        Xr.call(this, new Int16Array(e), t, r)
    }
    function $r(e, t, r) {
        Xr.call(this, new Uint16Array(e), t, r)
    }
    function ei(e, t, r) {
        Xr.call(this, new Int32Array(e), t, r)
    }
    function ti(e, t, r) {
        Xr.call(this, new Uint32Array(e), t, r)
    }
    function ri(e, t, r) {
        Xr.call(this, new Float32Array(e), t, r)
    }
    function ii(e, t, r) {
        Xr.call(this, new Float64Array(e), t, r)
    }
    function ni() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function si(e) {
        if (0 === e.length)
            return -1 / 0;
        for (var t = e[0], r = 1, i = e.length; r < i; ++r)
            e[r] > t && (t = e[r]);
        return t
    }
    Zr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Zr,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new Yt).getNormalMatrix(e), r = 0, i = this.vertices.length; r < i; r++) {
                this.vertices[r].applyMatrix4(e)
            }
            for (r = 0,
            i = this.faces.length; r < i; r++) {
                var n = this.faces[r];
                n.normal.applyMatrix3(t).normalize();
                for (var s = 0, a = n.vertexNormals.length; s < a; s++)
                    n.vertexNormals[s].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new br;
            return function(t, r, i) {
                return e.makeTranslation(t, r, i),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new br;
            return function(t, r, i) {
                return e.makeScale(t, r, i),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: (Wr = new Hr,
        function(e) {
            Wr.lookAt(e),
            Wr.updateMatrix(),
            this.applyMatrix(Wr.matrix)
        }
        ),
        fromBufferGeometry: function(e) {
            var t = this
              , r = null !== e.index ? e.index.array : void 0
              , i = e.attributes
              , n = i.position.array
              , s = void 0 !== i.normal ? i.normal.array : void 0
              , a = void 0 !== i.color ? i.color.array : void 0
              , o = void 0 !== i.uv ? i.uv.array : void 0
              , c = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var l = 0; l < n.length; l += 3)
                t.vertices.push((new Wt).fromArray(n, l)),
                void 0 !== a && t.colors.push((new Pr).fromArray(a, l));
            function p(e, r, i, n) {
                var l = void 0 === a ? [] : [t.colors[e].clone(), t.colors[r].clone(), t.colors[i].clone()]
                  , p = new kr(e,r,i,void 0 === s ? [] : [(new Wt).fromArray(s, 3 * e), (new Wt).fromArray(s, 3 * r), (new Wt).fromArray(s, 3 * i)],l,n);
                t.faces.push(p),
                void 0 !== o && t.faceVertexUvs[0].push([(new Ht).fromArray(o, 2 * e), (new Ht).fromArray(o, 2 * r), (new Ht).fromArray(o, 2 * i)]),
                void 0 !== c && t.faceVertexUvs[1].push([(new Ht).fromArray(c, 2 * e), (new Ht).fromArray(c, 2 * r), (new Ht).fromArray(c, 2 * i)])
            }
            var h = e.groups;
            if (h.length > 0)
                for (l = 0; l < h.length; l++)
                    for (var u = h[l], d = u.start, f = d, m = d + u.count; f < m; f += 3)
                        void 0 !== r ? p(r[f], r[f + 1], r[f + 2], u.materialIndex) : p(f, f + 1, f + 2, u.materialIndex);
            else if (void 0 !== r)
                for (l = 0; l < r.length; l += 3)
                    p(r[l], r[l + 1], r[l + 2]);
            else
                for (l = 0; l < n.length / 3; l += 3)
                    p(l, l + 1, l + 2);
            return this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
        },
        center: (Vr = new Wt,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Vr).negate(),
            this.translate(Vr.x, Vr.y, Vr.z),
            this
        }
        ),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center
              , t = this.boundingSphere.radius
              , r = 0 === t ? 1 : 1 / t
              , i = new br;
            return i.set(r, 0, 0, -r * e.x, 0, r, 0, -r * e.y, 0, 0, r, -r * e.z, 0, 0, 0, 1),
            this.applyMatrix(i),
            this
        },
        computeFaceNormals: function() {
            for (var e = new Wt, t = new Wt, r = 0, i = this.faces.length; r < i; r++) {
                var n = this.faces[r]
                  , s = this.vertices[n.a]
                  , a = this.vertices[n.b]
                  , o = this.vertices[n.c];
                e.subVectors(o, a),
                t.subVectors(s, a),
                e.cross(t),
                e.normalize(),
                n.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, r, i, n, s, a;
            for (void 0 === e && (e = !0),
            a = new Array(this.vertices.length),
            t = 0,
            r = this.vertices.length; t < r; t++)
                a[t] = new Wt;
            if (e) {
                var o, c, l, p = new Wt, h = new Wt;
                for (i = 0,
                n = this.faces.length; i < n; i++)
                    s = this.faces[i],
                    o = this.vertices[s.a],
                    c = this.vertices[s.b],
                    l = this.vertices[s.c],
                    p.subVectors(l, c),
                    h.subVectors(o, c),
                    p.cross(h),
                    a[s.a].add(p),
                    a[s.b].add(p),
                    a[s.c].add(p)
            } else
                for (this.computeFaceNormals(),
                i = 0,
                n = this.faces.length; i < n; i++)
                    a[(s = this.faces[i]).a].add(s.normal),
                    a[s.b].add(s.normal),
                    a[s.c].add(s.normal);
            for (t = 0,
            r = this.vertices.length; t < r; t++)
                a[t].normalize();
            for (i = 0,
            n = this.faces.length; i < n; i++) {
                var u = (s = this.faces[i]).vertexNormals;
                3 === u.length ? (u[0].copy(a[s.a]),
                u[1].copy(a[s.b]),
                u[2].copy(a[s.c])) : (u[0] = a[s.a].clone(),
                u[1] = a[s.b].clone(),
                u[2] = a[s.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, r;
            for (this.computeFaceNormals(),
            e = 0,
            t = this.faces.length; e < t; e++) {
                var i = (r = this.faces[e]).vertexNormals;
                3 === i.length ? (i[0].copy(r.normal),
                i[1].copy(r.normal),
                i[2].copy(r.normal)) : (i[0] = r.normal.clone(),
                i[1] = r.normal.clone(),
                i[2] = r.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, r, i, n;
            for (r = 0,
            i = this.faces.length; r < i; r++)
                for ((n = this.faces[r]).__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(),
                n.__originalVertexNormals || (n.__originalVertexNormals = []),
                e = 0,
                t = n.vertexNormals.length; e < t; e++)
                    n.__originalVertexNormals[e] ? n.__originalVertexNormals[e].copy(n.vertexNormals[e]) : n.__originalVertexNormals[e] = n.vertexNormals[e].clone();
            var s = new Zr;
            for (s.faces = this.faces,
            e = 0,
            t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {},
                    this.morphNormals[e].faceNormals = [],
                    this.morphNormals[e].vertexNormals = [];
                    var a = this.morphNormals[e].faceNormals
                      , o = this.morphNormals[e].vertexNormals;
                    for (r = 0,
                    i = this.faces.length; r < i; r++)
                        c = new Wt,
                        l = {
                            a: new Wt,
                            b: new Wt,
                            c: new Wt
                        },
                        a.push(c),
                        o.push(l)
                }
                var c, l, p = this.morphNormals[e];
                for (s.vertices = this.morphTargets[e].vertices,
                s.computeFaceNormals(),
                s.computeVertexNormals(),
                r = 0,
                i = this.faces.length; r < i; r++)
                    n = this.faces[r],
                    c = p.faceNormals[r],
                    l = p.vertexNormals[r],
                    c.copy(n.normal),
                    l.a.copy(n.vertexNormals[0]),
                    l.b.copy(n.vertexNormals[1]),
                    l.c.copy(n.vertexNormals[2])
            }
            for (r = 0,
            i = this.faces.length; r < i; r++)
                (n = this.faces[r]).normal = n.__originalFaceNormal,
                n.vertexNormals = n.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new mr),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new gr),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, r) {
            if (e && e.isGeometry) {
                var i, n = this.vertices.length, s = this.vertices, a = e.vertices, o = this.faces, c = e.faces, l = this.faceVertexUvs[0], p = e.faceVertexUvs[0], h = this.colors, u = e.colors;
                void 0 === r && (r = 0),
                void 0 !== t && (i = (new Yt).getNormalMatrix(t));
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = a[d].clone();
                    void 0 !== t && m.applyMatrix4(t),
                    s.push(m)
                }
                for (d = 0,
                f = u.length; d < f; d++)
                    h.push(u[d].clone());
                for (d = 0,
                f = c.length; d < f; d++) {
                    var g, v, y, b = c[d], w = b.vertexNormals, x = b.vertexColors;
                    (g = new kr(b.a + n,b.b + n,b.c + n)).normal.copy(b.normal),
                    void 0 !== i && g.normal.applyMatrix3(i).normalize();
                    for (var M = 0, _ = w.length; M < _; M++)
                        v = w[M].clone(),
                        void 0 !== i && v.applyMatrix3(i).normalize(),
                        g.vertexNormals.push(v);
                    g.color.copy(b.color);
                    for (M = 0,
                    _ = x.length; M < _; M++)
                        y = x[M],
                        g.vertexColors.push(y.clone());
                    g.materialIndex = b.materialIndex + r,
                    o.push(g)
                }
                for (d = 0,
                f = p.length; d < f; d++) {
                    var S = p[d]
                      , T = [];
                    if (void 0 !== S) {
                        for (M = 0,
                        _ = S.length; M < _; M++)
                            T.push(S[M].clone());
                        l.push(T)
                    }
                }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(),
            this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t, r, i, n, s, a, o, c = {}, l = [], p = [], h = Math.pow(10, 4);
            for (r = 0,
            i = this.vertices.length; r < i; r++)
                e = this.vertices[r],
                void 0 === c[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (c[t] = r,
                l.push(this.vertices[r]),
                p[r] = l.length - 1) : p[r] = p[c[t]];
            var u = [];
            for (r = 0,
            i = this.faces.length; r < i; r++) {
                (n = this.faces[r]).a = p[n.a],
                n.b = p[n.b],
                n.c = p[n.c],
                s = [n.a, n.b, n.c];
                for (var d = 0; d < 3; d++)
                    if (s[d] === s[(d + 1) % 3]) {
                        u.push(r);
                        break
                    }
            }
            for (r = u.length - 1; r >= 0; r--) {
                var f = u[r];
                for (this.faces.splice(f, 1),
                a = 0,
                o = this.faceVertexUvs.length; a < o; a++)
                    this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - l.length;
            return this.vertices = l,
            m
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                this.vertices.push(new Wt(i.x,i.y,i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, r = 0; r < t; r++)
                e[r]._id = r;
            e.sort(function(e, t) {
                return e.materialIndex - t.materialIndex
            });
            var i, n, s = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            s && s.length === t && (i = []),
            a && a.length === t && (n = []);
            for (r = 0; r < t; r++) {
                var o = e[r]._id;
                i && i.push(s[o]),
                n && n.push(a[o])
            }
            i && (this.faceVertexUvs[0] = i),
            n && (this.faceVertexUvs[1] = n)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var r in t)
                    void 0 !== t[r] && (e[r] = t[r]);
                return e
            }
            for (var i = [], n = 0; n < this.vertices.length; n++) {
                var s = this.vertices[n];
                i.push(s.x, s.y, s.z)
            }
            var a = []
              , o = []
              , c = {}
              , l = []
              , p = {}
              , h = []
              , u = {};
            for (n = 0; n < this.faces.length; n++) {
                var d = this.faces[n]
                  , f = void 0 !== this.faceVertexUvs[0][n]
                  , m = d.normal.length() > 0
                  , g = d.vertexNormals.length > 0
                  , v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , b = 0;
                if (b = _(b, 0, 0),
                b = _(b, 1, !0),
                b = _(b, 2, !1),
                b = _(b, 3, f),
                b = _(b, 4, m),
                b = _(b, 5, g),
                b = _(b, 6, v),
                b = _(b, 7, y),
                a.push(b),
                a.push(d.a, d.b, d.c),
                a.push(d.materialIndex),
                f) {
                    var w = this.faceVertexUvs[0][n];
                    a.push(E(w[0]), E(w[1]), E(w[2]))
                }
                if (m && a.push(S(d.normal)),
                g) {
                    var x = d.vertexNormals;
                    a.push(S(x[0]), S(x[1]), S(x[2]))
                }
                if (v && a.push(T(d.color)),
                y) {
                    var M = d.vertexColors;
                    a.push(T(M[0]), T(M[1]), T(M[2]))
                }
            }
            function _(e, t, r) {
                return r ? e | 1 << t : e & ~(1 << t)
            }
            function S(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] ? c[t] : (c[t] = o.length / 3,
                o.push(e.x, e.y, e.z),
                c[t])
            }
            function T(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== p[t] ? p[t] : (p[t] = l.length,
                l.push(e.getHex()),
                p[t])
            }
            function E(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== u[t] ? u[t] : (u[t] = h.length / 2,
                h.push(e.x, e.y),
                u[t])
            }
            return e.data = {},
            e.data.vertices = i,
            e.data.normals = o,
            l.length > 0 && (e.data.colors = l),
            h.length > 0 && (e.data.uvs = [h]),
            e.data.faces = a,
            e
        },
        clone: function() {
            return (new Zr).copy(this)
        },
        copy: function(e) {
            var t, r, i, n, s, a;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var o = e.vertices;
            for (t = 0,
            r = o.length; t < r; t++)
                this.vertices.push(o[t].clone());
            var c = e.colors;
            for (t = 0,
            r = c.length; t < r; t++)
                this.colors.push(c[t].clone());
            var l = e.faces;
            for (t = 0,
            r = l.length; t < r; t++)
                this.faces.push(l[t].clone());
            for (t = 0,
            r = e.faceVertexUvs.length; t < r; t++) {
                var p = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []),
                i = 0,
                n = p.length; i < n; i++) {
                    var h = p[i]
                      , u = [];
                    for (s = 0,
                    a = h.length; s < a; s++) {
                        var d = h[s];
                        u.push(d.clone())
                    }
                    this.faceVertexUvs[t].push(u)
                }
            }
            var f = e.morphTargets;
            for (t = 0,
            r = f.length; t < r; t++) {
                var m = {};
                if (m.name = f[t].name,
                void 0 !== f[t].vertices)
                    for (m.vertices = [],
                    i = 0,
                    n = f[t].vertices.length; i < n; i++)
                        m.vertices.push(f[t].vertices[i].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [],
                    i = 0,
                    n = f[t].normals.length; i < n; i++)
                        m.normals.push(f[t].normals[i].clone());
                this.morphTargets.push(m)
            }
            var g = e.morphNormals;
            for (t = 0,
            r = g.length; t < r; t++) {
                var v = {};
                if (void 0 !== g[t].vertexNormals)
                    for (v.vertexNormals = [],
                    i = 0,
                    n = g[t].vertexNormals.length; i < n; i++) {
                        var y = g[t].vertexNormals[i]
                          , b = {};
                        b.a = y.a.clone(),
                        b.b = y.b.clone(),
                        b.c = y.c.clone(),
                        v.vertexNormals.push(b)
                    }
                if (void 0 !== g[t].faceNormals)
                    for (v.faceNormals = [],
                    i = 0,
                    n = g[t].faceNormals.length; i < n; i++)
                        v.faceNormals.push(g[t].faceNormals[i].clone());
                this.morphNormals.push(v)
            }
            var w = e.skinWeights;
            for (t = 0,
            r = w.length; t < r; t++)
                this.skinWeights.push(w[t].clone());
            var x = e.skinIndices;
            for (t = 0,
            r = x.length; t < r; t++)
                this.skinIndices.push(x[t].clone());
            var M = e.lineDistances;
            for (t = 0,
            r = M.length; t < r; t++)
                this.lineDistances.push(M[t]);
            var _ = e.boundingBox;
            null !== _ && (this.boundingBox = _.clone());
            var S = e.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()),
            this.elementsNeedUpdate = e.elementsNeedUpdate,
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(Xr.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Xr.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, r) {
            e *= this.itemSize,
            r *= t.itemSize;
            for (var i = 0, n = this.itemSize; i < n; i++)
                this.array[e + i] = t.array[r + i];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                s = new Pr),
                t[r++] = s.r,
                t[r++] = s.g,
                t[r++] = s.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                s = new Ht),
                t[r++] = s.x,
                t[r++] = s.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                s = new Wt),
                t[r++] = s.x,
                t[r++] = s.y,
                t[r++] = s.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                s = new pr),
                t[r++] = s.x,
                t[r++] = s.y,
                t[r++] = s.z,
                t[r++] = s.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this
        },
        setXYZ: function(e, t, r, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = i,
            this
        },
        setXYZW: function(e, t, r, i, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = i,
            this.array[e + 3] = n,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }),
    qr.prototype = Object.create(Xr.prototype),
    qr.prototype.constructor = qr,
    Jr.prototype = Object.create(Xr.prototype),
    Jr.prototype.constructor = Jr,
    Kr.prototype = Object.create(Xr.prototype),
    Kr.prototype.constructor = Kr,
    Qr.prototype = Object.create(Xr.prototype),
    Qr.prototype.constructor = Qr,
    $r.prototype = Object.create(Xr.prototype),
    $r.prototype.constructor = $r,
    ei.prototype = Object.create(Xr.prototype),
    ei.prototype.constructor = ei,
    ti.prototype = Object.create(Xr.prototype),
    ti.prototype.constructor = ti,
    ri.prototype = Object.create(Xr.prototype),
    ri.prototype.constructor = ri,
    ii.prototype = Object.create(Xr.prototype),
    ii.prototype.constructor = ii,
    Object.assign(ni.prototype, {
        computeGroups: function(e) {
            for (var t, r = [], i = void 0, n = e.faces, s = 0; s < n.length; s++) {
                var a = n[s];
                a.materialIndex !== i && (i = a.materialIndex,
                void 0 !== t && (t.count = 3 * s - t.start,
                r.push(t)),
                t = {
                    start: 3 * s,
                    materialIndex: i
                })
            }
            void 0 !== t && (t.count = 3 * s - t.start,
            r.push(t)),
            this.groups = r
        },
        fromGeometry: function(e) {
            var t, r = e.faces, i = e.vertices, n = e.faceVertexUvs, s = n[0] && n[0].length > 0, a = n[1] && n[1].length > 0, o = e.morphTargets, c = o.length;
            if (c > 0) {
                t = [];
                for (var l = 0; l < c; l++)
                    t[l] = {
                        name: o[l].name,
                        data: []
                    };
                this.morphTargets.position = t
            }
            var p, h = e.morphNormals, u = h.length;
            if (u > 0) {
                p = [];
                for (l = 0; l < u; l++)
                    p[l] = {
                        name: h[l].name,
                        data: []
                    };
                this.morphTargets.normal = p
            }
            var d = e.skinIndices
              , f = e.skinWeights
              , m = d.length === i.length
              , g = f.length === i.length;
            i.length > 0 && 0 === r.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (l = 0; l < r.length; l++) {
                var v = r[l];
                this.vertices.push(i[v.a], i[v.b], i[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length)
                    this.normals.push(y[0], y[1], y[2]);
                else {
                    var b = v.normal;
                    this.normals.push(b, b, b)
                }
                var w, x = v.vertexColors;
                if (3 === x.length)
                    this.colors.push(x[0], x[1], x[2]);
                else {
                    var M = v.color;
                    this.colors.push(M, M, M)
                }
                if (!0 === s)
                    void 0 !== (w = n[0][l]) ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l),
                    this.uvs.push(new Ht, new Ht, new Ht));
                if (!0 === a)
                    void 0 !== (w = n[1][l]) ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l),
                    this.uvs2.push(new Ht, new Ht, new Ht));
                for (var _ = 0; _ < c; _++) {
                    var S = o[_].vertices;
                    t[_].data.push(S[v.a], S[v.b], S[v.c])
                }
                for (_ = 0; _ < u; _++) {
                    var T = h[_].vertexNormals[l];
                    p[_].data.push(T.a, T.b, T.c)
                }
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(e),
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        }
    });
    var ai = 1;
    function oi() {
        Object.defineProperty(this, "id", {
            value: ai += 2
        }),
        this.uuid = Gt.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function ci(e, t, r, i, n, s) {
        Zr.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: i,
            heightSegments: n,
            depthSegments: s
        },
        this.fromBufferGeometry(new li(e,t,r,i,n,s)),
        this.mergeVertices()
    }
    function li(e, t, r, i, n, s) {
        oi.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: i,
            heightSegments: n,
            depthSegments: s
        };
        var a = this;
        e = e || 1,
        t = t || 1,
        r = r || 1,
        i = Math.floor(i) || 1,
        n = Math.floor(n) || 1,
        s = Math.floor(s) || 1;
        var o = []
          , c = []
          , l = []
          , p = []
          , h = 0
          , u = 0;
        function d(e, t, r, i, n, s, d, f, m, g, v) {
            var y, b, w = s / m, x = d / g, M = s / 2, _ = d / 2, S = f / 2, T = m + 1, E = g + 1, A = 0, P = 0, O = new Wt;
            for (b = 0; b < E; b++) {
                var R = b * x - _;
                for (y = 0; y < T; y++) {
                    var C = y * w - M;
                    O[e] = C * i,
                    O[t] = R * n,
                    O[r] = S,
                    c.push(O.x, O.y, O.z),
                    O[e] = 0,
                    O[t] = 0,
                    O[r] = f > 0 ? 1 : -1,
                    l.push(O.x, O.y, O.z),
                    p.push(y / m),
                    p.push(1 - b / g),
                    A += 1
                }
            }
            for (b = 0; b < g; b++)
                for (y = 0; y < m; y++) {
                    var L = h + y + T * b
                      , I = h + y + T * (b + 1)
                      , k = h + (y + 1) + T * (b + 1)
                      , D = h + (y + 1) + T * b;
                    o.push(L, I, D),
                    o.push(I, k, D),
                    P += 6
                }
            a.addGroup(u, P, v),
            u += P,
            h += A
        }
        d("z", "y", "x", -1, -1, r, t, e, s, n, 0),
        d("z", "y", "x", 1, -1, r, t, -e, s, n, 1),
        d("x", "z", "y", 1, 1, e, r, t, i, s, 2),
        d("x", "z", "y", 1, -1, e, r, -t, i, s, 3),
        d("x", "y", "z", 1, -1, e, t, r, i, n, 4),
        d("x", "y", "z", -1, -1, e, t, -r, i, n, 5),
        this.setIndex(o),
        this.addAttribute("position", new ri(c,3)),
        this.addAttribute("normal", new ri(l,3)),
        this.addAttribute("uv", new ri(p,2))
    }
    function pi(e, t, r, i) {
        Zr.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: i
        },
        this.fromBufferGeometry(new hi(e,t,r,i)),
        this.mergeVertices()
    }
    function hi(e, t, r, i) {
        oi.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: i
        };
        var n, s, a = (e = e || 1) / 2, o = (t = t || 1) / 2, c = Math.floor(r) || 1, l = Math.floor(i) || 1, p = c + 1, h = l + 1, u = e / c, d = t / l, f = [], m = [], g = [], v = [];
        for (s = 0; s < h; s++) {
            var y = s * d - o;
            for (n = 0; n < p; n++) {
                var b = n * u - a;
                m.push(b, -y, 0),
                g.push(0, 0, 1),
                v.push(n / c),
                v.push(1 - s / l)
            }
        }
        for (s = 0; s < l; s++)
            for (n = 0; n < c; n++) {
                var w = n + p * s
                  , x = n + p * (s + 1)
                  , M = n + 1 + p * (s + 1)
                  , _ = n + 1 + p * s;
                f.push(w, x, _),
                f.push(x, M, _)
            }
        this.setIndex(f),
        this.addAttribute("position", new ri(m,3)),
        this.addAttribute("normal", new ri(g,3)),
        this.addAttribute("uv", new ri(v,2))
    }
    oi.prototype = Object.assign(Object.create(i.prototype), {
        constructor: oi,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new (si(e) > 65535 ? ti : $r)(e,1) : this.index = e
        },
        addAttribute: function(e, t) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(t),
            this) : (this.attributes[e] = t,
            this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.addAttribute(e, new Xr(arguments[1],arguments[2])))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        addGroup: function(e, t, r) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== r ? r : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t),
            t.needsUpdate = !0);
            var r = this.attributes.normal;
            void 0 !== r && ((new Yt).getNormalMatrix(e).applyToBufferAttribute(r),
            r.needsUpdate = !0);
            var i = this.attributes.tangent;
            void 0 !== i && ((new Yt).getNormalMatrix(e).applyToBufferAttribute(i),
            i.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new br;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new br;
            return function(t, r, i) {
                return e.makeTranslation(t, r, i),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new br;
            return function(t, r, i) {
                return e.makeScale(t, r, i),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: function() {
            var e = new Hr;
            return function(t) {
                e.lookAt(t),
                e.updateMatrix(),
                this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            var e = new Wt;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(e).negate(),
                this.translate(e.x, e.y, e.z),
                this
            }
        }(),
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var r = new ri(3 * t.vertices.length,3)
                  , i = new ri(3 * t.colors.length,3);
                if (this.addAttribute("position", r.copyVector3sArray(t.vertices)),
                this.addAttribute("color", i.copyColorsArray(t.colors)),
                t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var n = new ri(t.lineDistances.length,1);
                    this.addAttribute("lineDistance", n.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else
                e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], r = 0, i = e.length; r < i; r++) {
                var n = e[r];
                t.push(n.x, n.y, n.z || 0)
            }
            return this.addAttribute("position", new ri(t,3)),
            this
        },
        updateFromObject: function(e) {
            var t, r = e.geometry;
            if (e.isMesh) {
                var i = r.__directGeometry;
                if (!0 === r.elementsNeedUpdate && (i = void 0,
                r.elementsNeedUpdate = !1),
                void 0 === i)
                    return this.fromGeometry(r);
                i.verticesNeedUpdate = r.verticesNeedUpdate,
                i.normalsNeedUpdate = r.normalsNeedUpdate,
                i.colorsNeedUpdate = r.colorsNeedUpdate,
                i.uvsNeedUpdate = r.uvsNeedUpdate,
                i.groupsNeedUpdate = r.groupsNeedUpdate,
                r.verticesNeedUpdate = !1,
                r.normalsNeedUpdate = !1,
                r.colorsNeedUpdate = !1,
                r.uvsNeedUpdate = !1,
                r.groupsNeedUpdate = !1,
                r = i
            }
            return !0 === r.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(r.vertices),
            t.needsUpdate = !0),
            r.verticesNeedUpdate = !1),
            !0 === r.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(r.normals),
            t.needsUpdate = !0),
            r.normalsNeedUpdate = !1),
            !0 === r.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(r.colors),
            t.needsUpdate = !0),
            r.colorsNeedUpdate = !1),
            r.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(r.uvs),
            t.needsUpdate = !0),
            r.uvsNeedUpdate = !1),
            r.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(r.lineDistances),
            t.needsUpdate = !0),
            r.lineDistancesNeedUpdate = !1),
            r.groupsNeedUpdate && (r.computeGroups(e.geometry),
            this.groups = r.groups,
            r.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new ni).fromGeometry(e),
            this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new Xr(t,3).copyVector3sArray(e.vertices)),
            e.normals.length > 0) {
                var r = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new Xr(r,3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var i = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new Xr(i,3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var n = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new Xr(n,2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var s = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new Xr(s,2).copyVector2sArray(e.uvs2))
            }
            for (var a in this.groups = e.groups,
            e.morphTargets) {
                for (var o = [], c = e.morphTargets[a], l = 0, p = c.length; l < p; l++) {
                    var h = c[l]
                      , u = new ri(3 * h.data.length,3);
                    u.name = h.name,
                    o.push(u.copyVector3sArray(h.data))
                }
                this.morphAttributes[a] = o
            }
            if (e.skinIndices.length > 0) {
                var d = new ri(4 * e.skinIndices.length,4);
                this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var f = new ri(4 * e.skinWeights.length,4);
                this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            var e = new mr;
            return function() {
                null === this.boundingBox && (this.boundingBox = new mr);
                var t = this.attributes.position
                  , r = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    r)
                        for (var i = 0, n = r.length; i < n; i++) {
                            var s = r[i];
                            e.setFromBufferAttribute(s),
                            this.boundingBox.expandByPoint(e.min),
                            this.boundingBox.expandByPoint(e.max)
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
        }(),
        computeBoundingSphere: function() {
            var e = new mr
              , t = new mr
              , r = new Wt;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new gr);
                var i = this.attributes.position
                  , n = this.morphAttributes.position;
                if (i) {
                    var s = this.boundingSphere.center;
                    if (e.setFromBufferAttribute(i),
                    n)
                        for (var a = 0, o = n.length; a < o; a++) {
                            var c = n[a];
                            t.setFromBufferAttribute(c),
                            e.expandByPoint(t.min),
                            e.expandByPoint(t.max)
                        }
                    e.getCenter(s);
                    var l = 0;
                    for (a = 0,
                    o = i.count; a < o; a++)
                        r.fromBufferAttribute(i, a),
                        l = Math.max(l, s.distanceToSquared(r));
                    if (n)
                        for (a = 0,
                        o = n.length; a < o; a++)
                            for (var p = 0, h = (c = n[a]).count; p < h; p++)
                                r.fromBufferAttribute(c, p),
                                l = Math.max(l, s.distanceToSquared(r));
                    this.boundingSphere.radius = Math.sqrt(l),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index
              , t = this.attributes;
            if (t.position) {
                var r = t.position.array;
                if (void 0 === t.normal)
                    this.addAttribute("normal", new Xr(new Float32Array(r.length),3));
                else
                    for (var i = t.normal.array, n = 0, s = i.length; n < s; n++)
                        i[n] = 0;
                var a, o, c, l = t.normal.array, p = new Wt, h = new Wt, u = new Wt, d = new Wt, f = new Wt;
                if (e) {
                    var m = e.array;
                    for (n = 0,
                    s = e.count; n < s; n += 3)
                        a = 3 * m[n + 0],
                        o = 3 * m[n + 1],
                        c = 3 * m[n + 2],
                        p.fromArray(r, a),
                        h.fromArray(r, o),
                        u.fromArray(r, c),
                        d.subVectors(u, h),
                        f.subVectors(p, h),
                        d.cross(f),
                        l[a] += d.x,
                        l[a + 1] += d.y,
                        l[a + 2] += d.z,
                        l[o] += d.x,
                        l[o + 1] += d.y,
                        l[o + 2] += d.z,
                        l[c] += d.x,
                        l[c + 1] += d.y,
                        l[c + 2] += d.z
                } else
                    for (n = 0,
                    s = r.length; n < s; n += 9)
                        p.fromArray(r, n),
                        h.fromArray(r, n + 3),
                        u.fromArray(r, n + 6),
                        d.subVectors(u, h),
                        f.subVectors(p, h),
                        d.cross(f),
                        l[n] = d.x,
                        l[n + 1] = d.y,
                        l[n + 2] = d.z,
                        l[n + 3] = d.x,
                        l[n + 4] = d.y,
                        l[n + 5] = d.z,
                        l[n + 6] = d.x,
                        l[n + 7] = d.y,
                        l[n + 8] = d.z;
                this.normalizeNormals(),
                t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var r = this.attributes;
                for (var i in r)
                    if (void 0 !== e.attributes[i])
                        for (var n = r[i].array, s = e.attributes[i], a = s.array, o = s.itemSize * t, c = Math.min(a.length, n.length - o), l = 0, p = o; l < c; l++,
                        p++)
                            n[p] = a[l];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            var e = new Wt;
            return function() {
                for (var t = this.attributes.normal, r = 0, i = t.count; r < i; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.normalize(),
                    t.setXYZ(r, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function() {
            function e(e, t) {
                for (var r = e.array, i = e.itemSize, n = new r.constructor(t.length * i), s = 0, a = 0, o = 0, c = t.length; o < c; o++) {
                    s = t[o] * i;
                    for (var l = 0; l < i; l++)
                        n[a++] = r[s++]
                }
                return new Xr(n,i)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t = new oi
              , r = this.index.array
              , i = this.attributes;
            for (var n in i) {
                var s = e(i[n], r);
                t.addAttribute(n, s)
            }
            var a = this.morphAttributes;
            for (n in a) {
                for (var o = [], c = a[n], l = 0, p = c.length; l < p; l++) {
                    s = e(c[l], r);
                    o.push(s)
                }
                t.morphAttributes[n] = o
            }
            for (var h = this.groups, u = (l = 0,
            h.length); l < u; l++) {
                var d = h[l];
                t.addGroup(d.start, d.count, d.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var r in t)
                    void 0 !== t[r] && (e[r] = t[r]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (e.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var n = this.attributes;
            for (var r in n) {
                var s = (u = n[r]).toJSON();
                "" !== u.name && (s.name = u.name),
                e.data.attributes[r] = s
            }
            var a = {}
              , o = !1;
            for (var r in this.morphAttributes) {
                for (var c = this.morphAttributes[r], l = [], p = 0, h = c.length; p < h; p++) {
                    var u;
                    s = (u = c[p]).toJSON();
                    "" !== u.name && (s.name = u.name),
                    l.push(s)
                }
                l.length > 0 && (a[r] = l,
                o = !0)
            }
            o && (e.data.morphAttributes = a);
            var d = this.groups;
            d.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(d)));
            var f = this.boundingSphere;
            return null !== f && (e.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }),
            e
        },
        clone: function() {
            return (new oi).copy(this)
        },
        copy: function(e) {
            var t, r, i;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var n = e.index;
            null !== n && this.setIndex(n.clone());
            var s = e.attributes;
            for (t in s) {
                var a = s[t];
                this.addAttribute(t, a.clone())
            }
            var o = e.morphAttributes;
            for (t in o) {
                var c = []
                  , l = o[t];
                for (r = 0,
                i = l.length; r < i; r++)
                    c.push(l[r].clone());
                this.morphAttributes[t] = c
            }
            var p = e.groups;
            for (r = 0,
            i = p.length; r < i; r++) {
                var h = p[r];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            var u = e.boundingBox;
            null !== u && (this.boundingBox = u.clone());
            var d = e.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    ci.prototype = Object.create(Zr.prototype),
    ci.prototype.constructor = ci,
    li.prototype = Object.create(oi.prototype),
    li.prototype.constructor = li,
    pi.prototype = Object.create(Zr.prototype),
    pi.prototype.constructor = pi,
    hi.prototype = Object.create(oi.prototype),
    hi.prototype.constructor = hi;
    var ui = 0;
    function di() {
        Object.defineProperty(this, "id", {
            value: ui++
        }),
        this.uuid = Gt.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.lights = !0,
        this.blending = A,
        this.side = y,
        this.flatShading = !1,
        this.vertexTangents = !1,
        this.vertexColors = _,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = U,
        this.blendDst = G,
        this.blendEquation = L,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = K,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    di.prototype = Object.assign(Object.create(i.prototype), {
        constructor: di,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var r = e[t];
                    if (void 0 !== r)
                        if ("shading" !== t) {
                            var i = this[t];
                            void 0 !== i ? i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        } else
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = r === x;
                    else
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function i(e) {
                var t = [];
                for (var r in e) {
                    var i = e[r];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            this.color && this.color.isColor && (r.color = this.color.getHex()),
            void 0 !== this.roughness && (r.roughness = this.roughness),
            void 0 !== this.metalness && (r.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
            void 0 !== this.shininess && (r.shininess = this.shininess),
            void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (r.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
            r.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
            r.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
            r.normalMapType = this.normalMapType,
            r.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
            r.displacementScale = this.displacementScale,
            r.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
            r.reflectivity = this.reflectivity,
            void 0 !== this.combine && (r.combine = this.combine),
            void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (r.size = this.size),
            void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation),
            this.blending !== A && (r.blending = this.blending),
            !0 === this.flatShading && (r.flatShading = this.flatShading),
            this.side !== y && (r.side = this.side),
            this.vertexColors !== _ && (r.vertexColors = this.vertexColors),
            this.opacity < 1 && (r.opacity = this.opacity),
            !0 === this.transparent && (r.transparent = this.transparent),
            r.depthFunc = this.depthFunc,
            r.depthTest = this.depthTest,
            r.depthWrite = this.depthWrite,
            0 !== this.rotation && (r.rotation = this.rotation),
            !0 === this.polygonOffset && (r.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (r.linewidth = this.linewidth),
            void 0 !== this.dashSize && (r.dashSize = this.dashSize),
            void 0 !== this.gapSize && (r.gapSize = this.gapSize),
            void 0 !== this.scale && (r.scale = this.scale),
            !0 === this.dithering && (r.dithering = !0),
            this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (r.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (r.morphTargets = !0),
            !0 === this.skinning && (r.skinning = !0),
            !1 === this.visible && (r.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            t) {
                var n = i(e.textures)
                  , s = i(e.images);
                n.length > 0 && (r.textures = n),
                s.length > 0 && (r.images = s)
            }
            return r
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.lights = e.lights,
            this.blending = e.blending,
            this.side = e.side,
            this.flatShading = e.flatShading,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.clipShadows = e.clipShadows,
            this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes
              , r = null;
            if (null !== t) {
                var i = t.length;
                r = new Array(i);
                for (var n = 0; n !== i; ++n)
                    r[n] = t[n].clone()
            }
            return this.clippingPlanes = r,
            this.shadowSide = e.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var fi, mi, gi, vi, yi, bi, wi, xi, Mi, _i, Si, Ti, Ei = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", Ai = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    function Pi(e) {
        di.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = Ei,
        this.fragmentShader = Ai,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    function Oi(e, t) {
        this.origin = void 0 !== e ? e : new Wt,
        this.direction = void 0 !== t ? t : new Wt
    }
    function Ri(e, t, r) {
        this.a = void 0 !== e ? e : new Wt,
        this.b = void 0 !== t ? t : new Wt,
        this.c = void 0 !== r ? r : new Wt
    }
    function Ci(e) {
        di.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new Pr(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = re,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Li(e, t) {
        Hr.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== e ? e : new oi,
        this.material = void 0 !== t ? t : new Ci({
            color: 16777215 * Math.random()
        }),
        this.drawMode = At,
        this.updateMorphTargets()
    }
    function Ii(e, t, r, i) {
        var n, s, a = new Pr(0), o = 0, c = null, l = 0;
        function p(e, r) {
            t.buffers.color.setClear(e.r, e.g, e.b, r, i)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(e, t) {
                a.set(e),
                p(a, o = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return o
            },
            setClearAlpha: function(e) {
                p(a, o = e)
            },
            render: function(t, i, h, u) {
                var d = i.background
                  , f = e.vr
                  , m = f.getSession && f.getSession();
                if (m && "additive" === m.environmentBlendMode && (d = null),
                null === d ? (p(a, o),
                c = null,
                l = 0) : d && d.isColor && (p(d, 1),
                u = !0,
                c = null,
                l = 0),
                (e.autoClear || u) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
                    void 0 === s && ((s = new Li(new li(1,1,1),new Pi({
                        type: "BackgroundCubeMaterial",
                        uniforms: xr(Cr.cube.uniforms),
                        vertexShader: Cr.cube.vertexShader,
                        fragmentShader: Cr.cube.fragmentShader,
                        side: b,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"),
                    s.geometry.removeAttribute("uv"),
                    s.onBeforeRender = function(e, t, r) {
                        this.matrixWorld.copyPosition(r.matrixWorld)
                    }
                    ,
                    Object.defineProperty(s.material, "map", {
                        get: function() {
                            return this.uniforms.tCube.value
                        }
                    }),
                    r.update(s));
                    var g = d.isWebGLRenderTargetCube ? d.texture : d;
                    s.material.uniforms.tCube.value = g,
                    s.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ? 1 : -1,
                    c === d && l === g.version || (s.material.needsUpdate = !0,
                    c = d,
                    l = g.version),
                    t.unshift(s, s.geometry, s.material, 0, 0, null)
                } else
                    d && d.isTexture && (void 0 === n && ((n = new Li(new hi(2,2),new Pi({
                        type: "BackgroundMaterial",
                        uniforms: xr(Cr.background.uniforms),
                        vertexShader: Cr.background.vertexShader,
                        fragmentShader: Cr.background.fragmentShader,
                        side: y,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"),
                    Object.defineProperty(n.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    r.update(n)),
                    n.material.uniforms.t2D.value = d,
                    !0 === d.matrixAutoUpdate && d.updateMatrix(),
                    n.material.uniforms.uvTransform.value.copy(d.matrix),
                    c === d && l === d.version || (n.material.needsUpdate = !0,
                    c = d,
                    l = d.version),
                    t.unshift(n, n.geometry, n.material, 0, 0, null))
            }
        }
    }
    function ki(e, t, r, i) {
        var n;
        this.setMode = function(e) {
            n = e
        }
        ,
        this.render = function(t, i) {
            e.drawArrays(n, t, i),
            r.update(i, n)
        }
        ,
        this.renderInstances = function(s, a, o) {
            var c;
            if (i.isWebGL2)
                c = e;
            else if (null === (c = t.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            c[i.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](n, a, o, s.maxInstancedCount),
            r.update(o, n, s.maxInstancedCount)
        }
    }
    function Di(e, t, r) {
        var i;
        function n(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        var s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext
          , a = void 0 !== r.precision ? r.precision : "highp"
          , o = n(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
        a = o);
        var c = !0 === r.logarithmicDepthBuffer
          , l = e.getParameter(34930)
          , p = e.getParameter(35660)
          , h = e.getParameter(3379)
          , u = e.getParameter(34076)
          , d = e.getParameter(34921)
          , f = e.getParameter(36347)
          , m = e.getParameter(36348)
          , g = e.getParameter(36349)
          , v = p > 0
          , y = s || !!t.get("OES_texture_float");
        return {
            isWebGL2: s,
            getMaxAnisotropy: function() {
                if (void 0 !== i)
                    return i;
                var r = t.get("EXT_texture_filter_anisotropic");
                return i = null !== r ? e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: l,
            maxVertexTextures: p,
            maxTextureSize: h,
            maxCubemapSize: u,
            maxAttributes: d,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? e.getParameter(36183) : 0
        }
    }
    function zi() {
        var e = this
          , t = null
          , r = 0
          , i = !1
          , n = !1
          , s = new vr
          , a = new Yt
          , o = {
            value: null,
            needsUpdate: !1
        };
        function c() {
            o.value !== t && (o.value = t,
            o.needsUpdate = r > 0),
            e.numPlanes = r,
            e.numIntersection = 0
        }
        function l(t, r, i, n) {
            var c = null !== t ? t.length : 0
              , l = null;
            if (0 !== c) {
                if (l = o.value,
                !0 !== n || null === l) {
                    var p = i + 4 * c
                      , h = r.matrixWorldInverse;
                    a.getNormalMatrix(h),
                    (null === l || l.length < p) && (l = new Float32Array(p));
                    for (var u = 0, d = i; u !== c; ++u,
                    d += 4)
                        s.copy(t[u]).applyMatrix4(h, a),
                        s.normal.toArray(l, d),
                        l[d + 3] = s.constant
                }
                o.value = l,
                o.needsUpdate = !0
            }
            return e.numPlanes = c,
            l
        }
        this.uniform = o,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(e, n, s) {
            var a = 0 !== e.length || n || 0 !== r || i;
            return i = n,
            t = l(e, s, 0),
            r = e.length,
            a
        }
        ,
        this.beginShadows = function() {
            n = !0,
            l(null)
        }
        ,
        this.endShadows = function() {
            n = !1,
            c()
        }
        ,
        this.setState = function(e, s, a, p, h, u) {
            if (!i || null === e || 0 === e.length || n && !a)
                n ? l(null) : c();
            else {
                var d = n ? 0 : r
                  , f = 4 * d
                  , m = h.clippingState || null;
                o.value = m,
                m = l(e, p, f, u);
                for (var g = 0; g !== f; ++g)
                    m[g] = t[g];
                h.clippingState = m,
                this.numIntersection = s ? this.numPlanes : 0,
                this.numPlanes += d
            }
        }
    }
    function Bi(e) {
        var t = {};
        return {
            get: function(r) {
                if (void 0 !== t[r])
                    return t[r];
                var i;
                switch (r) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(r)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
                t[r] = i,
                i
            }
        }
    }
    function Ni(e, t, r) {
        var i = {}
          , n = {};
        function s(e) {
            var a = e.target
              , o = i[a.id];
            for (var c in null !== o.index && t.remove(o.index),
            o.attributes)
                t.remove(o.attributes[c]);
            a.removeEventListener("dispose", s),
            delete i[a.id];
            var l = n[o.id];
            l && (t.remove(l),
            delete n[o.id]),
            r.memory.geometries--
        }
        return {
            get: function(e, t) {
                var n = i[t.id];
                return n || (t.addEventListener("dispose", s),
                t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new oi).setFromObject(e)),
                n = t._bufferGeometry),
                i[t.id] = n,
                r.memory.geometries++,
                n)
            },
            update: function(e) {
                var r = e.index
                  , i = e.attributes;
                for (var n in null !== r && t.update(r, 34963),
                i)
                    t.update(i[n], 34962);
                var s = e.morphAttributes;
                for (var n in s)
                    for (var a = s[n], o = 0, c = a.length; o < c; o++)
                        t.update(a[o], 34962)
            },
            getWireframeAttribute: function(e) {
                var r = n[e.id];
                if (r)
                    return r;
                var i, s = [], a = e.index, o = e.attributes;
                if (null !== a)
                    for (var c = 0, l = (i = a.array).length; c < l; c += 3) {
                        var p = i[c + 0]
                          , h = i[c + 1]
                          , u = i[c + 2];
                        s.push(p, h, h, u, u, p)
                    }
                else
                    for (c = 0,
                    l = (i = o.position.array).length / 3 - 1; c < l; c += 3)
                        p = c + 0,
                        h = c + 1,
                        u = c + 2,
                        s.push(p, h, h, u, u, p);
                return r = new (si(s) > 65535 ? ti : $r)(s,1),
                t.update(r, 34963),
                n[e.id] = r,
                r
            }
        }
    }
    function ji(e, t, r, i) {
        var n, s, a;
        this.setMode = function(e) {
            n = e
        }
        ,
        this.setIndex = function(e) {
            s = e.type,
            a = e.bytesPerElement
        }
        ,
        this.render = function(t, i) {
            e.drawElements(n, i, s, t * a),
            r.update(i, n)
        }
        ,
        this.renderInstances = function(o, c, l) {
            var p;
            if (i.isWebGL2)
                p = e;
            else if (null === (p = t.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            p[i.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](n, l, s, c * a, o.maxInstancedCount),
            r.update(l, n, o.maxInstancedCount)
        }
    }
    function Fi(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++,
                t.calls = 0,
                t.triangles = 0,
                t.points = 0,
                t.lines = 0
            },
            update: function(e, r, i) {
                switch (i = i || 1,
                t.calls++,
                r) {
                case 4:
                    t.triangles += i * (e / 3);
                    break;
                case 5:
                case 6:
                    t.triangles += i * (e - 2);
                    break;
                case 1:
                    t.lines += i * (e / 2);
                    break;
                case 3:
                    t.lines += i * (e - 1);
                    break;
                case 2:
                    t.lines += i * e;
                    break;
                case 0:
                    t.points += i * e;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                }
            }
        }
    }
    function Ui(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function Gi(e) {
        var t = {}
          , r = new Float32Array(8);
        return {
            update: function(i, n, s, a) {
                var o = i.morphTargetInfluences
                  , c = o.length
                  , l = t[n.id];
                if (void 0 === l) {
                    l = [];
                    for (var p = 0; p < c; p++)
                        l[p] = [p, 0];
                    t[n.id] = l
                }
                var h = s.morphTargets && n.morphAttributes.position
                  , u = s.morphNormals && n.morphAttributes.normal;
                for (p = 0; p < c; p++)
                    0 !== (d = l[p])[1] && (h && n.removeAttribute("morphTarget" + p),
                    u && n.removeAttribute("morphNormal" + p));
                for (p = 0; p < c; p++)
                    (d = l[p])[0] = p,
                    d[1] = o[p];
                for (l.sort(Ui),
                p = 0; p < 8; p++) {
                    var d;
                    if (d = l[p]) {
                        var f = d[0]
                          , m = d[1];
                        if (m) {
                            h && n.addAttribute("morphTarget" + p, h[f]),
                            u && n.addAttribute("morphNormal" + p, u[f]),
                            r[p] = m;
                            continue
                        }
                    }
                    r[p] = 0
                }
                a.getUniforms().setValue(e, "morphTargetInfluences", r)
            }
        }
    }
    function Hi(e, t) {
        var r = {};
        return {
            update: function(i) {
                var n = t.render.frame
                  , s = i.geometry
                  , a = e.get(i, s);
                return r[a.id] !== n && (s.isGeometry && a.updateFromObject(i),
                e.update(a),
                r[a.id] = n),
                a
            },
            dispose: function() {
                r = {}
            }
        }
    }
    function Vi(e, t, r, i, n, s, a, o, c, l) {
        e = void 0 !== e ? e : [],
        t = void 0 !== t ? t : ue,
        a = void 0 !== a ? a : Ue,
        lr.call(this, e, t, r, i, n, s, a, o, c, l),
        this.flipY = !1
    }
    function Wi(e, t, r, i) {
        lr.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Me,
        this.minFilter = Me,
        this.wrapR = we,
        this.generateMipmaps = !1,
        this.flipY = !1
    }
    function Yi(e, t, r, i) {
        lr.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Me,
        this.minFilter = Me,
        this.wrapR = we,
        this.generateMipmaps = !1,
        this.flipY = !1
    }
    Pi.prototype = Object.create(di.prototype),
    Pi.prototype.constructor = Pi,
    Pi.prototype.isShaderMaterial = !0,
    Pi.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = xr(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = e.extensions,
        this
    }
    ,
    Pi.prototype.toJSON = function(e) {
        var t = di.prototype.toJSON.call(this, e);
        for (var r in t.uniforms = {},
        this.uniforms) {
            var i = this.uniforms[r].value;
            i && i.isTexture ? t.uniforms[r] = {
                type: "t",
                value: i.toJSON(e).uuid
            } : i && i.isColor ? t.uniforms[r] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: i.toArray()
            } : t.uniforms[r] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        var n = {};
        for (var s in this.extensions)
            !0 === this.extensions[s] && (n[s] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
    ,
    Object.assign(Oi.prototype, {
        set: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
            t = new Wt),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        },
        recast: function() {
            var e = new Wt;
            return function(t) {
                return this.origin.copy(this.at(t, e)),
                this
            }
        }(),
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            t = new Wt),
            t.subVectors(e, this.origin);
            var r = t.dot(this.direction);
            return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new Wt;
            return function(t) {
                var r = e.subVectors(t, this.origin).dot(this.direction);
                return r < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(r).add(this.origin),
                e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: (mi = new Wt,
        gi = new Wt,
        vi = new Wt,
        function(e, t, r, i) {
            mi.copy(e).add(t).multiplyScalar(.5),
            gi.copy(t).sub(e).normalize(),
            vi.copy(this.origin).sub(mi);
            var n, s, a, o, c = .5 * e.distanceTo(t), l = -this.direction.dot(gi), p = vi.dot(this.direction), h = -vi.dot(gi), u = vi.lengthSq(), d = Math.abs(1 - l * l);
            if (d > 0)
                if (s = l * p - h,
                o = c * d,
                (n = l * h - p) >= 0)
                    if (s >= -o)
                        if (s <= o) {
                            var f = 1 / d;
                            a = (n *= f) * (n + l * (s *= f) + 2 * p) + s * (l * n + s + 2 * h) + u
                        } else
                            s = c,
                            a = -(n = Math.max(0, -(l * s + p))) * n + s * (s + 2 * h) + u;
                    else
                        s = -c,
                        a = -(n = Math.max(0, -(l * s + p))) * n + s * (s + 2 * h) + u;
                else
                    s <= -o ? a = -(n = Math.max(0, -(-l * c + p))) * n + (s = n > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (s + 2 * h) + u : s <= o ? (n = 0,
                    a = (s = Math.min(Math.max(-c, -h), c)) * (s + 2 * h) + u) : a = -(n = Math.max(0, -(l * c + p))) * n + (s = n > 0 ? c : Math.min(Math.max(-c, -h), c)) * (s + 2 * h) + u;
            else
                s = l > 0 ? -c : c,
                a = -(n = Math.max(0, -(l * s + p))) * n + s * (s + 2 * h) + u;
            return r && r.copy(this.direction).multiplyScalar(n).add(this.origin),
            i && i.copy(gi).multiplyScalar(s).add(mi),
            a
        }
        ),
        intersectSphere: function() {
            var e = new Wt;
            return function(t, r) {
                e.subVectors(t.center, this.origin);
                var i = e.dot(this.direction)
                  , n = e.dot(e) - i * i
                  , s = t.radius * t.radius;
                if (n > s)
                    return null;
                var a = Math.sqrt(s - n)
                  , o = i - a
                  , c = i + a;
                return o < 0 && c < 0 ? null : o < 0 ? this.at(c, r) : this.at(o, r)
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var r = -(this.origin.dot(e.normal) + e.constant) / t;
            return r >= 0 ? r : null
        },
        intersectPlane: function(e, t) {
            var r = this.distanceToPlane(e);
            return null === r ? null : this.at(r, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var r, i, n, s, a, o, c = 1 / this.direction.x, l = 1 / this.direction.y, p = 1 / this.direction.z, h = this.origin;
            return c >= 0 ? (r = (e.min.x - h.x) * c,
            i = (e.max.x - h.x) * c) : (r = (e.max.x - h.x) * c,
            i = (e.min.x - h.x) * c),
            l >= 0 ? (n = (e.min.y - h.y) * l,
            s = (e.max.y - h.y) * l) : (n = (e.max.y - h.y) * l,
            s = (e.min.y - h.y) * l),
            r > s || n > i ? null : ((n > r || r != r) && (r = n),
            (s < i || i != i) && (i = s),
            p >= 0 ? (a = (e.min.z - h.z) * p,
            o = (e.max.z - h.z) * p) : (a = (e.max.z - h.z) * p,
            o = (e.min.z - h.z) * p),
            r > o || a > i ? null : ((a > r || r != r) && (r = a),
            (o < i || i != i) && (i = o),
            i < 0 ? null : this.at(r >= 0 ? r : i, t)))
        },
        intersectsBox: (fi = new Wt,
        function(e) {
            return null !== this.intersectBox(e, fi)
        }
        ),
        intersectTriangle: function() {
            var e = new Wt
              , t = new Wt
              , r = new Wt
              , i = new Wt;
            return function(n, s, a, o, c) {
                t.subVectors(s, n),
                r.subVectors(a, n),
                i.crossVectors(t, r);
                var l, p = this.direction.dot(i);
                if (p > 0) {
                    if (o)
                        return null;
                    l = 1
                } else {
                    if (!(p < 0))
                        return null;
                    l = -1,
                    p = -p
                }
                e.subVectors(this.origin, n);
                var h = l * this.direction.dot(r.crossVectors(e, r));
                if (h < 0)
                    return null;
                var u = l * this.direction.dot(t.cross(e));
                if (u < 0)
                    return null;
                if (h + u > p)
                    return null;
                var d = -l * e.dot(i);
                return d < 0 ? null : this.at(d / p, c)
            }
        }(),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }),
    Object.assign(Ri, {
        getNormal: (bi = new Wt,
        function(e, t, r, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            i = new Wt),
            i.subVectors(r, t),
            bi.subVectors(e, t),
            i.cross(bi);
            var n = i.lengthSq();
            return n > 0 ? i.multiplyScalar(1 / Math.sqrt(n)) : i.set(0, 0, 0)
        }
        ),
        getBarycoord: function() {
            var e = new Wt
              , t = new Wt
              , r = new Wt;
            return function(i, n, s, a, o) {
                e.subVectors(a, n),
                t.subVectors(s, n),
                r.subVectors(i, n);
                var c = e.dot(e)
                  , l = e.dot(t)
                  , p = e.dot(r)
                  , h = t.dot(t)
                  , u = t.dot(r)
                  , d = c * h - l * l;
                if (void 0 === o && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                o = new Wt),
                0 === d)
                    return o.set(-2, -1, -1);
                var f = 1 / d
                  , m = (h * p - l * u) * f
                  , g = (c * u - l * p) * f;
                return o.set(1 - m - g, g, m)
            }
        }(),
        containsPoint: function() {
            var e = new Wt;
            return function(t, r, i, n) {
                return Ri.getBarycoord(t, r, i, n, e),
                e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
            }
        }(),
        getUV: (yi = new Wt,
        function(e, t, r, i, n, s, a, o) {
            return this.getBarycoord(e, t, r, i, yi),
            o.set(0, 0),
            o.addScaledVector(n, yi.x),
            o.addScaledVector(s, yi.y),
            o.addScaledVector(a, yi.z),
            o
        }
        ),
        isFrontFacing: function() {
            var e = new Wt
              , t = new Wt;
            return function(r, i, n, s) {
                return e.subVectors(n, i),
                t.subVectors(r, i),
                e.cross(t).dot(s) < 0
            }
        }()
    }),
    Object.assign(Ri.prototype, {
        set: function(e, t, r) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(r),
            this
        },
        setFromPointsAndIndices: function(e, t, r, i) {
            return this.a.copy(e[t]),
            this.b.copy(e[r]),
            this.c.copy(e[i]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        },
        getArea: function() {
            var e = new Wt
              , t = new Wt;
            return function() {
                return e.subVectors(this.c, this.b),
                t.subVectors(this.a, this.b),
                .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            e = new Wt),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return Ri.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            e = new Wt),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return Ri.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function(e, t, r, i, n) {
            return Ri.getUV(e, this.a, this.b, this.c, t, r, i, n)
        },
        containsPoint: function(e) {
            return Ri.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function(e) {
            return Ri.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: (wi = new Wt,
        xi = new Wt,
        Mi = new Wt,
        _i = new Wt,
        Si = new Wt,
        Ti = new Wt,
        function(e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            t = new Wt);
            var r, i, n = this.a, s = this.b, a = this.c;
            wi.subVectors(s, n),
            xi.subVectors(a, n),
            _i.subVectors(e, n);
            var o = wi.dot(_i)
              , c = xi.dot(_i);
            if (o <= 0 && c <= 0)
                return t.copy(n);
            Si.subVectors(e, s);
            var l = wi.dot(Si)
              , p = xi.dot(Si);
            if (l >= 0 && p <= l)
                return t.copy(s);
            var h = o * p - l * c;
            if (h <= 0 && o >= 0 && l <= 0)
                return r = o / (o - l),
                t.copy(n).addScaledVector(wi, r);
            Ti.subVectors(e, a);
            var u = wi.dot(Ti)
              , d = xi.dot(Ti);
            if (d >= 0 && u <= d)
                return t.copy(a);
            var f = u * c - o * d;
            if (f <= 0 && c >= 0 && d <= 0)
                return i = c / (c - d),
                t.copy(n).addScaledVector(xi, i);
            var m = l * d - u * p;
            if (m <= 0 && p - l >= 0 && u - d >= 0)
                return Mi.subVectors(a, s),
                i = (p - l) / (p - l + (u - d)),
                t.copy(s).addScaledVector(Mi, i);
            var g = 1 / (m + f + h);
            return r = f * g,
            i = h * g,
            t.copy(n).addScaledVector(wi, r).addScaledVector(xi, i)
        }
        ),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }),
    Ci.prototype = Object.create(di.prototype),
    Ci.prototype.constructor = Ci,
    Ci.prototype.isMeshBasicMaterial = !0,
    Ci.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    Li.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Li,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return Hr.prototype.copy.call(this, e),
            this.drawMode = e.drawMode,
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var e, t, r, i = this.geometry;
            if (i.isBufferGeometry) {
                var n = i.morphAttributes
                  , s = Object.keys(n);
                if (s.length > 0) {
                    var a = n[s[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = a.length; e < t; e++)
                            r = a[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[r] = e
                }
            } else {
                var o = i.morphTargets;
                void 0 !== o && o.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function() {
            var e = new br
              , t = new Oi
              , r = new gr
              , i = new Wt
              , n = new Wt
              , s = new Wt
              , a = new Wt
              , o = new Wt
              , c = new Wt
              , l = new Wt
              , p = new Wt
              , h = new Wt
              , u = new Ht
              , d = new Ht
              , f = new Ht
              , m = new Wt
              , g = new Wt;
            function v(e, t, r, i, n, s, a, o) {
                if (null === (t.side === b ? i.intersectTriangle(a, s, n, !0, o) : i.intersectTriangle(n, s, a, t.side !== w, o)))
                    return null;
                g.copy(o),
                g.applyMatrix4(e.matrixWorld);
                var c = r.ray.origin.distanceTo(g);
                return c < r.near || c > r.far ? null : {
                    distance: c,
                    point: g.clone(),
                    object: e
                }
            }
            function y(e, t, r, g, y, b, w, x, M, _) {
                i.fromBufferAttribute(y, x),
                n.fromBufferAttribute(y, M),
                s.fromBufferAttribute(y, _);
                var S = e.morphTargetInfluences;
                if (t.morphTargets && b && S) {
                    l.set(0, 0, 0),
                    p.set(0, 0, 0),
                    h.set(0, 0, 0);
                    for (var T = 0, E = b.length; T < E; T++) {
                        var A = S[T]
                          , P = b[T];
                        0 !== A && (a.fromBufferAttribute(P, x),
                        o.fromBufferAttribute(P, M),
                        c.fromBufferAttribute(P, _),
                        l.addScaledVector(a.sub(i), A),
                        p.addScaledVector(o.sub(n), A),
                        h.addScaledVector(c.sub(s), A))
                    }
                    i.add(l),
                    n.add(p),
                    s.add(h)
                }
                var O = v(e, t, r, g, i, n, s, m);
                if (O) {
                    w && (u.fromBufferAttribute(w, x),
                    d.fromBufferAttribute(w, M),
                    f.fromBufferAttribute(w, _),
                    O.uv = Ri.getUV(m, i, n, s, u, d, f, new Ht));
                    var R = new kr(x,M,_);
                    Ri.getNormal(i, n, s, R.normal),
                    O.face = R
                }
                return O
            }
            return function(i, n) {
                var s, a = this.geometry, o = this.material, c = this.matrixWorld;
                if (void 0 !== o && (null === a.boundingSphere && a.computeBoundingSphere(),
                r.copy(a.boundingSphere),
                r.applyMatrix4(c),
                !1 !== i.ray.intersectsSphere(r) && (e.getInverse(c),
                t.copy(i.ray).applyMatrix4(e),
                null === a.boundingBox || !1 !== t.intersectsBox(a.boundingBox))))
                    if (a.isBufferGeometry) {
                        var l, p, h, g, b, w, x, M, _, S = a.index, T = a.attributes.position, E = a.morphAttributes.position, A = a.attributes.uv, P = a.groups, O = a.drawRange;
                        if (null !== S)
                            if (Array.isArray(o))
                                for (g = 0,
                                w = P.length; g < w; g++)
                                    for (_ = o[(M = P[g]).materialIndex],
                                    b = Math.max(M.start, O.start),
                                    x = Math.min(M.start + M.count, O.start + O.count); b < x; b += 3)
                                        l = S.getX(b),
                                        p = S.getX(b + 1),
                                        h = S.getX(b + 2),
                                        (s = y(this, _, i, t, T, E, A, l, p, h)) && (s.faceIndex = Math.floor(b / 3),
                                        s.face.materialIndex = M.materialIndex,
                                        n.push(s));
                            else
                                for (g = Math.max(0, O.start),
                                w = Math.min(S.count, O.start + O.count); g < w; g += 3)
                                    l = S.getX(g),
                                    p = S.getX(g + 1),
                                    h = S.getX(g + 2),
                                    (s = y(this, o, i, t, T, E, A, l, p, h)) && (s.faceIndex = Math.floor(g / 3),
                                    n.push(s));
                        else if (void 0 !== T)
                            if (Array.isArray(o))
                                for (g = 0,
                                w = P.length; g < w; g++)
                                    for (_ = o[(M = P[g]).materialIndex],
                                    b = Math.max(M.start, O.start),
                                    x = Math.min(M.start + M.count, O.start + O.count); b < x; b += 3)
                                        (s = y(this, _, i, t, T, E, A, l = b, p = b + 1, h = b + 2)) && (s.faceIndex = Math.floor(b / 3),
                                        s.face.materialIndex = M.materialIndex,
                                        n.push(s));
                            else
                                for (g = Math.max(0, O.start),
                                w = Math.min(T.count, O.start + O.count); g < w; g += 3)
                                    (s = y(this, o, i, t, T, E, A, l = g, p = g + 1, h = g + 2)) && (s.faceIndex = Math.floor(g / 3),
                                    n.push(s))
                    } else if (a.isGeometry) {
                        var R, C, L, I, k = Array.isArray(o), D = a.vertices, z = a.faces, B = a.faceVertexUvs[0];
                        B.length > 0 && (I = B);
                        for (var N = 0, j = z.length; N < j; N++) {
                            var F = z[N]
                              , U = k ? o[F.materialIndex] : o;
                            if (void 0 !== U && (R = D[F.a],
                            C = D[F.b],
                            L = D[F.c],
                            s = v(this, U, i, t, R, C, L, m))) {
                                if (I && I[N]) {
                                    var G = I[N];
                                    u.copy(G[0]),
                                    d.copy(G[1]),
                                    f.copy(G[2]),
                                    s.uv = Ri.getUV(m, R, C, L, u, d, f, new Ht)
                                }
                                s.face = F,
                                s.faceIndex = N,
                                n.push(s)
                            }
                        }
                    }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Vi.prototype = Object.create(lr.prototype),
    Vi.prototype.constructor = Vi,
    Vi.prototype.isCubeTexture = !0,
    Object.defineProperty(Vi.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }),
    Wi.prototype = Object.create(lr.prototype),
    Wi.prototype.constructor = Wi,
    Wi.prototype.isDataTexture2DArray = !0,
    Yi.prototype = Object.create(lr.prototype),
    Yi.prototype.constructor = Yi,
    Yi.prototype.isDataTexture3D = !0;
    var Zi = new lr
      , Xi = new Wi
      , qi = new Yi
      , Ji = new Vi
      , Ki = []
      , Qi = []
      , $i = new Float32Array(16)
      , en = new Float32Array(9)
      , tn = new Float32Array(4);
    function rn(e, t, r) {
        var i = e[0];
        if (i <= 0 || i > 0)
            return e;
        var n = t * r
          , s = Ki[n];
        if (void 0 === s && (s = new Float32Array(n),
        Ki[n] = s),
        0 !== t) {
            i.toArray(s, 0);
            for (var a = 1, o = 0; a !== t; ++a)
                o += r,
                e[a].toArray(s, o)
        }
        return s
    }
    function nn(e, t) {
        if (e.length !== t.length)
            return !1;
        for (var r = 0, i = e.length; r < i; r++)
            if (e[r] !== t[r])
                return !1;
        return !0
    }
    function sn(e, t) {
        for (var r = 0, i = t.length; r < i; r++)
            e[r] = t[r]
    }
    function an(e, t) {
        var r = Qi[t];
        void 0 === r && (r = new Int32Array(t),
        Qi[t] = r);
        for (var i = 0; i !== t; ++i)
            r[i] = e.allocateTextureUnit();
        return r
    }
    function on(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1f(this.addr, t),
        r[0] = t)
    }
    function cn(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
            r[0] = t.x,
            r[1] = t.y);
        else {
            if (nn(r, t))
                return;
            e.uniform2fv(this.addr, t),
            sn(r, t)
        }
    }
    function ln(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y && r[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
            r[0] = t.x,
            r[1] = t.y,
            r[2] = t.z);
        else if (void 0 !== t.r)
            r[0] === t.r && r[1] === t.g && r[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
            r[0] = t.r,
            r[1] = t.g,
            r[2] = t.b);
        else {
            if (nn(r, t))
                return;
            e.uniform3fv(this.addr, t),
            sn(r, t)
        }
    }
    function pn(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            r[0] = t.x,
            r[1] = t.y,
            r[2] = t.z,
            r[3] = t.w);
        else {
            if (nn(r, t))
                return;
            e.uniform4fv(this.addr, t),
            sn(r, t)
        }
    }
    function hn(e, t) {
        var r = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (nn(r, t))
                return;
            e.uniformMatrix2fv(this.addr, !1, t),
            sn(r, t)
        } else {
            if (nn(r, i))
                return;
            tn.set(i),
            e.uniformMatrix2fv(this.addr, !1, tn),
            sn(r, i)
        }
    }
    function un(e, t) {
        var r = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (nn(r, t))
                return;
            e.uniformMatrix3fv(this.addr, !1, t),
            sn(r, t)
        } else {
            if (nn(r, i))
                return;
            en.set(i),
            e.uniformMatrix3fv(this.addr, !1, en),
            sn(r, i)
        }
    }
    function dn(e, t) {
        var r = this.cache
          , i = t.elements;
        if (void 0 === i) {
            if (nn(r, t))
                return;
            e.uniformMatrix4fv(this.addr, !1, t),
            sn(r, t)
        } else {
            if (nn(r, i))
                return;
            $i.set(i),
            e.uniformMatrix4fv(this.addr, !1, $i),
            sn(r, i)
        }
    }
    function fn(e, t, r) {
        var i = this.cache
          , n = r.allocateTextureUnit();
        i[0] !== n && (e.uniform1i(this.addr, n),
        i[0] = n),
        r.safeSetTexture2D(t || Zi, n)
    }
    function mn(e, t, r) {
        var i = this.cache
          , n = r.allocateTextureUnit();
        i[0] !== n && (e.uniform1i(this.addr, n),
        i[0] = n),
        r.setTexture2DArray(t || Xi, n)
    }
    function gn(e, t, r) {
        var i = this.cache
          , n = r.allocateTextureUnit();
        i[0] !== n && (e.uniform1i(this.addr, n),
        i[0] = n),
        r.setTexture3D(t || qi, n)
    }
    function vn(e, t, r) {
        var i = this.cache
          , n = r.allocateTextureUnit();
        i[0] !== n && (e.uniform1i(this.addr, n),
        i[0] = n),
        r.safeSetTextureCube(t || Ji, n)
    }
    function yn(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1i(this.addr, t),
        r[0] = t)
    }
    function bn(e, t) {
        var r = this.cache;
        nn(r, t) || (e.uniform2iv(this.addr, t),
        sn(r, t))
    }
    function wn(e, t) {
        var r = this.cache;
        nn(r, t) || (e.uniform3iv(this.addr, t),
        sn(r, t))
    }
    function xn(e, t) {
        var r = this.cache;
        nn(r, t) || (e.uniform4iv(this.addr, t),
        sn(r, t))
    }
    function Mn(e, t) {
        e.uniform1fv(this.addr, t)
    }
    function _n(e, t) {
        e.uniform1iv(this.addr, t)
    }
    function Sn(e, t) {
        e.uniform2iv(this.addr, t)
    }
    function Tn(e, t) {
        e.uniform3iv(this.addr, t)
    }
    function En(e, t) {
        e.uniform4iv(this.addr, t)
    }
    function An(e, t) {
        var r = rn(t, this.size, 2);
        e.uniform2fv(this.addr, r)
    }
    function Pn(e, t) {
        var r = rn(t, this.size, 3);
        e.uniform3fv(this.addr, r)
    }
    function On(e, t) {
        var r = rn(t, this.size, 4);
        e.uniform4fv(this.addr, r)
    }
    function Rn(e, t) {
        var r = rn(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, r)
    }
    function Cn(e, t) {
        var r = rn(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, r)
    }
    function Ln(e, t) {
        var r = rn(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, r)
    }
    function In(e, t, r) {
        var i = t.length
          , n = an(r, i);
        e.uniform1iv(this.addr, n);
        for (var s = 0; s !== i; ++s)
            r.safeSetTexture2D(t[s] || Zi, n[s])
    }
    function kn(e, t, r) {
        var i = t.length
          , n = an(r, i);
        e.uniform1iv(this.addr, n);
        for (var s = 0; s !== i; ++s)
            r.safeSetTextureCube(t[s] || Ji, n[s])
    }
    function Dn(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return on;
            case 35664:
                return cn;
            case 35665:
                return ln;
            case 35666:
                return pn;
            case 35674:
                return hn;
            case 35675:
                return un;
            case 35676:
                return dn;
            case 35678:
            case 36198:
                return fn;
            case 35679:
                return gn;
            case 35680:
                return vn;
            case 36289:
                return mn;
            case 5124:
            case 35670:
                return yn;
            case 35667:
            case 35671:
                return bn;
            case 35668:
            case 35672:
                return wn;
            case 35669:
            case 35673:
                return xn
            }
        }(t.type)
    }
    function zn(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Mn;
            case 35664:
                return An;
            case 35665:
                return Pn;
            case 35666:
                return On;
            case 35674:
                return Rn;
            case 35675:
                return Cn;
            case 35676:
                return Ln;
            case 35678:
                return In;
            case 35680:
                return kn;
            case 5124:
            case 35670:
                return _n;
            case 35667:
            case 35671:
                return Sn;
            case 35668:
            case 35672:
                return Tn;
            case 35669:
            case 35673:
                return En
            }
        }(t.type)
    }
    function Bn(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    zn.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        sn(t, e)
    }
    ,
    Bn.prototype.setValue = function(e, t, r) {
        for (var i = this.seq, n = 0, s = i.length; n !== s; ++n) {
            var a = i[n];
            a.setValue(e, t[a.id], r)
        }
    }
    ;
    var Nn = /([\w\d_]+)(\])?(\[|\.)?/g;
    function jn(e, t) {
        e.seq.push(t),
        e.map[t.id] = t
    }
    function Fn(e, t, r) {
        var i = e.name
          , n = i.length;
        for (Nn.lastIndex = 0; ; ) {
            var s = Nn.exec(i)
              , a = Nn.lastIndex
              , o = s[1]
              , c = "]" === s[2]
              , l = s[3];
            if (c && (o |= 0),
            void 0 === l || "[" === l && a + 2 === n) {
                jn(r, void 0 === l ? new Dn(o,e,t) : new zn(o,e,t));
                break
            }
            var p = r.map[o];
            void 0 === p && jn(r, p = new Bn(o)),
            r = p
        }
    }
    function Un(e, t) {
        this.seq = [],
        this.map = {};
        for (var r = e.getProgramParameter(t, 35718), i = 0; i < r; ++i) {
            var n = e.getActiveUniform(t, i);
            Fn(n, e.getUniformLocation(t, n.name), this)
        }
    }
    function Gn(e, t, r, i) {
        var n = e.createShader(t);
        return e.shaderSource(n, r),
        e.compileShader(n),
        !0 === i && (!1 === e.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(n), function(e) {
            for (var t = e.split("\n"), r = 0; r < t.length; r++)
                t[r] = r + 1 + ": " + t[r];
            return t.join("\n")
        }(r))),
        n
    }
    Un.prototype.setValue = function(e, t, r, i) {
        var n = this.map[t];
        void 0 !== n && n.setValue(e, r, i)
    }
    ,
    Un.prototype.setOptional = function(e, t, r) {
        var i = t[r];
        void 0 !== i && this.setValue(e, r, i)
    }
    ,
    Un.upload = function(e, t, r, i) {
        for (var n = 0, s = t.length; n !== s; ++n) {
            var a = t[n]
              , o = r[a.id];
            !1 !== o.needsUpdate && a.setValue(e, o.value, i)
        }
    }
    ,
    Un.seqWithValue = function(e, t) {
        for (var r = [], i = 0, n = e.length; i !== n; ++i) {
            var s = e[i];
            s.id in t && r.push(s)
        }
        return r
    }
    ;
    var Hn = 0;
    function Vn(e) {
        switch (e) {
        case Rt:
            return ["Linear", "( value )"];
        case Ct:
            return ["sRGB", "( value )"];
        case It:
            return ["RGBE", "( value )"];
        case Dt:
            return ["RGBM", "( value, 7.0 )"];
        case zt:
            return ["RGBM", "( value, 16.0 )"];
        case Bt:
            return ["RGBD", "( value, 256.0 )"];
        case Lt:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + e)
        }
    }
    function Wn(e, t) {
        var r = Vn(t);
        return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
    }
    function Yn(e, t) {
        var r;
        switch (t) {
        case ae:
            r = "Linear";
            break;
        case oe:
            r = "Reinhard";
            break;
        case ce:
            r = "Uncharted2";
            break;
        case le:
            r = "OptimizedCineon";
            break;
        case pe:
            r = "ACESFilmic";
            break;
        default:
            throw new Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
    }
    function Zn(e) {
        return "" !== e
    }
    function Xn(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }
    function qn(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    function Jn(e) {
        return e.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function(e, t) {
            var r = wr[t];
            if (void 0 === r)
                throw new Error("Can not resolve #include <" + t + ">");
            return Jn(r)
        })
    }
    function Kn(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, r, i) {
            for (var n = "", s = parseInt(t); s < parseInt(r); s++)
                n += i.replace(/\[ i \]/g, "[ " + s + " ]");
            return n
        })
    }
    function Qn(e, t, r, i, n, s, a, o) {
        var c = e.context
          , l = i.defines
          , p = n.vertexShader
          , h = n.fragmentShader
          , u = "SHADOWMAP_TYPE_BASIC";
        s.shadowMapType === g ? u = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === v && (u = "SHADOWMAP_TYPE_PCF_SOFT");
        var d = "ENVMAP_TYPE_CUBE"
          , f = "ENVMAP_MODE_REFLECTION"
          , m = "ENVMAP_BLENDING_MULTIPLY";
        if (s.envMap) {
            switch (i.envMap.mapping) {
            case ue:
            case de:
                d = "ENVMAP_TYPE_CUBE";
                break;
            case ve:
            case ye:
                d = "ENVMAP_TYPE_CUBE_UV";
                break;
            case fe:
            case me:
                d = "ENVMAP_TYPE_EQUIREC";
                break;
            case ge:
                d = "ENVMAP_TYPE_SPHERE"
            }
            switch (i.envMap.mapping) {
            case de:
            case me:
                f = "ENVMAP_MODE_REFRACTION"
            }
            switch (i.combine) {
            case re:
                m = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case ie:
                m = "ENVMAP_BLENDING_MIX";
                break;
            case ne:
                m = "ENVMAP_BLENDING_ADD"
            }
        }
        var y, b, w, x, M, _ = e.gammaFactor > 0 ? e.gammaFactor : 1, S = a.isWebGL2 ? "" : function(e, t, r) {
            return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Zn).join("\n")
        }(i.extensions, s, t), T = function(e) {
            var t = [];
            for (var r in e) {
                var i = e[r];
                !1 !== i && t.push("#define " + r + " " + i)
            }
            return t.join("\n")
        }(l), E = c.createProgram();
        if (i.isRawShaderMaterial ? ((y = [T].filter(Zn).join("\n")).length > 0 && (y += "\n"),
        (b = [S, T].filter(Zn).join("\n")).length > 0 && (b += "\n")) : (y = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + n.name, T, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + s.maxBones, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + f : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals && !1 === s.flatShading ? "#define USE_MORPHNORMALS" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + u : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Zn).join("\n"),
        b = [S, "precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + n.name, T, s.alphaTest ? "#define ALPHATEST " + s.alphaTest + (s.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.matcap ? "#define USE_MATCAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + d : "", s.envMap ? "#define " + f : "", s.envMap ? "#define " + m : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.gradientMap ? "#define USE_GRADIENTMAP" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + u : "", s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", s.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", s.toneMapping !== se ? "#define TONE_MAPPING" : "", s.toneMapping !== se ? wr.tonemapping_pars_fragment : "", s.toneMapping !== se ? Yn("toneMapping", s.toneMapping) : "", s.dithering ? "#define DITHERING" : "", s.outputEncoding || s.mapEncoding || s.matcapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? wr.encodings_pars_fragment : "", s.mapEncoding ? Wn("mapTexelToLinear", s.mapEncoding) : "", s.matcapEncoding ? Wn("matcapTexelToLinear", s.matcapEncoding) : "", s.envMapEncoding ? Wn("envMapTexelToLinear", s.envMapEncoding) : "", s.emissiveMapEncoding ? Wn("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "", s.outputEncoding ? (w = "linearToOutputTexel",
        x = s.outputEncoding,
        M = Vn(x),
        "vec4 " + w + "( vec4 value ) { return LinearTo" + M[0] + M[1] + "; }") : "", s.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Zn).join("\n")),
        p = qn(p = Xn(p = Jn(p), s), s),
        h = qn(h = Xn(h = Jn(h), s), s),
        p = Kn(p),
        h = Kn(h),
        a.isWebGL2 && !i.isRawShaderMaterial) {
            var A = !1
              , P = /^\s*#version\s+300\s+es\s*\n/;
            i.isShaderMaterial && null !== p.match(P) && null !== h.match(P) && (A = !0,
            p = p.replace(P, ""),
            h = h.replace(P, "")),
            y = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y,
            b = ["#version 300 es\n", "#define varying in", A ? "" : "out highp vec4 pc_fragColor;", A ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b
        }
        var O, R, C = b + h, L = Gn(c, 35633, y + p, e.debug.checkShaderErrors), I = Gn(c, 35632, C, e.debug.checkShaderErrors);
        if (c.attachShader(E, L),
        c.attachShader(E, I),
        void 0 !== i.index0AttributeName ? c.bindAttribLocation(E, 0, i.index0AttributeName) : !0 === s.morphTargets && c.bindAttribLocation(E, 0, "position"),
        c.linkProgram(E),
        e.debug.checkShaderErrors) {
            var k = c.getProgramInfoLog(E).trim()
              , D = c.getShaderInfoLog(L).trim()
              , z = c.getShaderInfoLog(I).trim()
              , B = !0
              , N = !0;
            !1 === c.getProgramParameter(E, 35714) ? (B = !1,
            console.error("THREE.WebGLProgram: shader error: ", c.getError(), "35715", c.getProgramParameter(E, 35715), "gl.getProgramInfoLog", k, D, z)) : "" !== k ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", k) : "" !== D && "" !== z || (N = !1),
            N && (this.diagnostics = {
                runnable: B,
                material: i,
                programLog: k,
                vertexShader: {
                    log: D,
                    prefix: y
                },
                fragmentShader: {
                    log: z,
                    prefix: b
                }
            })
        }
        return c.deleteShader(L),
        c.deleteShader(I),
        this.getUniforms = function() {
            return void 0 === O && (O = new Un(c,E,o)),
            O
        }
        ,
        this.getAttributes = function() {
            return void 0 === R && (R = function(e, t) {
                for (var r = {}, i = e.getProgramParameter(t, 35721), n = 0; n < i; n++) {
                    var s = e.getActiveAttrib(t, n).name;
                    r[s] = e.getAttribLocation(t, s)
                }
                return r
            }(c, E)),
            R
        }
        ,
        this.destroy = function() {
            c.deleteProgram(E),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.name = n.name,
        this.id = Hn++,
        this.code = r,
        this.usedTimes = 1,
        this.program = E,
        this.vertexShader = L,
        this.fragmentShader = I,
        this
    }
    function $n(e, t, r, i) {
        var n = []
          , s = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function o(e, t) {
            var r;
            return e ? e.isTexture ? r = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            r = e.texture.encoding) : r = Rt,
            r === Rt && t && (r = Lt),
            r
        }
        this.getParameters = function(t, i, n, a, c, l, p) {
            var h = s[t.type]
              , u = p.isSkinnedMesh ? function(e) {
                var t = e.skeleton.bones;
                if (r.floatVertexTextures)
                    return 1024;
                var i = r.maxVertexUniforms
                  , n = Math.floor((i - 20) / 4)
                  , s = Math.min(n, t.length);
                return s < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + s + "."),
                0) : s
            }(p) : 0
              , d = r.precision;
            null !== t.precision && (d = r.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", d, "instead.");
            var f = e.getRenderTarget();
            return {
                shaderID: h,
                precision: d,
                supportsVertexTextures: r.vertexTextures,
                outputEncoding: o(f ? f.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: o(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: o(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: o(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (t.envMap.mapping === ve || t.envMap.mapping === ye),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: o(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: t.normalMapType === Ut,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                fog: !!a,
                useFog: t.fog,
                fogExp: a && a.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: r.logarithmicDepthBuffer,
                skinning: t.skinning && u > 0,
                maxBones: u,
                useVertexTexture: r.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: i.directional.length,
                numPointLights: i.point.length,
                numSpotLights: i.spot.length,
                numRectAreaLights: i.rectArea.length,
                numHemiLights: i.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: l,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && p.receiveShadow && n.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: t.side === w,
                flipSided: t.side === b,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }
        ,
        this.getProgramCode = function(t, r) {
            var i = [];
            if (r.shaderID ? i.push(r.shaderID) : (i.push(t.fragmentShader),
            i.push(t.vertexShader)),
            void 0 !== t.defines)
                for (var n in t.defines)
                    i.push(n),
                    i.push(t.defines[n]);
            for (var s = 0; s < a.length; s++)
                i.push(r[a[s]]);
            return i.push(t.onBeforeCompile.toString()),
            i.push(e.gammaOutput),
            i.push(e.gammaFactor),
            i.join()
        }
        ,
        this.acquireProgram = function(s, a, o, c) {
            for (var l, p = 0, h = n.length; p < h; p++) {
                var u = n[p];
                if (u.code === c) {
                    ++(l = u).usedTimes;
                    break
                }
            }
            return void 0 === l && (l = new Qn(e,t,c,s,a,o,r,i),
            n.push(l)),
            l
        }
        ,
        this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = n.indexOf(e);
                n[t] = n[n.length - 1],
                n.pop(),
                e.destroy()
            }
        }
        ,
        this.programs = n
    }
    function es() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var r = e.get(t);
                return void 0 === r && (r = {},
                e.set(t, r)),
                r
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, r, i) {
                e.get(t)[r] = i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function ts(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function rs(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function is() {
        var e = []
          , t = 0
          , r = []
          , i = []
          , n = {
            id: -1
        };
        function s(r, i, s, a, o, c) {
            var l = e[t];
            return void 0 === l ? (l = {
                id: r.id,
                object: r,
                geometry: i,
                material: s,
                program: s.program || n,
                groupOrder: a,
                renderOrder: r.renderOrder,
                z: o,
                group: c
            },
            e[t] = l) : (l.id = r.id,
            l.object = r,
            l.geometry = i,
            l.material = s,
            l.program = s.program || n,
            l.groupOrder = a,
            l.renderOrder = r.renderOrder,
            l.z = o,
            l.group = c),
            t++,
            l
        }
        return {
            opaque: r,
            transparent: i,
            init: function() {
                t = 0,
                r.length = 0,
                i.length = 0
            },
            push: function(e, t, n, a, o, c) {
                var l = s(e, t, n, a, o, c);
                (!0 === n.transparent ? i : r).push(l)
            },
            unshift: function(e, t, n, a, o, c) {
                var l = s(e, t, n, a, o, c);
                (!0 === n.transparent ? i : r).unshift(l)
            },
            sort: function() {
                r.length > 1 && r.sort(ts),
                i.length > 1 && i.sort(rs)
            }
        }
    }
    function ns() {
        var e = {};
        function t(r) {
            var i = r.target;
            i.removeEventListener("dispose", t),
            delete e[i.id]
        }
        return {
            get: function(r, i) {
                var n, s = e[r.id];
                return void 0 === s ? (n = new is,
                e[r.id] = {},
                e[r.id][i.id] = n,
                r.addEventListener("dispose", t)) : void 0 === (n = s[i.id]) && (n = new is,
                s[i.id] = n),
                n
            },
            dispose: function() {
                e = {}
            }
        }
    }
    function ss() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                var r;
                switch (t.type) {
                case "DirectionalLight":
                    r = {
                        direction: new Wt,
                        color: new Pr,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ht
                    };
                    break;
                case "SpotLight":
                    r = {
                        position: new Wt,
                        direction: new Wt,
                        color: new Pr,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ht
                    };
                    break;
                case "PointLight":
                    r = {
                        position: new Wt,
                        color: new Pr,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ht,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case "HemisphereLight":
                    r = {
                        direction: new Wt,
                        skyColor: new Pr,
                        groundColor: new Pr
                    };
                    break;
                case "RectAreaLight":
                    r = {
                        color: new Pr,
                        position: new Wt,
                        halfWidth: new Wt,
                        halfHeight: new Wt
                    }
                }
                return e[t.id] = r,
                r
            }
        }
    }
    var as = 0;
    function os() {
        for (var e = new ss, t = {
            id: as++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, r = 0; r < 9; r++)
            t.probe.push(new Wt);
        var i = new Wt
          , n = new br
          , s = new br;
        return {
            setup: function(r, a, o) {
                for (var c = 0, l = 0, p = 0, h = 0; h < 9; h++)
                    t.probe[h].set(0, 0, 0);
                for (var u = 0, d = 0, f = 0, m = 0, g = 0, v = o.matrixWorldInverse, y = (h = 0,
                r.length); h < y; h++) {
                    var b = r[h]
                      , w = b.color
                      , x = b.intensity
                      , M = b.distance
                      , _ = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
                    if (b.isAmbientLight)
                        c += w.r * x,
                        l += w.g * x,
                        p += w.b * x;
                    else if (b.isLightProbe)
                        for (var S = 0; S < 9; S++)
                            t.probe[S].addScaledVector(b.sh.coefficients[S], x);
                    else if (b.isDirectionalLight) {
                        if ((E = e.get(b)).color.copy(b.color).multiplyScalar(b.intensity),
                        E.direction.setFromMatrixPosition(b.matrixWorld),
                        i.setFromMatrixPosition(b.target.matrixWorld),
                        E.direction.sub(i),
                        E.direction.transformDirection(v),
                        E.shadow = b.castShadow,
                        b.castShadow) {
                            var T = b.shadow;
                            E.shadowBias = T.bias,
                            E.shadowRadius = T.radius,
                            E.shadowMapSize = T.mapSize
                        }
                        t.directionalShadowMap[u] = _,
                        t.directionalShadowMatrix[u] = b.shadow.matrix,
                        t.directional[u] = E,
                        u++
                    } else if (b.isSpotLight)
                        (E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        E.color.copy(w).multiplyScalar(x),
                        E.distance = M,
                        E.direction.setFromMatrixPosition(b.matrixWorld),
                        i.setFromMatrixPosition(b.target.matrixWorld),
                        E.direction.sub(i),
                        E.direction.transformDirection(v),
                        E.coneCos = Math.cos(b.angle),
                        E.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)),
                        E.decay = b.decay,
                        E.shadow = b.castShadow,
                        b.castShadow && (T = b.shadow,
                        E.shadowBias = T.bias,
                        E.shadowRadius = T.radius,
                        E.shadowMapSize = T.mapSize),
                        t.spotShadowMap[f] = _,
                        t.spotShadowMatrix[f] = b.shadow.matrix,
                        t.spot[f] = E,
                        f++;
                    else if (b.isRectAreaLight)
                        (E = e.get(b)).color.copy(w).multiplyScalar(x),
                        E.position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        s.identity(),
                        n.copy(b.matrixWorld),
                        n.premultiply(v),
                        s.extractRotation(n),
                        E.halfWidth.set(.5 * b.width, 0, 0),
                        E.halfHeight.set(0, .5 * b.height, 0),
                        E.halfWidth.applyMatrix4(s),
                        E.halfHeight.applyMatrix4(s),
                        t.rectArea[m] = E,
                        m++;
                    else if (b.isPointLight)
                        (E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        E.color.copy(b.color).multiplyScalar(b.intensity),
                        E.distance = b.distance,
                        E.decay = b.decay,
                        E.shadow = b.castShadow,
                        b.castShadow && (T = b.shadow,
                        E.shadowBias = T.bias,
                        E.shadowRadius = T.radius,
                        E.shadowMapSize = T.mapSize,
                        E.shadowCameraNear = T.camera.near,
                        E.shadowCameraFar = T.camera.far),
                        t.pointShadowMap[d] = _,
                        t.pointShadowMatrix[d] = b.shadow.matrix,
                        t.point[d] = E,
                        d++;
                    else if (b.isHemisphereLight) {
                        var E;
                        (E = e.get(b)).direction.setFromMatrixPosition(b.matrixWorld),
                        E.direction.transformDirection(v),
                        E.direction.normalize(),
                        E.skyColor.copy(b.color).multiplyScalar(x),
                        E.groundColor.copy(b.groundColor).multiplyScalar(x),
                        t.hemi[g] = E,
                        g++
                    }
                }
                t.ambient[0] = c,
                t.ambient[1] = l,
                t.ambient[2] = p,
                t.directional.length = u,
                t.spot.length = f,
                t.rectArea.length = m,
                t.point.length = d,
                t.hemi.length = g,
                t.hash.stateID = t.id,
                t.hash.directionalLength = u,
                t.hash.pointLength = d,
                t.hash.spotLength = f,
                t.hash.rectAreaLength = m,
                t.hash.hemiLength = g,
                t.hash.shadowsLength = a.length
            },
            state: t
        }
    }
    function cs() {
        var e = new os
          , t = []
          , r = [];
        return {
            init: function() {
                t.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: r,
                lights: e
            },
            setupLights: function(i) {
                e.setup(t, r, i)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                r.push(e)
            }
        }
    }
    function ls() {
        var e = {};
        function t(r) {
            var i = r.target;
            i.removeEventListener("dispose", t),
            delete e[i.id]
        }
        return {
            get: function(r, i) {
                var n;
                return void 0 === e[r.id] ? (n = new cs,
                e[r.id] = {},
                e[r.id][i.id] = n,
                r.addEventListener("dispose", t)) : void 0 === e[r.id][i.id] ? (n = new cs,
                e[r.id][i.id] = n) : n = e[r.id][i.id],
                n
            },
            dispose: function() {
                e = {}
            }
        }
    }
    function ps(e) {
        di.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = Nt,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function hs(e) {
        di.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Wt,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function us(e, t, r) {
        for (var i = new yr, n = new br, s = new Ht, a = new Ht(r,r), o = new Wt, c = new Wt, l = 1, p = 2, h = 1 + (l | p), u = new Array(h), d = new Array(h), f = {}, m = {
            0: b,
            1: y,
            2: w
        }, v = [new Wt(1,0,0), new Wt(-1,0,0), new Wt(0,0,1), new Wt(0,0,-1), new Wt(0,1,0), new Wt(0,-1,0)], x = [new Wt(0,1,0), new Wt(0,1,0), new Wt(0,1,0), new Wt(0,1,0), new Wt(0,0,1), new Wt(0,0,-1)], M = [new pr, new pr, new pr, new pr, new pr, new pr], _ = 0; _ !== h; ++_) {
            var S = 0 != (_ & l)
              , T = 0 != (_ & p)
              , A = new ps({
                depthPacking: jt,
                morphTargets: S,
                skinning: T
            });
            u[_] = A;
            var P = new hs({
                morphTargets: S,
                skinning: T
            });
            d[_] = P
        }
        var O = this;
        function R(t, r, i, n, s, a) {
            var o = t.geometry
              , c = null
              , h = u
              , g = t.customDepthMaterial;
            if (i && (h = d,
            g = t.customDistanceMaterial),
            g)
                c = g;
            else {
                var v = !1;
                r.morphTargets && (o && o.isBufferGeometry ? v = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (v = o.morphTargets && o.morphTargets.length > 0)),
                t.isSkinnedMesh && !1 === r.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                var y = t.isSkinnedMesh && r.skinning
                  , b = 0;
                v && (b |= l),
                y && (b |= p),
                c = h[b]
            }
            if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                var w = c.uuid
                  , x = r.uuid
                  , M = f[w];
                void 0 === M && (M = {},
                f[w] = M);
                var _ = M[x];
                void 0 === _ && (_ = c.clone(),
                M[x] = _),
                c = _
            }
            return c.visible = r.visible,
            c.wireframe = r.wireframe,
            c.side = null != r.shadowSide ? r.shadowSide : m[r.side],
            c.clipShadows = r.clipShadows,
            c.clippingPlanes = r.clippingPlanes,
            c.clipIntersection = r.clipIntersection,
            c.wireframeLinewidth = r.wireframeLinewidth,
            c.linewidth = r.linewidth,
            i && c.isMeshDistanceMaterial && (c.referencePosition.copy(n),
            c.nearDistance = s,
            c.farDistance = a),
            c
        }
        function C(r, n, s, a) {
            if (!1 !== r.visible) {
                if (r.layers.test(n.layers) && (r.isMesh || r.isLine || r.isPoints) && r.castShadow && (!r.frustumCulled || i.intersectsObject(r))) {
                    r.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, r.matrixWorld);
                    var o = t.update(r)
                      , l = r.material;
                    if (Array.isArray(l))
                        for (var p = o.groups, h = 0, u = p.length; h < u; h++) {
                            var d = p[h]
                              , f = l[d.materialIndex];
                            if (f && f.visible) {
                                var m = R(r, f, a, c, s.near, s.far);
                                e.renderBufferDirect(s, null, o, m, r, d)
                            }
                        }
                    else if (l.visible) {
                        m = R(r, l, a, c, s.near, s.far);
                        e.renderBufferDirect(s, null, o, m, r, null)
                    }
                }
                for (var g = r.children, v = 0, y = g.length; v < y; v++)
                    C(g[v], n, s, a)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = g,
        this.render = function(t, r, l) {
            if (!1 !== O.enabled && (!1 !== O.autoUpdate || !1 !== O.needsUpdate) && 0 !== t.length) {
                var p, h = e.getRenderTarget(), u = e.getActiveCubeFace(), d = e.getActiveMipMapLevel(), f = e.state;
                f.setBlending(E),
                f.buffers.color.setClear(1, 1, 1, 1),
                f.buffers.depth.setTest(!0),
                f.setScissorTest(!1);
                for (var m = 0, g = t.length; m < g; m++) {
                    var y = t[m]
                      , b = y.shadow
                      , w = y && y.isPointLight;
                    if (void 0 !== b) {
                        var _ = b.camera;
                        if (s.copy(b.mapSize),
                        s.min(a),
                        w) {
                            var S = s.x
                              , T = s.y;
                            M[0].set(2 * S, T, S, T),
                            M[1].set(0, T, S, T),
                            M[2].set(3 * S, T, S, T),
                            M[3].set(S, T, S, T),
                            M[4].set(3 * S, 0, S, T),
                            M[5].set(S, 0, S, T),
                            s.x *= 4,
                            s.y *= 2
                        }
                        if (null === b.map) {
                            var A = {
                                minFilter: Me,
                                magFilter: Me,
                                format: Ge
                            };
                            b.map = new hr(s.x,s.y,A),
                            b.map.texture.name = y.name + ".shadowMap",
                            _.updateProjectionMatrix()
                        }
                        b.isSpotLightShadow && b.update(y);
                        var P = b.map
                          , R = b.matrix;
                        c.setFromMatrixPosition(y.matrixWorld),
                        _.position.copy(c),
                        w ? (p = 6,
                        R.makeTranslation(-c.x, -c.y, -c.z)) : (p = 1,
                        o.setFromMatrixPosition(y.target.matrixWorld),
                        _.lookAt(o),
                        _.updateMatrixWorld(),
                        R.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        R.multiply(_.projectionMatrix),
                        R.multiply(_.matrixWorldInverse)),
                        e.setRenderTarget(P),
                        e.clear();
                        for (var L = 0; L < p; L++) {
                            if (w) {
                                o.copy(_.position),
                                o.add(v[L]),
                                _.up.copy(x[L]),
                                _.lookAt(o),
                                _.updateMatrixWorld();
                                var I = M[L];
                                f.viewport(I)
                            }
                            n.multiplyMatrices(_.projectionMatrix, _.matrixWorldInverse),
                            i.setFromMatrix(n),
                            C(r, l, _, w)
                        }
                    } else
                        console.warn("THREE.WebGLShadowMap:", y, "has no shadow.")
                }
                O.needsUpdate = !1,
                e.setRenderTarget(h, u, d)
            }
        }
    }
    function ds(e, t, r, i) {
        var n = new function() {
            var t = !1
              , r = new pr
              , i = null
              , n = new pr(0,0,0,0);
            return {
                setMask: function(r) {
                    i === r || t || (e.colorMask(r, r, r, r),
                    i = r)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, i, s, a, o) {
                    !0 === o && (t *= a,
                    i *= a,
                    s *= a),
                    r.set(t, i, s, a),
                    !1 === n.equals(r) && (e.clearColor(t, i, s, a),
                    n.copy(r))
                },
                reset: function() {
                    t = !1,
                    i = null,
                    n.set(-1, 0, 0, 0)
                }
            }
        }
          , s = new function() {
            var t = !1
              , r = null
              , i = null
              , n = null;
            return {
                setTest: function(e) {
                    e ? se(2929) : ae(2929)
                },
                setMask: function(i) {
                    r === i || t || (e.depthMask(i),
                    r = i)
                },
                setFunc: function(t) {
                    if (i !== t) {
                        if (t)
                            switch (t) {
                            case X:
                                e.depthFunc(512);
                                break;
                            case q:
                                e.depthFunc(519);
                                break;
                            case J:
                                e.depthFunc(513);
                                break;
                            case K:
                                e.depthFunc(515);
                                break;
                            case Q:
                                e.depthFunc(514);
                                break;
                            case $:
                                e.depthFunc(518);
                                break;
                            case ee:
                                e.depthFunc(516);
                                break;
                            case te:
                                e.depthFunc(517);
                                break;
                            default:
                                e.depthFunc(515)
                            }
                        else
                            e.depthFunc(515);
                        i = t
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    n !== t && (e.clearDepth(t),
                    n = t)
                },
                reset: function() {
                    t = !1,
                    r = null,
                    i = null,
                    n = null
                }
            }
        }
          , a = new function() {
            var t = !1
              , r = null
              , i = null
              , n = null
              , s = null
              , a = null
              , o = null
              , c = null
              , l = null;
            return {
                setTest: function(e) {
                    e ? se(2960) : ae(2960)
                },
                setMask: function(i) {
                    r === i || t || (e.stencilMask(i),
                    r = i)
                },
                setFunc: function(t, r, a) {
                    i === t && n === r && s === a || (e.stencilFunc(t, r, a),
                    i = t,
                    n = r,
                    s = a)
                },
                setOp: function(t, r, i) {
                    a === t && o === r && c === i || (e.stencilOp(t, r, i),
                    a = t,
                    o = r,
                    c = i)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    l !== t && (e.clearStencil(t),
                    l = t)
                },
                reset: function() {
                    t = !1,
                    r = null,
                    i = null,
                    n = null,
                    s = null,
                    a = null,
                    o = null,
                    c = null,
                    l = null
                }
            }
        }
          , o = e.getParameter(34921)
          , c = new Uint8Array(o)
          , u = new Uint8Array(o)
          , d = new Uint8Array(o)
          , f = {}
          , m = null
          , g = null
          , v = null
          , y = null
          , x = null
          , M = null
          , _ = null
          , S = null
          , T = null
          , I = null
          , k = !1
          , D = null
          , z = null
          , B = null
          , N = null
          , j = null
          , F = e.getParameter(35661)
          , U = !1
          , G = 0
          , H = e.getParameter(7938);
        -1 !== H.indexOf("WebGL") ? (G = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1]),
        U = G >= 1) : -1 !== H.indexOf("OpenGL ES") && (G = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1]),
        U = G >= 2);
        var V = null
          , W = {}
          , Y = new pr
          , Z = new pr;
        function re(t, r, i) {
            var n = new Uint8Array(4)
              , s = e.createTexture();
            e.bindTexture(t, s),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
            for (var a = 0; a < i; a++)
                e.texImage2D(r + a, 0, 6408, 1, 1, 0, 6408, 5121, n);
            return s
        }
        var ie = {};
        function ne(r, n) {
            (c[r] = 1,
            0 === u[r] && (e.enableVertexAttribArray(r),
            u[r] = 1),
            d[r] !== n) && ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, n),
            d[r] = n)
        }
        function se(t) {
            !0 !== f[t] && (e.enable(t),
            f[t] = !0)
        }
        function ae(t) {
            !1 !== f[t] && (e.disable(t),
            f[t] = !1)
        }
        function oe(t, i, n, s, a, o, c, l) {
            if (t !== E) {
                if (v || (se(3042),
                v = !0),
                t === C)
                    a = a || i,
                    o = o || n,
                    c = c || s,
                    i === x && a === S || (e.blendEquationSeparate(r.convert(i), r.convert(a)),
                    x = i,
                    S = a),
                    n === M && s === _ && o === T && c === I || (e.blendFuncSeparate(r.convert(n), r.convert(s), r.convert(o), r.convert(c)),
                    M = n,
                    _ = s,
                    T = o,
                    I = c),
                    y = t,
                    k = null;
                else if (t !== y || l !== k) {
                    if (x === L && S === L || (e.blendEquation(32774),
                    x = L,
                    S = L),
                    l)
                        switch (t) {
                        case A:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case P:
                            e.blendFunc(1, 1);
                            break;
                        case O:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case R:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    else
                        switch (t) {
                        case A:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case P:
                            e.blendFunc(770, 1);
                            break;
                        case O:
                            e.blendFunc(0, 769);
                            break;
                        case R:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    M = null,
                    _ = null,
                    T = null,
                    I = null,
                    y = t,
                    k = l
                }
            } else
                v && (ae(3042),
                v = !1)
        }
        function ce(t) {
            D !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
            D = t)
        }
        function le(t) {
            t !== l ? (se(2884),
            t !== z && (t === p ? e.cullFace(1029) : t === h ? e.cullFace(1028) : e.cullFace(1032))) : ae(2884),
            z = t
        }
        function pe(t, r, i) {
            t ? (se(32823),
            N === r && j === i || (e.polygonOffset(r, i),
            N = r,
            j = i)) : ae(32823)
        }
        function he(t) {
            void 0 === t && (t = 33984 + F - 1),
            V !== t && (e.activeTexture(t),
            V = t)
        }
        return ie[3553] = re(3553, 3553, 1),
        ie[34067] = re(34067, 34069, 6),
        n.setClear(0, 0, 0, 1),
        s.setClear(1),
        a.setClear(0),
        se(2929),
        s.setFunc(K),
        ce(!1),
        le(p),
        se(2884),
        oe(E),
        {
            buffers: {
                color: n,
                depth: s,
                stencil: a
            },
            initAttributes: function() {
                for (var e = 0, t = c.length; e < t; e++)
                    c[e] = 0
            },
            enableAttribute: function(e) {
                ne(e, 0)
            },
            enableAttributeAndDivisor: ne,
            disableUnusedAttributes: function() {
                for (var t = 0, r = u.length; t !== r; ++t)
                    u[t] !== c[t] && (e.disableVertexAttribArray(t),
                    u[t] = 0)
            },
            enable: se,
            disable: ae,
            getCompressedTextureFormats: function() {
                if (null === m && (m = [],
                t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var r = e.getParameter(34467), i = 0; i < r.length; i++)
                        m.push(r[i]);
                return m
            },
            useProgram: function(t) {
                return g !== t && (e.useProgram(t),
                g = t,
                !0)
            },
            setBlending: oe,
            setMaterial: function(e, t) {
                e.side === w ? ae(2884) : se(2884);
                var r = e.side === b;
                t && (r = !r),
                ce(r),
                e.blending === A && !1 === e.transparent ? oe(E) : oe(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                n.setMask(e.colorWrite),
                pe(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: ce,
            setCullFace: le,
            setLineWidth: function(t) {
                t !== B && (U && e.lineWidth(t),
                B = t)
            },
            setPolygonOffset: pe,
            setScissorTest: function(e) {
                e ? se(3089) : ae(3089)
            },
            activeTexture: he,
            bindTexture: function(t, r) {
                null === V && he();
                var i = W[V];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                W[V] = i),
                i.type === t && i.texture === r || (e.bindTexture(t, r || ie[t]),
                i.type = t,
                i.texture = r)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === Y.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                Y.copy(t))
            },
            viewport: function(t) {
                !1 === Z.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                Z.copy(t))
            },
            reset: function() {
                for (var t = 0; t < u.length; t++)
                    1 === u[t] && (e.disableVertexAttribArray(t),
                    u[t] = 0);
                f = {},
                m = null,
                V = null,
                W = {},
                g = null,
                y = null,
                D = null,
                z = null,
                n.reset(),
                s.reset(),
                a.reset()
            }
        }
    }
    function fs(e, t, r, i, n, s, a) {
        var o, c = {}, l = "undefined" != typeof OffscreenCanvas;
        function p(e, t) {
            return l ? new OffscreenCanvas(e,t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function h(e, t, r, i) {
            var n = 1;
            if ((e.width > i || e.height > i) && (n = i / Math.max(e.width, e.height)),
            n < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    var s = t ? Gt.floorPowerOfTwo : Math.floor
                      , a = s(n * e.width)
                      , c = s(n * e.height);
                    void 0 === o && (o = p(a, c));
                    var l = r ? p(a, c) : o;
                    return l.width = a,
                    l.height = c,
                    l.getContext("2d").drawImage(e, 0, 0, a, c),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + c + ")."),
                    l
                }
                return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                e
            }
            return e
        }
        function u(e) {
            return Gt.isPowerOfTwo(e.width) && Gt.isPowerOfTwo(e.height)
        }
        function d(e, t) {
            return e.generateMipmaps && t && e.minFilter !== Me && e.minFilter !== Te
        }
        function f(t, r, n, s) {
            e.generateMipmap(t),
            i.get(r).__maxMipLevel = Math.log(Math.max(n, s)) * Math.LOG2E
        }
        function m(e, r) {
            if (!n.isWebGL2)
                return e;
            var i = e;
            return 6403 === e && (5126 === r && (i = 33326),
            5131 === r && (i = 33325),
            5121 === r && (i = 33321)),
            6407 === e && (5126 === r && (i = 34837),
            5131 === r && (i = 34843),
            5121 === r && (i = 32849)),
            6408 === e && (5126 === r && (i = 34836),
            5131 === r && (i = 34842),
            5121 === r && (i = 32856)),
            33325 === i || 33326 === i || 34842 === i || 34836 === i ? t.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."),
            i
        }
        function g(e) {
            return e === Me || e === _e || e === Se ? 9728 : 9729
        }
        function v(t) {
            var r = t.target;
            r.removeEventListener("dispose", v),
            function(t) {
                var r = i.get(t);
                if (void 0 === r.__webglInit)
                    return;
                e.deleteTexture(r.__webglTexture),
                i.remove(t)
            }(r),
            r.isVideoTexture && delete c[r.id],
            a.memory.textures--
        }
        function y(t) {
            var r = t.target;
            r.removeEventListener("dispose", y),
            function(t) {
                var r = i.get(t)
                  , n = i.get(t.texture);
                if (!t)
                    return;
                void 0 !== n.__webglTexture && e.deleteTexture(n.__webglTexture);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLRenderTargetCube)
                    for (var s = 0; s < 6; s++)
                        e.deleteFramebuffer(r.__webglFramebuffer[s]),
                        r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[s]);
                else
                    e.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer);
                i.remove(t.texture),
                i.remove(t)
            }(r),
            a.memory.textures--
        }
        var b = 0;
        function w(e, t) {
            var n = i.get(e);
            if (e.isVideoTexture && function(e) {
                var t = e.id
                  , r = a.render.frame;
                c[t] !== r && (c[t] = r,
                e.update())
            }(e),
            e.version > 0 && n.__version !== e.version) {
                var s = e.image;
                if (void 0 === s)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== s.complete)
                        return void T(n, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            r.activeTexture(33984 + t),
            r.bindTexture(3553, n.__webglTexture)
        }
        function x(t, a) {
            var o = i.get(t);
            if (6 === t.image.length)
                if (t.version > 0 && o.__version !== t.version) {
                    S(o, t),
                    r.activeTexture(33984 + a),
                    r.bindTexture(34067, o.__webglTexture),
                    e.pixelStorei(37440, t.flipY);
                    for (var c = t && t.isCompressedTexture, l = t.image[0] && t.image[0].isDataTexture, p = [], g = 0; g < 6; g++)
                        p[g] = c || l ? l ? t.image[g].image : t.image[g] : h(t.image[g], !1, !0, n.maxCubemapSize);
                    var v = p[0]
                      , y = u(v) || n.isWebGL2
                      , b = s.convert(t.format)
                      , w = s.convert(t.type)
                      , x = m(b, w);
                    _(34067, t, y);
                    for (g = 0; g < 6; g++)
                        if (c)
                            for (var M, T = p[g].mipmaps, E = 0, A = T.length; E < A; E++)
                                M = T[E],
                                t.format !== Ge && t.format !== Ue ? r.getCompressedTextureFormats().indexOf(b) > -1 ? r.compressedTexImage2D(34069 + g, E, x, M.width, M.height, 0, M.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + g, E, x, M.width, M.height, 0, b, w, M.data);
                        else
                            l ? r.texImage2D(34069 + g, 0, x, p[g].width, p[g].height, 0, b, w, p[g].data) : r.texImage2D(34069 + g, 0, x, b, w, p[g]);
                    o.__maxMipLevel = c ? T.length - 1 : 0,
                    d(t, y) && f(34067, t, v.width, v.height),
                    o.__version = t.version,
                    t.onUpdate && t.onUpdate(t)
                } else
                    r.activeTexture(33984 + a),
                    r.bindTexture(34067, o.__webglTexture)
        }
        function M(e, t) {
            r.activeTexture(33984 + t),
            r.bindTexture(34067, i.get(e).__webglTexture)
        }
        function _(r, a, o) {
            var c;
            if (o ? (e.texParameteri(r, 10242, s.convert(a.wrapS)),
            e.texParameteri(r, 10243, s.convert(a.wrapT)),
            32879 !== r && 35866 !== r || e.texParameteri(r, 32882, s.convert(a.wrapR)),
            e.texParameteri(r, 10240, s.convert(a.magFilter)),
            e.texParameteri(r, 10241, s.convert(a.minFilter))) : (e.texParameteri(r, 10242, 33071),
            e.texParameteri(r, 10243, 33071),
            32879 !== r && 35866 !== r || e.texParameteri(r, 32882, 33071),
            a.wrapS === we && a.wrapT === we || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            e.texParameteri(r, 10240, g(a.magFilter)),
            e.texParameteri(r, 10241, g(a.minFilter)),
            a.minFilter !== Me && a.minFilter !== Te && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            c = t.get("EXT_texture_filter_anisotropic")) {
                if (a.type === ke && null === t.get("OES_texture_float_linear"))
                    return;
                if (a.type === De && null === (n.isWebGL2 || t.get("OES_texture_half_float_linear")))
                    return;
                (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(r, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, n.getMaxAnisotropy())),
                i.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function S(t, r) {
            void 0 === t.__webglInit && (t.__webglInit = !0,
            r.addEventListener("dispose", v),
            t.__webglTexture = e.createTexture(),
            a.memory.textures++)
        }
        function T(t, i, a) {
            var o = 3553;
            i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            S(t, i),
            r.activeTexture(33984 + a),
            r.bindTexture(o, t.__webglTexture),
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment);
            var c = function(e) {
                return !n.isWebGL2 && (e.wrapS !== we || e.wrapT !== we || e.minFilter !== Me && e.minFilter !== Te)
            }(i) && !1 === u(i.image)
              , l = h(i.image, c, !1, n.maxTextureSize)
              , p = u(l) || n.isWebGL2
              , g = s.convert(i.format)
              , v = s.convert(i.type)
              , y = m(g, v);
            _(o, i, p);
            var b, w = i.mipmaps;
            if (i.isDepthTexture) {
                if (y = 6402,
                i.type === ke) {
                    if (!n.isWebGL2)
                        throw new Error("Float Depth Texture only supported in WebGL2.0");
                    y = 36012
                } else
                    n.isWebGL2 && (y = 33189);
                i.format === Ye && 6402 === y && i.type !== Ce && i.type !== Ie && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = Ce,
                v = s.convert(i.type)),
                i.format === Ze && (y = 34041,
                i.type !== je && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = je,
                v = s.convert(i.type))),
                r.texImage2D(3553, 0, y, l.width, l.height, 0, g, v, null)
            } else if (i.isDataTexture)
                if (w.length > 0 && p) {
                    for (var x = 0, M = w.length; x < M; x++)
                        b = w[x],
                        r.texImage2D(3553, x, y, b.width, b.height, 0, g, v, b.data);
                    i.generateMipmaps = !1,
                    t.__maxMipLevel = w.length - 1
                } else
                    r.texImage2D(3553, 0, y, l.width, l.height, 0, g, v, l.data),
                    t.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (x = 0,
                M = w.length; x < M; x++)
                    b = w[x],
                    i.format !== Ge && i.format !== Ue ? r.getCompressedTextureFormats().indexOf(g) > -1 ? r.compressedTexImage2D(3553, x, y, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, x, y, b.width, b.height, 0, g, v, b.data);
                t.__maxMipLevel = w.length - 1
            } else if (i.isDataTexture2DArray)
                r.texImage3D(35866, 0, y, l.width, l.height, l.depth, 0, g, v, l.data),
                t.__maxMipLevel = 0;
            else if (i.isDataTexture3D)
                r.texImage3D(32879, 0, y, l.width, l.height, l.depth, 0, g, v, l.data),
                t.__maxMipLevel = 0;
            else if (w.length > 0 && p) {
                for (x = 0,
                M = w.length; x < M; x++)
                    b = w[x],
                    r.texImage2D(3553, x, y, g, v, b);
                i.generateMipmaps = !1,
                t.__maxMipLevel = w.length - 1
            } else
                r.texImage2D(3553, 0, y, g, v, l),
                t.__maxMipLevel = 0;
            d(i, p) && f(3553, i, l.width, l.height),
            t.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function E(t, n, a, o) {
            var c = s.convert(n.texture.format)
              , l = s.convert(n.texture.type)
              , p = m(c, l);
            r.texImage2D(o, 0, p, n.width, n.height, 0, c, l, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, a, o, i.get(n.texture).__webglTexture, 0),
            e.bindFramebuffer(36160, null)
        }
        function A(t, r, i) {
            if (e.bindRenderbuffer(36161, t),
            r.depthBuffer && !r.stencilBuffer) {
                if (i) {
                    var n = O(r);
                    e.renderbufferStorageMultisample(36161, n, 33189, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, 33189, r.width, r.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (r.depthBuffer && r.stencilBuffer) {
                if (i) {
                    n = O(r);
                    e.renderbufferStorageMultisample(36161, n, 34041, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, 34041, r.width, r.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                var a = m(s.convert(r.texture.format), s.convert(r.texture.type));
                if (i) {
                    n = O(r);
                    e.renderbufferStorageMultisample(36161, n, a, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, a, r.width, r.height)
            }
            e.bindRenderbuffer(36161, null)
        }
        function P(t) {
            var r = i.get(t)
              , n = !0 === t.isWebGLRenderTargetCube;
            if (t.depthTexture) {
                if (n)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(t, r) {
                    if (r && r.isWebGLRenderTargetCube)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t),
                    !r.depthTexture || !r.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                    r.depthTexture.image.height = r.height,
                    r.depthTexture.needsUpdate = !0),
                    w(r.depthTexture, 0);
                    var n = i.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === Ye)
                        e.framebufferTexture2D(36160, 36096, 3553, n, 0);
                    else {
                        if (r.depthTexture.format !== Ze)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, n, 0)
                    }
                }(r.__webglFramebuffer, t)
            } else if (n) {
                r.__webglDepthbuffer = [];
                for (var s = 0; s < 6; s++)
                    e.bindFramebuffer(36160, r.__webglFramebuffer[s]),
                    r.__webglDepthbuffer[s] = e.createRenderbuffer(),
                    A(r.__webglDepthbuffer[s], t)
            } else
                e.bindFramebuffer(36160, r.__webglFramebuffer),
                r.__webglDepthbuffer = e.createRenderbuffer(),
                A(r.__webglDepthbuffer, t);
            e.bindFramebuffer(36160, null)
        }
        function O(e) {
            return n.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(n.maxSamples, e.samples) : 0
        }
        var R = !1
          , C = !1;
        this.allocateTextureUnit = function() {
            var e = b;
            return e >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + n.maxTextures),
            b += 1,
            e
        }
        ,
        this.resetTextureUnits = function() {
            b = 0
        }
        ,
        this.setTexture2D = w,
        this.setTexture2DArray = function(e, t) {
            var n = i.get(e);
            e.version > 0 && n.__version !== e.version ? T(n, e, t) : (r.activeTexture(33984 + t),
            r.bindTexture(35866, n.__webglTexture))
        }
        ,
        this.setTexture3D = function(e, t) {
            var n = i.get(e);
            e.version > 0 && n.__version !== e.version ? T(n, e, t) : (r.activeTexture(33984 + t),
            r.bindTexture(32879, n.__webglTexture))
        }
        ,
        this.setTextureCube = x,
        this.setTextureCubeDynamic = M,
        this.setupRenderTarget = function(t) {
            var o = i.get(t)
              , c = i.get(t.texture);
            t.addEventListener("dispose", y),
            c.__webglTexture = e.createTexture(),
            a.memory.textures++;
            var l = !0 === t.isWebGLRenderTargetCube
              , p = !0 === t.isWebGLMultisampleRenderTarget
              , h = u(t) || n.isWebGL2;
            if (l) {
                o.__webglFramebuffer = [];
                for (var g = 0; g < 6; g++)
                    o.__webglFramebuffer[g] = e.createFramebuffer()
            } else if (o.__webglFramebuffer = e.createFramebuffer(),
            p)
                if (n.isWebGL2) {
                    o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                    o.__webglColorRenderbuffer = e.createRenderbuffer(),
                    e.bindRenderbuffer(36161, o.__webglColorRenderbuffer);
                    var v = m(s.convert(t.texture.format), s.convert(t.texture.type))
                      , b = O(t);
                    e.renderbufferStorageMultisample(36161, b, v, t.width, t.height),
                    e.bindFramebuffer(36160, o.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064, 36161, o.__webglColorRenderbuffer),
                    e.bindRenderbuffer(36161, null),
                    t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                    A(o.__webglDepthRenderbuffer, t, !0)),
                    e.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (l) {
                for (r.bindTexture(34067, c.__webglTexture),
                _(34067, t.texture, h),
                g = 0; g < 6; g++)
                    E(o.__webglFramebuffer[g], t, 36064, 34069 + g);
                d(t.texture, h) && f(34067, t.texture, t.width, t.height),
                r.bindTexture(34067, null)
            } else
                r.bindTexture(3553, c.__webglTexture),
                _(3553, t.texture, h),
                E(o.__webglFramebuffer, t, 36064, 3553),
                d(t.texture, h) && f(3553, t.texture, t.width, t.height),
                r.bindTexture(3553, null);
            t.depthBuffer && P(t)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var t = e.texture;
            if (d(t, u(e) || n.isWebGL2)) {
                var s = e.isWebGLRenderTargetCube ? 34067 : 3553
                  , a = i.get(t).__webglTexture;
                r.bindTexture(s, a),
                f(s, t, e.width, e.height),
                r.bindTexture(s, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (n.isWebGL2) {
                    var r = i.get(t);
                    e.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                    e.bindFramebuffer(36009, r.__webglFramebuffer);
                    var s = t.width
                      , a = t.height
                      , o = 16384;
                    t.depthBuffer && (o |= 256),
                    t.stencilBuffer && (o |= 1024),
                    e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === R && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            R = !0),
            e = e.texture),
            w(e, t)
        }
        ,
        this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            C = !0),
            e = e.texture),
            e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? x(e, t) : M(e, t)
        }
    }
    function ms(e, t, r) {
        return {
            convert: function(e) {
                var i;
                if (e === be)
                    return 10497;
                if (e === we)
                    return 33071;
                if (e === xe)
                    return 33648;
                if (e === Me)
                    return 9728;
                if (e === _e)
                    return 9984;
                if (e === Se)
                    return 9986;
                if (e === Te)
                    return 9729;
                if (e === Ee)
                    return 9985;
                if (e === Ae)
                    return 9987;
                if (e === Pe)
                    return 5121;
                if (e === ze)
                    return 32819;
                if (e === Be)
                    return 32820;
                if (e === Ne)
                    return 33635;
                if (e === Oe)
                    return 5120;
                if (e === Re)
                    return 5122;
                if (e === Ce)
                    return 5123;
                if (e === Le)
                    return 5124;
                if (e === Ie)
                    return 5125;
                if (e === ke)
                    return 5126;
                if (e === De) {
                    if (r.isWebGL2)
                        return 5131;
                    if (null !== (i = t.get("OES_texture_half_float")))
                        return i.HALF_FLOAT_OES
                }
                if (e === Fe)
                    return 6406;
                if (e === Ue)
                    return 6407;
                if (e === Ge)
                    return 6408;
                if (e === He)
                    return 6409;
                if (e === Ve)
                    return 6410;
                if (e === Ye)
                    return 6402;
                if (e === Ze)
                    return 34041;
                if (e === Xe)
                    return 6403;
                if (e === L)
                    return 32774;
                if (e === I)
                    return 32778;
                if (e === k)
                    return 32779;
                if (e === B)
                    return 0;
                if (e === N)
                    return 1;
                if (e === j)
                    return 768;
                if (e === F)
                    return 769;
                if (e === U)
                    return 770;
                if (e === G)
                    return 771;
                if (e === H)
                    return 772;
                if (e === V)
                    return 773;
                if (e === W)
                    return 774;
                if (e === Y)
                    return 775;
                if (e === Z)
                    return 776;
                if ((e === qe || e === Je || e === Ke || e === Qe) && null !== (i = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (e === qe)
                        return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === Je)
                        return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === Ke)
                        return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === Qe)
                        return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((e === $e || e === et || e === tt || e === rt) && null !== (i = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (e === $e)
                        return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === et)
                        return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === tt)
                        return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === rt)
                        return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === it && null !== (i = t.get("WEBGL_compressed_texture_etc1")))
                    return i.COMPRESSED_RGB_ETC1_WEBGL;
                if ((e === nt || e === st || e === at || e === ot || e === ct || e === lt || e === pt || e === ht || e === ut || e === dt || e === ft || e === mt || e === gt || e === vt) && null !== (i = t.get("WEBGL_compressed_texture_astc")))
                    return e;
                if (e === D || e === z) {
                    if (r.isWebGL2) {
                        if (e === D)
                            return 32775;
                        if (e === z)
                            return 32776
                    }
                    if (null !== (i = t.get("EXT_blend_minmax"))) {
                        if (e === D)
                            return i.MIN_EXT;
                        if (e === z)
                            return i.MAX_EXT
                    }
                }
                if (e === je) {
                    if (r.isWebGL2)
                        return 34042;
                    if (null !== (i = t.get("WEBGL_depth_texture")))
                        return i.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }
    function gs() {
        Hr.call(this),
        this.type = "Group"
    }
    function vs() {
        Hr.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new br,
        this.projectionMatrix = new br,
        this.projectionMatrixInverse = new br
    }
    function ys(e, t, r, i) {
        vs.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== e ? e : 50,
        this.zoom = 1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== i ? i : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== t ? t : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function bs(e) {
        ys.call(this),
        this.cameras = e || []
    }
    ps.prototype = Object.create(di.prototype),
    ps.prototype.constructor = ps,
    ps.prototype.isMeshDepthMaterial = !0,
    ps.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.depthPacking = e.depthPacking,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
    ,
    hs.prototype = Object.create(di.prototype),
    hs.prototype.constructor = hs,
    hs.prototype.isMeshDistanceMaterial = !0,
    hs.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
    ,
    gs.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: gs,
        isGroup: !0
    }),
    vs.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: vs,
        isCamera: !0,
        copy: function(e, t) {
            return Hr.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            e = new Wt),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            Hr.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    ys.prototype = Object.assign(Object.create(vs.prototype), {
        constructor: ys,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return vs.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Gt.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * Gt.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * Gt.RAD2DEG * Math.atan(Math.tan(.5 * Gt.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, r, i, n, s) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = i,
            this.view.width = n,
            this.view.height = s,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near
              , t = e * Math.tan(.5 * Gt.DEG2RAD * this.fov) / this.zoom
              , r = 2 * t
              , i = this.aspect * r
              , n = -.5 * i
              , s = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = s.fullWidth
                  , o = s.fullHeight;
                n += s.offsetX * i / a,
                t -= s.offsetY * r / o,
                i *= s.width / a,
                r *= s.height / o
            }
            var c = this.filmOffset;
            0 !== c && (n += e * c / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(n, n + i, t, t - r, e, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Hr.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }),
    bs.prototype = Object.assign(Object.create(ys.prototype), {
        constructor: bs,
        isArrayCamera: !0
    });
    var ws, xs, Ms, _s, Ss, Ts, Es = new Wt, As = new Wt;
    function Ps(e, t, r) {
        Es.setFromMatrixPosition(t.matrixWorld),
        As.setFromMatrixPosition(r.matrixWorld);
        var i = Es.distanceTo(As)
          , n = t.projectionMatrix.elements
          , s = r.projectionMatrix.elements
          , a = n[14] / (n[10] - 1)
          , o = n[14] / (n[10] + 1)
          , c = (n[9] + 1) / n[5]
          , l = (n[9] - 1) / n[5]
          , p = (n[8] - 1) / n[0]
          , h = (s[8] + 1) / s[0]
          , u = a * p
          , d = a * h
          , f = i / (-p + h)
          , m = f * -p;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
        e.translateX(m),
        e.translateZ(f),
        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
        e.matrixWorldInverse.getInverse(e.matrixWorld);
        var g = a + f
          , v = o + f
          , y = u - m
          , b = d + (i - m)
          , w = c * o / v * g
          , x = l * o / v * g;
        e.projectionMatrix.makePerspective(y, b, w, x, g, v)
    }
    function Os(e) {
        var t, r, i = this, n = null, s = null, a = null, o = [], c = new br, l = new br, p = 1, h = "local-floor";
        "undefined" != typeof window && "VRFrameData"in window && (s = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", x, !1));
        var u = new br
          , d = new Vt
          , f = new Wt
          , m = new ys;
        m.viewport = new pr,
        m.layers.enable(1);
        var g = new ys;
        g.viewport = new pr,
        g.layers.enable(2);
        var v = new bs([m, g]);
        function y() {
            return null !== n && !0 === n.isPresenting
        }
        v.layers.enable(1),
        v.layers.enable(2);
        var b, w = new Ht;
        function x() {
            if (y()) {
                var s = n.getEyeParameters("left");
                t = 2 * s.renderWidth * p,
                r = s.renderHeight * p,
                b = e.getPixelRatio(),
                e.getSize(w),
                e.setDrawingBufferSize(t, r, 1),
                m.viewport.set(0, 0, t / 2, r),
                g.viewport.set(t / 2, 0, t / 2, r),
                T.start()
            } else
                i.enabled && e.setDrawingBufferSize(w.width, w.height, b),
                T.stop()
        }
        var M = [];
        function _(e) {
            for (var t = navigator.getGamepads && navigator.getGamepads(), r = 0, i = 0, n = t.length; r < n; r++) {
                var s = t[r];
                if (s && ("Daydream Controller" === s.id || "Gear VR Controller" === s.id || "Oculus Go Controller" === s.id || "OpenVR Gamepad" === s.id || s.id.startsWith("Oculus Touch") || s.id.startsWith("Spatial Controller"))) {
                    if (i === e)
                        return s;
                    i++
                }
            }
        }
        function S(e, i) {
            null !== i && 4 === i.length && e.set(i[0] * t, i[1] * r, i[2] * t, i[3] * r)
        }
        this.enabled = !1,
        this.getController = function(e) {
            var t = o[e];
            return void 0 === t && ((t = new gs).matrixAutoUpdate = !1,
            t.visible = !1,
            o[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return n
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (n = e),
            T.setContext(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            p = e
        }
        ,
        this.setReferenceSpaceType = function(e) {
            h = e
        }
        ,
        this.setPoseTarget = function(e) {
            void 0 !== e && (a = e)
        }
        ,
        this.getCamera = function(e) {
            var t = "local-floor" === h ? 1.6 : 0;
            if (!1 === y())
                return e.position.set(0, t, 0),
                e.rotation.set(0, 0, 0),
                e;
            if (n.depthNear = e.near,
            n.depthFar = e.far,
            n.getFrameData(s),
            "local-floor" === h) {
                var r = n.stageParameters;
                r ? c.fromArray(r.sittingToStandingTransform) : c.makeTranslation(0, t, 0)
            }
            var i = s.pose
              , p = null !== a ? a : e;
            p.matrix.copy(c),
            p.matrix.decompose(p.position, p.quaternion, p.scale),
            null !== i.orientation && (d.fromArray(i.orientation),
            p.quaternion.multiply(d)),
            null !== i.position && (d.setFromRotationMatrix(c),
            f.fromArray(i.position),
            f.applyQuaternion(d),
            p.position.add(f)),
            p.updateMatrixWorld(),
            m.near = e.near,
            g.near = e.near,
            m.far = e.far,
            g.far = e.far,
            m.matrixWorldInverse.fromArray(s.leftViewMatrix),
            g.matrixWorldInverse.fromArray(s.rightViewMatrix),
            l.getInverse(c),
            "local-floor" === h && (m.matrixWorldInverse.multiply(l),
            g.matrixWorldInverse.multiply(l));
            var b = p.parent;
            null !== b && (u.getInverse(b.matrixWorld),
            m.matrixWorldInverse.multiply(u),
            g.matrixWorldInverse.multiply(u)),
            m.matrixWorld.getInverse(m.matrixWorldInverse),
            g.matrixWorld.getInverse(g.matrixWorldInverse),
            m.projectionMatrix.fromArray(s.leftProjectionMatrix),
            g.projectionMatrix.fromArray(s.rightProjectionMatrix),
            Ps(v, m, g);
            var w = n.getLayers();
            if (w.length) {
                var x = w[0];
                S(m.viewport, x.leftBounds),
                S(g.viewport, x.rightBounds)
            }
            return function() {
                for (var e = 0; e < o.length; e++) {
                    var t = o[e]
                      , r = _(e);
                    if (void 0 !== r && void 0 !== r.pose) {
                        if (null === r.pose)
                            return;
                        var i = r.pose;
                        !1 === i.hasPosition && t.position.set(.2, -.6, -.05),
                        null !== i.position && t.position.fromArray(i.position),
                        null !== i.orientation && t.quaternion.fromArray(i.orientation),
                        t.matrix.compose(t.position, t.quaternion, t.scale),
                        t.matrix.premultiply(c),
                        t.matrix.decompose(t.position, t.quaternion, t.scale),
                        t.matrixWorldNeedsUpdate = !0,
                        t.visible = !0;
                        var n = "Daydream Controller" === r.id ? 0 : 1;
                        void 0 === M[e] && (M[e] = !1),
                        M[e] !== r.buttons[n].pressed && (M[e] = r.buttons[n].pressed,
                        !0 === M[e] ? t.dispatchEvent({
                            type: "selectstart"
                        }) : (t.dispatchEvent({
                            type: "selectend"
                        }),
                        t.dispatchEvent({
                            type: "select"
                        })))
                    } else
                        t.visible = !1
                }
            }(),
            v
        }
        ,
        this.getStandingMatrix = function() {
            return c
        }
        ,
        this.isPresenting = y;
        var T = new Lr;
        this.setAnimationLoop = function(e) {
            T.setAnimationLoop(e),
            y() && T.start()
        }
        ,
        this.submitFrame = function() {
            y() && n.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", x)
        }
        ,
        this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
        }
    }
    function Rs(e) {
        var t = e.context
          , r = null
          , i = null
          , n = "local-floor"
          , s = null
          , a = []
          , o = [];
        function c() {
            return null !== r && null !== i
        }
        var l = new ys;
        l.layers.enable(1),
        l.viewport = new pr;
        var p = new ys;
        p.layers.enable(2),
        p.viewport = new pr;
        var h = new bs([l, p]);
        function u(e) {
            for (var t = 0; t < a.length; t++)
                o[t] === e.inputSource && a[t].dispatchEvent({
                    type: e.type
                })
        }
        function d() {
            e.setFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            v.stop()
        }
        function f(e) {
            i = e,
            v.setContext(r),
            v.start()
        }
        function m(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        h.layers.enable(1),
        h.layers.enable(2),
        this.enabled = !1,
        this.getController = function(e) {
            var t = a[e];
            return void 0 === t && ((t = new gs).matrixAutoUpdate = !1,
            t.visible = !1,
            a[e] = t),
            t
        }
        ,
        this.setFramebufferScaleFactor = function(e) {}
        ,
        this.setReferenceSpaceType = function(e) {
            n = e
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = function(e) {
            null !== (r = e) && (r.addEventListener("select", u),
            r.addEventListener("selectstart", u),
            r.addEventListener("selectend", u),
            r.addEventListener("end", d),
            r.updateRenderState({
                baseLayer: new XRWebGLLayer(r,t)
            }),
            r.requestReferenceSpace(n).then(f),
            o = r.inputSources,
            r.addEventListener("inputsourceschange", function() {
                o = r.inputSources,
                console.log(o);
                for (var e = 0; e < a.length; e++) {
                    a[e].userData.inputSource = o[e]
                }
            }))
        }
        ,
        this.getCamera = function(e) {
            if (c()) {
                var t = e.parent
                  , r = h.cameras;
                m(h, t);
                for (var i = 0; i < r.length; i++)
                    m(r[i], t);
                e.matrixWorld.copy(h.matrixWorld);
                for (var n = e.children, s = (i = 0,
                n.length); i < s; i++)
                    n[i].updateMatrixWorld(!0);
                return Ps(h, l, p),
                h
            }
            return e
        }
        ,
        this.isPresenting = c;
        var g = null;
        var v = new Lr;
        v.setAnimationLoop(function(t, n) {
            if (null !== (s = n.getViewerPose(i))) {
                var c = s.views
                  , l = r.renderState.baseLayer;
                e.setFramebuffer(l.framebuffer);
                for (var p = 0; p < c.length; p++) {
                    var u = c[p]
                      , d = l.getViewport(u)
                      , f = u.transform.inverse.matrix
                      , m = h.cameras[p];
                    m.matrix.fromArray(f).getInverse(m.matrix),
                    m.projectionMatrix.fromArray(u.projectionMatrix),
                    m.viewport.set(d.x, d.y, d.width, d.height),
                    0 === p && h.matrix.copy(m.matrix)
                }
            }
            for (p = 0; p < a.length; p++) {
                var v = a[p]
                  , y = o[p];
                if (y) {
                    var b = n.getPose(y.targetRaySpace, i);
                    if (null !== b) {
                        v.matrix.fromArray(b.transform.matrix),
                        v.matrix.decompose(v.position, v.rotation, v.scale),
                        v.visible = !0;
                        continue
                    }
                }
                v.visible = !1
            }
            g && g(t)
        }),
        this.setAnimationLoop = function(e) {
            g = e
        }
        ,
        this.dispose = function() {}
        ,
        this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),
            new br
        }
        ,
        this.getDevice = function() {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
        }
        ,
        this.setDevice = function() {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
        }
        ,
        this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
        }
        ,
        this.submitFrame = function() {}
    }
    function Cs(e) {
        console.log("THREE.WebGLRenderer", o);
        var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , r = void 0 !== e.context ? e.context : null
          , i = void 0 !== e.alpha && e.alpha
          , n = void 0 === e.depth || e.depth
          , s = void 0 === e.stencil || e.stencil
          , a = void 0 !== e.antialias && e.antialias
          , c = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
          , l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
          , p = void 0 !== e.powerPreference ? e.powerPreference : "default"
          , h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat
          , u = null
          , d = null;
        this.domElement = t,
        this.context = null,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.gammaInput = !1,
        this.gammaOutput = !1,
        this.physicallyCorrectLights = !1,
        this.toneMapping = ae,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var f, m, g, v, y, w, x, M, _, S, T, E, A, P, O, R, C, L, I = this, k = !1, D = null, z = 0, B = 0, N = null, j = null, F = -1, U = {
            geometry: null,
            program: null,
            wireframe: !1
        }, G = null, H = null, V = new pr, W = new pr, Y = null, Z = t.width, X = t.height, q = 1, J = new pr(0,0,Z,X), K = new pr(0,0,Z,X), Q = !1, $ = new yr, ee = new zi, te = !1, re = !1, ie = new br, ne = new Wt;
        function se() {
            return null === N ? q : 1
        }
        try {
            var oe = {
                alpha: i,
                depth: n,
                stencil: s,
                antialias: a,
                premultipliedAlpha: c,
                preserveDrawingBuffer: l,
                powerPreference: p,
                failIfMajorPerformanceCaveat: h,
                xrCompatible: !0
            };
            if (t.addEventListener("webglcontextlost", he, !1),
            t.addEventListener("webglcontextrestored", ue, !1),
            null === (f = r || t.getContext("webgl", oe) || t.getContext("experimental-webgl", oe)))
                throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message),
            e
        }
        function ce() {
            m = new Bi(f),
            (g = new Di(f,m,e)).isWebGL2 || (m.get("WEBGL_depth_texture"),
            m.get("OES_texture_float"),
            m.get("OES_texture_half_float"),
            m.get("OES_texture_half_float_linear"),
            m.get("OES_standard_derivatives"),
            m.get("OES_element_index_uint"),
            m.get("ANGLE_instanced_arrays")),
            m.get("OES_texture_float_linear"),
            L = new ms(f,m,g),
            (v = new ds(f,m,L,g)).scissor(W.copy(K).multiplyScalar(q)),
            v.viewport(V.copy(J).multiplyScalar(q)),
            y = new Fi(f),
            w = new es,
            x = new fs(f,m,v,w,g,L,y),
            M = new Ir(f),
            _ = new Ni(f,M,y),
            S = new Hi(_,y),
            O = new Gi(f),
            T = new $n(I,m,g,x),
            E = new ns,
            A = new ls,
            P = new Ii(I,v,S,c),
            R = new ki(f,m,y,g),
            C = new ji(f,m,y,g),
            y.programs = T.programs,
            I.context = f,
            I.capabilities = g,
            I.extensions = m,
            I.properties = w,
            I.renderLists = E,
            I.state = v,
            I.info = y
        }
        ce();
        var le = "undefined" != typeof navigator && "xr"in navigator && "supportsSession"in navigator.xr ? new Rs(I) : new Os(I);
        this.vr = le;
        var pe = new us(I,S,g.maxTextureSize);
        function he(e) {
            e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            k = !0
        }
        function ue() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            k = !1,
            ce()
        }
        function de(e) {
            var t = e.target;
            t.removeEventListener("dispose", de),
            function(e) {
                fe(e),
                w.remove(e)
            }(t)
        }
        function fe(e) {
            var t = w.get(e).program;
            e.program = void 0,
            void 0 !== t && T.releaseProgram(t)
        }
        this.shadowMap = pe,
        this.getContext = function() {
            return f
        }
        ,
        this.getContextAttributes = function() {
            return f.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var e = m.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var e = m.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return q
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (q = e,
            this.setSize(Z, X, !1))
        }
        ,
        this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            e = new Ht),
            e.set(Z, X)
        }
        ,
        this.setSize = function(e, r, i) {
            le.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = e,
            X = r,
            t.width = e * q,
            t.height = r * q,
            !1 !== i && (t.style.width = e + "px",
            t.style.height = r + "px"),
            this.setViewport(0, 0, e, r))
        }
        ,
        this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            e = new Ht),
            e.set(Z * q, X * q)
        }
        ,
        this.setDrawingBufferSize = function(e, r, i) {
            Z = e,
            X = r,
            q = i,
            t.width = e * i,
            t.height = r * i,
            this.setViewport(0, 0, e, r)
        }
        ,
        this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            e = new pr),
            e.copy(V)
        }
        ,
        this.getViewport = function(e) {
            return e.copy(J)
        }
        ,
        this.setViewport = function(e, t, r, i) {
            e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, r, i),
            v.viewport(V.copy(J).multiplyScalar(q))
        }
        ,
        this.getScissor = function(e) {
            return e.copy(K)
        }
        ,
        this.setScissor = function(e, t, r, i) {
            e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, r, i),
            v.scissor(W.copy(K).multiplyScalar(q))
        }
        ,
        this.getScissorTest = function() {
            return Q
        }
        ,
        this.setScissorTest = function(e) {
            v.setScissorTest(Q = e)
        }
        ,
        this.getClearColor = function() {
            return P.getClearColor()
        }
        ,
        this.setClearColor = function() {
            P.setClearColor.apply(P, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return P.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            P.setClearAlpha.apply(P, arguments)
        }
        ,
        this.clear = function(e, t, r) {
            var i = 0;
            (void 0 === e || e) && (i |= 16384),
            (void 0 === t || t) && (i |= 256),
            (void 0 === r || r) && (i |= 1024),
            f.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", he, !1),
            t.removeEventListener("webglcontextrestored", ue, !1),
            E.dispose(),
            A.dispose(),
            w.dispose(),
            S.dispose(),
            le.dispose(),
            ge.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            v.initAttributes();
            var r = w.get(e);
            e.hasPositions && !r.position && (r.position = f.createBuffer()),
            e.hasNormals && !r.normal && (r.normal = f.createBuffer()),
            e.hasUvs && !r.uv && (r.uv = f.createBuffer()),
            e.hasColors && !r.color && (r.color = f.createBuffer());
            var i = t.getAttributes();
            e.hasPositions && (f.bindBuffer(34962, r.position),
            f.bufferData(34962, e.positionArray, 35048),
            v.enableAttribute(i.position),
            f.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (f.bindBuffer(34962, r.normal),
            f.bufferData(34962, e.normalArray, 35048),
            v.enableAttribute(i.normal),
            f.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (f.bindBuffer(34962, r.uv),
            f.bufferData(34962, e.uvArray, 35048),
            v.enableAttribute(i.uv),
            f.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (f.bindBuffer(34962, r.color),
            f.bufferData(34962, e.colorArray, 35048),
            v.enableAttribute(i.color),
            f.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            v.disableUnusedAttributes(),
            f.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ,
        this.renderBufferDirect = function(e, t, r, i, n, s) {
            var a = n.isMesh && n.matrixWorld.determinant() < 0;
            v.setMaterial(i, a);
            var o = we(e, t, i, n)
              , c = !1;
            U.geometry === r.id && U.program === o.id && U.wireframe === (!0 === i.wireframe) || (U.geometry = r.id,
            U.program = o.id,
            U.wireframe = !0 === i.wireframe,
            c = !0),
            n.morphTargetInfluences && (O.update(n, r, i, o),
            c = !0);
            var l, p = r.index, h = r.attributes.position, u = 1;
            !0 === i.wireframe && (p = _.getWireframeAttribute(r),
            u = 2);
            var d = R;
            null !== p && (l = M.get(p),
            (d = C).setIndex(l)),
            c && (!function(e, t, r) {
                if (r && r.isInstancedBufferGeometry && !g.isWebGL2 && null === m.get("ANGLE_instanced_arrays"))
                    return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                v.initAttributes();
                var i = r.attributes
                  , n = t.getAttributes()
                  , s = e.defaultAttributeValues;
                for (var a in n) {
                    var o = n[a];
                    if (o >= 0) {
                        var c = i[a];
                        if (void 0 !== c) {
                            var l = c.normalized
                              , p = c.itemSize
                              , h = M.get(c);
                            if (void 0 === h)
                                continue;
                            var u = h.buffer
                              , d = h.type
                              , y = h.bytesPerElement;
                            if (c.isInterleavedBufferAttribute) {
                                var b = c.data
                                  , w = b.stride
                                  , x = c.offset;
                                b && b.isInstancedInterleavedBuffer ? (v.enableAttributeAndDivisor(o, b.meshPerAttribute),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = b.meshPerAttribute * b.count)) : v.enableAttribute(o),
                                f.bindBuffer(34962, u),
                                f.vertexAttribPointer(o, p, d, l, w * y, x * y)
                            } else
                                c.isInstancedBufferAttribute ? (v.enableAttributeAndDivisor(o, c.meshPerAttribute),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = c.meshPerAttribute * c.count)) : v.enableAttribute(o),
                                f.bindBuffer(34962, u),
                                f.vertexAttribPointer(o, p, d, l, 0, 0)
                        } else if (void 0 !== s) {
                            var _ = s[a];
                            if (void 0 !== _)
                                switch (_.length) {
                                case 2:
                                    f.vertexAttrib2fv(o, _);
                                    break;
                                case 3:
                                    f.vertexAttrib3fv(o, _);
                                    break;
                                case 4:
                                    f.vertexAttrib4fv(o, _);
                                    break;
                                default:
                                    f.vertexAttrib1fv(o, _)
                                }
                        }
                    }
                }
                v.disableUnusedAttributes()
            }(i, o, r),
            null !== p && f.bindBuffer(34963, l.buffer));
            var y = 1 / 0;
            null !== p ? y = p.count : void 0 !== h && (y = h.count);
            var b = r.drawRange.start * u
              , w = r.drawRange.count * u
              , x = null !== s ? s.start * u : 0
              , S = null !== s ? s.count * u : 1 / 0
              , T = Math.max(b, x)
              , E = Math.min(y, b + w, x + S) - 1
              , A = Math.max(0, E - T + 1);
            if (0 !== A) {
                if (n.isMesh)
                    if (!0 === i.wireframe)
                        v.setLineWidth(i.wireframeLinewidth * se()),
                        d.setMode(1);
                    else
                        switch (n.drawMode) {
                        case At:
                            d.setMode(4);
                            break;
                        case Pt:
                            d.setMode(5);
                            break;
                        case Ot:
                            d.setMode(6)
                        }
                else if (n.isLine) {
                    var P = i.linewidth;
                    void 0 === P && (P = 1),
                    v.setLineWidth(P * se()),
                    n.isLineSegments ? d.setMode(1) : n.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    n.isPoints ? d.setMode(0) : n.isSprite && d.setMode(4);
                r && r.isInstancedBufferGeometry ? r.maxInstancedCount > 0 && d.renderInstances(r, T, A) : d.render(T, A)
            }
        }
        ,
        this.compile = function(e, t) {
            (d = A.get(e, t)).init(),
            e.traverse(function(e) {
                e.isLight && (d.pushLight(e),
                e.castShadow && d.pushShadow(e))
            }),
            d.setupLights(t),
            e.traverse(function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var r = 0; r < t.material.length; r++)
                            be(t.material[r], e.fog, t);
                    else
                        be(t.material, e.fog, t)
            })
        }
        ;
        var me = null;
        var ge = new Lr;
        function ve(e, t, r, i) {
            for (var n = 0, s = e.length; n < s; n++) {
                var a = e[n]
                  , o = a.object
                  , c = a.geometry
                  , l = void 0 === i ? a.material : i
                  , p = a.group;
                if (r.isArrayCamera) {
                    H = r;
                    for (var h = r.cameras, u = 0, f = h.length; u < f; u++) {
                        var m = h[u];
                        o.layers.test(m.layers) && (v.viewport(V.copy(m.viewport)),
                        d.setupLights(m),
                        ye(o, t, m, c, l, p))
                    }
                } else
                    H = null,
                    ye(o, t, r, c, l, p)
            }
        }
        function ye(e, t, r, i, n, s) {
            if (e.onBeforeRender(I, t, r, i, n, s),
            d = A.get(t, H || r),
            e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject) {
                v.setMaterial(n);
                var a = we(r, t.fog, n, e);
                U.geometry = null,
                U.program = null,
                U.wireframe = !1,
                function(e, t) {
                    e.render(function(e) {
                        I.renderBufferImmediate(e, t)
                    })
                }(e, a)
            } else
                I.renderBufferDirect(r, t.fog, i, n, e, s);
            e.onAfterRender(I, t, r, i, n, s),
            d = A.get(t, H || r)
        }
        function be(e, t, r) {
            var i = w.get(e)
              , n = d.state.lights
              , s = d.state.shadowsArray
              , a = i.lightsHash
              , o = n.state.hash
              , c = T.getParameters(e, n.state, s, t, ee.numPlanes, ee.numIntersection, r)
              , l = T.getProgramCode(e, c)
              , p = i.program
              , h = !0;
            if (void 0 === p)
                e.addEventListener("dispose", de);
            else if (p.code !== l)
                fe(e);
            else if (a.stateID !== o.stateID || a.directionalLength !== o.directionalLength || a.pointLength !== o.pointLength || a.spotLength !== o.spotLength || a.rectAreaLength !== o.rectAreaLength || a.hemiLength !== o.hemiLength || a.shadowsLength !== o.shadowsLength)
                a.stateID = o.stateID,
                a.directionalLength = o.directionalLength,
                a.pointLength = o.pointLength,
                a.spotLength = o.spotLength,
                a.rectAreaLength = o.rectAreaLength,
                a.hemiLength = o.hemiLength,
                a.shadowsLength = o.shadowsLength,
                h = !1;
            else {
                if (void 0 !== c.shaderID)
                    return;
                h = !1
            }
            if (h) {
                if (c.shaderID) {
                    var u = Cr[c.shaderID];
                    i.shader = {
                        name: e.type,
                        uniforms: xr(u.uniforms),
                        vertexShader: u.vertexShader,
                        fragmentShader: u.fragmentShader
                    }
                } else
                    i.shader = {
                        name: e.type,
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                e.onBeforeCompile(i.shader, I),
                l = T.getProgramCode(e, c),
                p = T.acquireProgram(e, i.shader, c, l),
                i.program = p,
                e.program = p
            }
            var f = p.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var m = 0; m < I.maxMorphTargets; m++)
                    f["morphTarget" + m] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (m = 0; m < I.maxMorphNormals; m++)
                    f["morphNormal" + m] >= 0 && e.numSupportedMorphNormals++
            }
            var g = i.shader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = ee.numPlanes,
            i.numIntersection = ee.numIntersection,
            g.clippingPlanes = ee.uniform),
            i.fog = t,
            void 0 === a && (i.lightsHash = a = {}),
            a.stateID = o.stateID,
            a.directionalLength = o.directionalLength,
            a.pointLength = o.pointLength,
            a.spotLength = o.spotLength,
            a.rectAreaLength = o.rectAreaLength,
            a.hemiLength = o.hemiLength,
            a.shadowsLength = o.shadowsLength,
            e.lights && (g.ambientLightColor.value = n.state.ambient,
            g.lightProbe.value = n.state.probe,
            g.directionalLights.value = n.state.directional,
            g.spotLights.value = n.state.spot,
            g.rectAreaLights.value = n.state.rectArea,
            g.pointLights.value = n.state.point,
            g.hemisphereLights.value = n.state.hemi,
            g.directionalShadowMap.value = n.state.directionalShadowMap,
            g.directionalShadowMatrix.value = n.state.directionalShadowMatrix,
            g.spotShadowMap.value = n.state.spotShadowMap,
            g.spotShadowMatrix.value = n.state.spotShadowMatrix,
            g.pointShadowMap.value = n.state.pointShadowMap,
            g.pointShadowMatrix.value = n.state.pointShadowMatrix);
            var v = i.program.getUniforms()
              , y = Un.seqWithValue(v.seq, g);
            i.uniformsList = y
        }
        function we(e, t, r, i) {
            x.resetTextureUnits();
            var n = w.get(r)
              , s = d.state.lights
              , a = n.lightsHash
              , o = s.state.hash;
            if (te && (re || e !== G)) {
                var c = e === G && r.id === F;
                ee.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, e, n, c)
            }
            !1 === r.needsUpdate && (void 0 === n.program ? r.needsUpdate = !0 : r.fog && n.fog !== t ? r.needsUpdate = !0 : (!r.lights || a.stateID === o.stateID && a.directionalLength === o.directionalLength && a.pointLength === o.pointLength && a.spotLength === o.spotLength && a.rectAreaLength === o.rectAreaLength && a.hemiLength === o.hemiLength && a.shadowsLength === o.shadowsLength) && (void 0 === n.numClippingPlanes || n.numClippingPlanes === ee.numPlanes && n.numIntersection === ee.numIntersection) || (r.needsUpdate = !0)),
            r.needsUpdate && (be(r, t, i),
            r.needsUpdate = !1);
            var l, p, h = !1, u = !1, m = !1, y = n.program, M = y.getUniforms(), _ = n.shader.uniforms;
            if (v.useProgram(y.program) && (h = !0,
            u = !0,
            m = !0),
            r.id !== F && (F = r.id,
            u = !0),
            h || G !== e) {
                if (M.setValue(f, "projectionMatrix", e.projectionMatrix),
                g.logarithmicDepthBuffer && M.setValue(f, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                G !== e && (G = e,
                u = !0,
                m = !0),
                r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) {
                    var S = M.map.cameraPosition;
                    void 0 !== S && S.setValue(f, ne.setFromMatrixPosition(e.matrixWorld))
                }
                (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && M.setValue(f, "viewMatrix", e.matrixWorldInverse)
            }
            if (r.skinning) {
                M.setOptional(f, i, "bindMatrix"),
                M.setOptional(f, i, "bindMatrixInverse");
                var T = i.skeleton;
                if (T) {
                    var E = T.bones;
                    if (g.floatVertexTextures) {
                        if (void 0 === T.boneTexture) {
                            var A = Math.sqrt(4 * E.length);
                            A = Gt.ceilPowerOfTwo(A),
                            A = Math.max(A, 4);
                            var P = new Float32Array(A * A * 4);
                            P.set(T.boneMatrices);
                            var O = new fr(P,A,A,Ge,ke);
                            O.needsUpdate = !0,
                            T.boneMatrices = P,
                            T.boneTexture = O,
                            T.boneTextureSize = A
                        }
                        M.setValue(f, "boneTexture", T.boneTexture, x),
                        M.setValue(f, "boneTextureSize", T.boneTextureSize)
                    } else
                        M.setOptional(f, T, "boneMatrices")
                }
            }
            return u && (M.setValue(f, "toneMappingExposure", I.toneMappingExposure),
            M.setValue(f, "toneMappingWhitePoint", I.toneMappingWhitePoint),
            r.lights && (p = m,
            (l = _).ambientLightColor.needsUpdate = p,
            l.lightProbe.needsUpdate = p,
            l.directionalLights.needsUpdate = p,
            l.pointLights.needsUpdate = p,
            l.spotLights.needsUpdate = p,
            l.rectAreaLights.needsUpdate = p,
            l.hemisphereLights.needsUpdate = p),
            t && r.fog && function(e, t) {
                e.fogColor.value.copy(t.color),
                t.isFog ? (e.fogNear.value = t.near,
                e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }(_, t),
            r.isMeshBasicMaterial ? xe(_, r) : r.isMeshLambertMaterial ? (xe(_, r),
            function(e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
            }(_, r)) : r.isMeshPhongMaterial ? (xe(_, r),
            r.isMeshToonMaterial ? function(e, t) {
                Me(e, t),
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(_, r) : Me(_, r)) : r.isMeshStandardMaterial ? (xe(_, r),
            r.isMeshPhysicalMaterial ? function(e, t) {
                _e(e, t),
                e.reflectivity.value = t.reflectivity,
                e.clearCoat.value = t.clearCoat,
                e.clearCoatRoughness.value = t.clearCoatRoughness
            }(_, r) : _e(_, r)) : r.isMeshMatcapMaterial ? (xe(_, r),
            function(e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === b && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === b && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(_, r)) : r.isMeshDepthMaterial ? (xe(_, r),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(_, r)) : r.isMeshDistanceMaterial ? (xe(_, r),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition),
                e.nearDistance.value = t.nearDistance,
                e.farDistance.value = t.farDistance
            }(_, r)) : r.isMeshNormalMaterial ? (xe(_, r),
            function(e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === b && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === b && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(_, r)) : r.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity
            }(_, r),
            r.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(_, r)) : r.isPointsMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.size.value = t.size * q,
                e.scale.value = .5 * X,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(_, r) : r.isSpriteMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(_, r) : r.isShadowMaterial && (_.color.value.copy(r.color),
            _.opacity.value = r.opacity),
            void 0 !== _.ltc_1 && (_.ltc_1.value = Rr.LTC_1),
            void 0 !== _.ltc_2 && (_.ltc_2.value = Rr.LTC_2),
            Un.upload(f, n.uniformsList, _, x)),
            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Un.upload(f, n.uniformsList, _, x),
            r.uniformsNeedUpdate = !1),
            r.isSpriteMaterial && M.setValue(f, "center", i.center),
            M.setValue(f, "modelViewMatrix", i.modelViewMatrix),
            M.setValue(f, "normalMatrix", i.normalMatrix),
            M.setValue(f, "modelMatrix", i.matrixWorld),
            y
        }
        function xe(e, t) {
            var r;
            e.opacity.value = t.opacity,
            t.color && e.diffuse.value.copy(t.color),
            t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
            t.map && (e.map.value = t.map),
            t.alphaMap && (e.alphaMap.value = t.alphaMap),
            t.specularMap && (e.specularMap.value = t.specularMap),
            t.envMap && (e.envMap.value = t.envMap,
            e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1,
            e.reflectivity.value = t.reflectivity,
            e.refractionRatio.value = t.refractionRatio,
            e.maxMipLevel.value = w.get(t.envMap).__maxMipLevel),
            t.lightMap && (e.lightMap.value = t.lightMap,
            e.lightMapIntensity.value = t.lightMapIntensity),
            t.aoMap && (e.aoMap.value = t.aoMap,
            e.aoMapIntensity.value = t.aoMapIntensity),
            t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap && (r = t.emissiveMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix))
        }
        function Me(e, t) {
            e.specular.value.copy(t.specular),
            e.shininess.value = Math.max(t.shininess, 1e-4),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === b && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === b && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias)
        }
        function _e(e, t) {
            e.roughness.value = t.roughness,
            e.metalness.value = t.metalness,
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === b && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === b && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias),
            t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        ge.setAnimationLoop(function(e) {
            le.isPresenting() || me && me(e)
        }),
        "undefined" != typeof window && ge.setContext(window),
        this.setAnimationLoop = function(e) {
            me = e,
            le.setAnimationLoop(e),
            ge.start()
        }
        ,
        this.render = function(e, t) {
            var r, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
            r = arguments[2]),
            void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
            i = arguments[3]),
            t && t.isCamera) {
                if (!k) {
                    U.geometry = null,
                    U.program = null,
                    U.wireframe = !1,
                    F = -1,
                    G = null,
                    !0 === e.autoUpdate && e.updateMatrixWorld(),
                    null === t.parent && t.updateMatrixWorld(),
                    le.enabled && (t = le.getCamera(t)),
                    (d = A.get(e, t)).init(),
                    e.onBeforeRender(I, e, t, r || N),
                    ie.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    $.setFromMatrix(ie),
                    re = this.localClippingEnabled,
                    te = ee.init(this.clippingPlanes, re, t),
                    (u = E.get(e, t)).init(),
                    function e(t, r, i, n) {
                        if (!1 === t.visible)
                            return;
                        var s = t.layers.test(r.layers);
                        if (s)
                            if (t.isGroup)
                                i = t.renderOrder;
                            else if (t.isLight)
                                d.pushLight(t),
                                t.castShadow && d.pushShadow(t);
                            else if (t.isSprite) {
                                if (!t.frustumCulled || $.intersectsSprite(t)) {
                                    n && ne.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ie);
                                    var a = S.update(t)
                                      , o = t.material;
                                    o.visible && u.push(t, a, o, i, ne.z, null)
                                }
                            } else if (t.isImmediateRenderObject)
                                n && ne.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ie),
                                u.push(t, null, t.material, i, ne.z, null);
                            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(),
                            !t.frustumCulled || $.intersectsObject(t))) {
                                n && ne.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ie);
                                var a = S.update(t)
                                  , o = t.material;
                                if (Array.isArray(o))
                                    for (var c = a.groups, l = 0, p = c.length; l < p; l++) {
                                        var h = c[l]
                                          , f = o[h.materialIndex];
                                        f && f.visible && u.push(t, a, f, i, ne.z, h)
                                    }
                                else
                                    o.visible && u.push(t, a, o, i, ne.z, null)
                            }
                        var m = t.children;
                        for (var l = 0, p = m.length; l < p; l++)
                            e(m[l], r, i, n)
                    }(e, t, 0, I.sortObjects),
                    !0 === I.sortObjects && u.sort(),
                    te && ee.beginShadows();
                    var n = d.state.shadowsArray;
                    pe.render(n, e, t),
                    d.setupLights(t),
                    te && ee.endShadows(),
                    this.info.autoReset && this.info.reset(),
                    void 0 !== r && this.setRenderTarget(r),
                    P.render(u, e, t, i);
                    var s = u.opaque
                      , a = u.transparent;
                    if (e.overrideMaterial) {
                        var o = e.overrideMaterial;
                        s.length && ve(s, e, t, o),
                        a.length && ve(a, e, t, o)
                    } else
                        s.length && ve(s, e, t),
                        a.length && ve(a, e, t);
                    e.onAfterRender(I, e, t),
                    null !== N && (x.updateRenderTargetMipmap(N),
                    x.updateMultisampleRenderTarget(N)),
                    v.buffers.depth.setTest(!0),
                    v.buffers.depth.setMask(!0),
                    v.buffers.color.setMask(!0),
                    v.setPolygonOffset(!1),
                    le.enabled && le.submitFrame(),
                    u = null,
                    d = null
                }
            } else
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.setFramebuffer = function(e) {
            D !== e && f.bindFramebuffer(36160, e),
            D = e
        }
        ,
        this.getActiveCubeFace = function() {
            return z
        }
        ,
        this.getActiveMipMapLevel = function() {
            return B
        }
        ,
        this.getRenderTarget = function() {
            return N
        }
        ,
        this.setRenderTarget = function(e, t, r) {
            N = e,
            z = t,
            B = r,
            e && void 0 === w.get(e).__webglFramebuffer && x.setupRenderTarget(e);
            var i = D
              , n = !1;
            if (e) {
                var s = w.get(e).__webglFramebuffer;
                e.isWebGLRenderTargetCube ? (i = s[t || 0],
                n = !0) : i = e.isWebGLMultisampleRenderTarget ? w.get(e).__webglMultisampledFramebuffer : s,
                V.copy(e.viewport),
                W.copy(e.scissor),
                Y = e.scissorTest
            } else
                V.copy(J).multiplyScalar(q),
                W.copy(K).multiplyScalar(q),
                Y = Q;
            if (j !== i && (f.bindFramebuffer(36160, i),
            j = i),
            v.viewport(V),
            v.scissor(W),
            v.setScissorTest(Y),
            n) {
                var a = w.get(e.texture);
                f.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, r || 0)
            }
        }
        ,
        this.readRenderTargetPixels = function(e, t, r, i, n, s, a) {
            if (e && e.isWebGLRenderTarget) {
                var o = w.get(e).__webglFramebuffer;
                if (e.isWebGLRenderTargetCube && void 0 !== a && (o = o[a]),
                o) {
                    var c = !1;
                    o !== j && (f.bindFramebuffer(36160, o),
                    c = !0);
                    try {
                        var l = e.texture
                          , p = l.format
                          , h = l.type;
                        if (p !== Ge && L.convert(p) !== f.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(h === Pe || L.convert(h) === f.getParameter(35738) || h === ke && (g.isWebGL2 || m.get("OES_texture_float") || m.get("WEBGL_color_buffer_float")) || h === De && (g.isWebGL2 ? m.get("EXT_color_buffer_float") : m.get("EXT_color_buffer_half_float"))))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === f.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && r >= 0 && r <= e.height - n && f.readPixels(t, r, i, n, L.convert(p), L.convert(h), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        c && f.bindFramebuffer(36160, j)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(e, t, r) {
            var i = t.image.width
              , n = t.image.height
              , s = L.convert(t.format);
            x.setTexture2D(t, 0),
            f.copyTexImage2D(3553, r || 0, s, e.x, e.y, i, n, 0)
        }
        ,
        this.copyTextureToTexture = function(e, t, r, i) {
            var n = t.image.width
              , s = t.image.height
              , a = L.convert(r.format)
              , o = L.convert(r.type);
            x.setTexture2D(r, 0),
            t.isDataTexture ? f.texSubImage2D(3553, i || 0, e.x, e.y, n, s, a, o, t.image.data) : f.texSubImage2D(3553, i || 0, e.x, e.y, a, o, t.image)
        }
    }
    function Ls(e, t) {
        this.name = "",
        this.color = new Pr(e),
        this.density = void 0 !== t ? t : 25e-5
    }
    function Is(e, t, r) {
        this.name = "",
        this.color = new Pr(e),
        this.near = void 0 !== t ? t : 1,
        this.far = void 0 !== r ? r : 1e3
    }
    function ks() {
        Hr.call(this),
        this.type = "Scene",
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0
    }
    function Ds(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function zs(e, t, r, i) {
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = !0 === i
    }
    function Bs(e) {
        di.call(this),
        this.type = "SpriteMaterial",
        this.color = new Pr(16777215),
        this.map = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.transparent = !0,
        this.setValues(e)
    }
    function Ns(e) {
        if (Hr.call(this),
        this.type = "Sprite",
        void 0 === ws) {
            ws = new oi;
            var t = new Ds(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            ws.setIndex([0, 1, 2, 0, 2, 3]),
            ws.addAttribute("position", new zs(t,3,0,!1)),
            ws.addAttribute("uv", new zs(t,2,3,!1))
        }
        this.geometry = ws,
        this.material = void 0 !== e ? e : new Bs,
        this.center = new Ht(.5,.5)
    }
    function js() {
        Hr.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function Fs(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        Li.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new br,
        this.bindMatrixInverse = new br
    }
    function Us(e, t) {
        if (e = e || [],
        this.bones = e.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === t)
            this.calculateInverses();
        else if (this.bones.length === t.length)
            this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [];
            for (var r = 0, i = this.bones.length; r < i; r++)
                this.boneInverses.push(new br)
        }
    }
    function Gs() {
        Hr.call(this),
        this.type = "Bone"
    }
    function Hs(e) {
        di.call(this),
        this.type = "LineBasicMaterial",
        this.color = new Pr(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.lights = !1,
        this.setValues(e)
    }
    function Vs(e, t, r) {
        1 === r && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
        Hr.call(this),
        this.type = "Line",
        this.geometry = void 0 !== e ? e : new oi,
        this.material = void 0 !== t ? t : new Hs({
            color: 16777215 * Math.random()
        })
    }
    function Ws(e, t) {
        Vs.call(this, e, t),
        this.type = "LineSegments"
    }
    function Ys(e, t) {
        Vs.call(this, e, t),
        this.type = "LineLoop"
    }
    function Zs(e) {
        di.call(this),
        this.type = "PointsMaterial",
        this.color = new Pr(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Xs(e, t) {
        Hr.call(this),
        this.type = "Points",
        this.geometry = void 0 !== e ? e : new oi,
        this.material = void 0 !== t ? t : new Zs({
            color: 16777215 * Math.random()
        })
    }
    function qs(e, t, r, i, n, s, a, o, c) {
        lr.call(this, e, t, r, i, n, s, a, o, c),
        this.format = void 0 !== a ? a : Ue,
        this.minFilter = void 0 !== s ? s : Te,
        this.magFilter = void 0 !== n ? n : Te,
        this.generateMipmaps = !1
    }
    function Js(e, t, r, i, n, s, a, o, c, l, p, h) {
        lr.call(this, null, s, a, o, c, l, i, n, p, h),
        this.image = {
            width: t,
            height: r
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Ks(e, t, r, i, n, s, a, o, c) {
        lr.call(this, e, t, r, i, n, s, a, o, c),
        this.needsUpdate = !0
    }
    function Qs(e, t, r, i, n, s, a, o, c, l) {
        if ((l = void 0 !== l ? l : Ye) !== Ye && l !== Ze)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === r && l === Ye && (r = Ce),
        void 0 === r && l === Ze && (r = je),
        lr.call(this, null, i, n, s, a, o, l, r, c),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== a ? a : Me,
        this.minFilter = void 0 !== o ? o : Me,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function $s(e) {
        oi.call(this),
        this.type = "WireframeGeometry";
        var t, r, i, n, s, a, o, c, l, p, h = [], u = [0, 0], d = {}, f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0,
            i = m.length; t < i; t++) {
                var g = m[t];
                for (r = 0; r < 3; r++)
                    o = g[f[r]],
                    c = g[f[(r + 1) % 3]],
                    u[0] = Math.min(o, c),
                    u[1] = Math.max(o, c),
                    void 0 === d[l = u[0] + "," + u[1]] && (d[l] = {
                        index1: u[0],
                        index2: u[1]
                    })
            }
            for (l in d)
                a = d[l],
                p = e.vertices[a.index1],
                h.push(p.x, p.y, p.z),
                p = e.vertices[a.index2],
                h.push(p.x, p.y, p.z)
        } else if (e && e.isBufferGeometry) {
            var v, y, b, w, x, M, _;
            if (p = new Wt,
            null !== e.index) {
                for (v = e.attributes.position,
                y = e.index,
                0 === (b = e.groups).length && (b = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                n = 0,
                s = b.length; n < s; ++n)
                    for (t = x = (w = b[n]).start,
                    i = x + w.count; t < i; t += 3)
                        for (r = 0; r < 3; r++)
                            o = y.getX(t + r),
                            c = y.getX(t + (r + 1) % 3),
                            u[0] = Math.min(o, c),
                            u[1] = Math.max(o, c),
                            void 0 === d[l = u[0] + "," + u[1]] && (d[l] = {
                                index1: u[0],
                                index2: u[1]
                            });
                for (l in d)
                    a = d[l],
                    p.fromBufferAttribute(v, a.index1),
                    h.push(p.x, p.y, p.z),
                    p.fromBufferAttribute(v, a.index2),
                    h.push(p.x, p.y, p.z)
            } else
                for (t = 0,
                i = (v = e.attributes.position).count / 3; t < i; t++)
                    for (r = 0; r < 3; r++)
                        M = 3 * t + r,
                        p.fromBufferAttribute(v, M),
                        h.push(p.x, p.y, p.z),
                        _ = 3 * t + (r + 1) % 3,
                        p.fromBufferAttribute(v, _),
                        h.push(p.x, p.y, p.z)
        }
        this.addAttribute("position", new ri(h,3))
    }
    function ea(e, t, r) {
        Zr.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: r
        },
        this.fromBufferGeometry(new ta(e,t,r)),
        this.mergeVertices()
    }
    function ta(e, t, r) {
        oi.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: r
        };
        var i, n, s = [], a = [], o = [], c = [], l = new Wt, p = new Wt, h = new Wt, u = new Wt, d = new Wt;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var f = t + 1;
        for (i = 0; i <= r; i++) {
            var m = i / r;
            for (n = 0; n <= t; n++) {
                var g = n / t;
                e(g, m, p),
                a.push(p.x, p.y, p.z),
                g - 1e-5 >= 0 ? (e(g - 1e-5, m, h),
                u.subVectors(p, h)) : (e(g + 1e-5, m, h),
                u.subVectors(h, p)),
                m - 1e-5 >= 0 ? (e(g, m - 1e-5, h),
                d.subVectors(p, h)) : (e(g, m + 1e-5, h),
                d.subVectors(h, p)),
                l.crossVectors(u, d).normalize(),
                o.push(l.x, l.y, l.z),
                c.push(g, m)
            }
        }
        for (i = 0; i < r; i++)
            for (n = 0; n < t; n++) {
                var v = i * f + n
                  , y = i * f + n + 1
                  , b = (i + 1) * f + n + 1
                  , w = (i + 1) * f + n;
                s.push(v, y, w),
                s.push(y, b, w)
            }
        this.setIndex(s),
        this.addAttribute("position", new ri(a,3)),
        this.addAttribute("normal", new ri(o,3)),
        this.addAttribute("uv", new ri(c,2))
    }
    function ra(e, t, r, i) {
        Zr.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: i
        },
        this.fromBufferGeometry(new ia(e,t,r,i)),
        this.mergeVertices()
    }
    function ia(e, t, r, i) {
        oi.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: i
        },
        r = r || 1;
        var n = []
          , s = [];
        function a(e, t, r, i) {
            var n, s, a = Math.pow(2, i), c = [];
            for (n = 0; n <= a; n++) {
                c[n] = [];
                var l = e.clone().lerp(r, n / a)
                  , p = t.clone().lerp(r, n / a)
                  , h = a - n;
                for (s = 0; s <= h; s++)
                    c[n][s] = 0 === s && n === a ? l : l.clone().lerp(p, s / h)
            }
            for (n = 0; n < a; n++)
                for (s = 0; s < 2 * (a - n) - 1; s++) {
                    var u = Math.floor(s / 2);
                    s % 2 == 0 ? (o(c[n][u + 1]),
                    o(c[n + 1][u]),
                    o(c[n][u])) : (o(c[n][u + 1]),
                    o(c[n + 1][u + 1]),
                    o(c[n + 1][u]))
                }
        }
        function o(e) {
            n.push(e.x, e.y, e.z)
        }
        function c(t, r) {
            var i = 3 * t;
            r.x = e[i + 0],
            r.y = e[i + 1],
            r.z = e[i + 2]
        }
        function l(e, t, r, i) {
            i < 0 && 1 === e.x && (s[t] = e.x - 1),
            0 === r.x && 0 === r.z && (s[t] = i / 2 / Math.PI + .5)
        }
        function p(e) {
            return Math.atan2(e.z, -e.x)
        }
        !function(e) {
            for (var r = new Wt, i = new Wt, n = new Wt, s = 0; s < t.length; s += 3)
                c(t[s + 0], r),
                c(t[s + 1], i),
                c(t[s + 2], n),
                a(r, i, n, e)
        }(i = i || 0),
        function(e) {
            for (var t = new Wt, r = 0; r < n.length; r += 3)
                t.x = n[r + 0],
                t.y = n[r + 1],
                t.z = n[r + 2],
                t.normalize().multiplyScalar(e),
                n[r + 0] = t.x,
                n[r + 1] = t.y,
                n[r + 2] = t.z
        }(r),
        function() {
            for (var e = new Wt, t = 0; t < n.length; t += 3) {
                e.x = n[t + 0],
                e.y = n[t + 1],
                e.z = n[t + 2];
                var r = p(e) / 2 / Math.PI + .5
                  , i = (a = e,
                Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                s.push(r, 1 - i)
            }
            var a;
            (function() {
                for (var e = new Wt, t = new Wt, r = new Wt, i = new Wt, a = new Ht, o = new Ht, c = new Ht, h = 0, u = 0; h < n.length; h += 9,
                u += 6) {
                    e.set(n[h + 0], n[h + 1], n[h + 2]),
                    t.set(n[h + 3], n[h + 4], n[h + 5]),
                    r.set(n[h + 6], n[h + 7], n[h + 8]),
                    a.set(s[u + 0], s[u + 1]),
                    o.set(s[u + 2], s[u + 3]),
                    c.set(s[u + 4], s[u + 5]),
                    i.copy(e).add(t).add(r).divideScalar(3);
                    var d = p(i);
                    l(a, u + 0, e, d),
                    l(o, u + 2, t, d),
                    l(c, u + 4, r, d)
                }
            }
            )(),
            function() {
                for (var e = 0; e < s.length; e += 6) {
                    var t = s[e + 0]
                      , r = s[e + 2]
                      , i = s[e + 4]
                      , n = Math.max(t, r, i)
                      , a = Math.min(t, r, i);
                    n > .9 && a < .1 && (t < .2 && (s[e + 0] += 1),
                    r < .2 && (s[e + 2] += 1),
                    i < .2 && (s[e + 4] += 1))
                }
            }()
        }(),
        this.addAttribute("position", new ri(n,3)),
        this.addAttribute("normal", new ri(n.slice(),3)),
        this.addAttribute("uv", new ri(s,2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function na(e, t) {
        Zr.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new sa(e,t)),
        this.mergeVertices()
    }
    function sa(e, t) {
        ia.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function aa(e, t) {
        Zr.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new oa(e,t)),
        this.mergeVertices()
    }
    function oa(e, t) {
        ia.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function ca(e, t) {
        Zr.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new la(e,t)),
        this.mergeVertices()
    }
    function la(e, t) {
        var r = (1 + Math.sqrt(5)) / 2
          , i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1];
        ia.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function pa(e, t) {
        Zr.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new ha(e,t)),
        this.mergeVertices()
    }
    function ha(e, t) {
        var r = (1 + Math.sqrt(5)) / 2
          , i = 1 / r
          , n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i];
        ia.call(this, n, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function ua(e, t, r, i, n, s) {
        Zr.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: i,
            closed: n
        },
        void 0 !== s && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new da(e,t,r,i,n);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function da(e, t, r, i, n) {
        oi.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: i,
            closed: n
        },
        t = t || 64,
        r = r || 1,
        i = i || 8,
        n = n || !1;
        var s = e.computeFrenetFrames(t, n);
        this.tangents = s.tangents,
        this.normals = s.normals,
        this.binormals = s.binormals;
        var a, o, c = new Wt, l = new Wt, p = new Ht, h = new Wt, u = [], d = [], f = [], m = [];
        function g(n) {
            h = e.getPointAt(n / t, h);
            var a = s.normals[n]
              , p = s.binormals[n];
            for (o = 0; o <= i; o++) {
                var f = o / i * Math.PI * 2
                  , m = Math.sin(f)
                  , g = -Math.cos(f);
                l.x = g * a.x + m * p.x,
                l.y = g * a.y + m * p.y,
                l.z = g * a.z + m * p.z,
                l.normalize(),
                d.push(l.x, l.y, l.z),
                c.x = h.x + r * l.x,
                c.y = h.y + r * l.y,
                c.z = h.z + r * l.z,
                u.push(c.x, c.y, c.z)
            }
        }
        !function() {
            for (a = 0; a < t; a++)
                g(a);
            g(!1 === n ? t : 0),
            function() {
                for (a = 0; a <= t; a++)
                    for (o = 0; o <= i; o++)
                        p.x = a / t,
                        p.y = o / i,
                        f.push(p.x, p.y)
            }(),
            function() {
                for (o = 1; o <= t; o++)
                    for (a = 1; a <= i; a++) {
                        var e = (i + 1) * (o - 1) + (a - 1)
                          , r = (i + 1) * o + (a - 1)
                          , n = (i + 1) * o + a
                          , s = (i + 1) * (o - 1) + a;
                        m.push(e, r, s),
                        m.push(r, n, s)
                    }
            }()
        }(),
        this.setIndex(m),
        this.addAttribute("position", new ri(u,3)),
        this.addAttribute("normal", new ri(d,3)),
        this.addAttribute("uv", new ri(f,2))
    }
    function fa(e, t, r, i, n, s, a) {
        Zr.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: i,
            p: n,
            q: s
        },
        void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new ma(e,t,r,i,n,s)),
        this.mergeVertices()
    }
    function ma(e, t, r, i, n, s) {
        oi.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: i,
            p: n,
            q: s
        },
        e = e || 1,
        t = t || .4,
        r = Math.floor(r) || 64,
        i = Math.floor(i) || 8,
        n = n || 2,
        s = s || 3;
        var a, o, c = [], l = [], p = [], h = [], u = new Wt, d = new Wt, f = new Wt, m = new Wt, g = new Wt, v = new Wt, y = new Wt;
        for (a = 0; a <= r; ++a) {
            var b = a / r * n * Math.PI * 2;
            for (A(b, n, s, e, f),
            A(b + .01, n, s, e, m),
            v.subVectors(m, f),
            y.addVectors(m, f),
            g.crossVectors(v, y),
            y.crossVectors(g, v),
            g.normalize(),
            y.normalize(),
            o = 0; o <= i; ++o) {
                var w = o / i * Math.PI * 2
                  , x = -t * Math.cos(w)
                  , M = t * Math.sin(w);
                u.x = f.x + (x * y.x + M * g.x),
                u.y = f.y + (x * y.y + M * g.y),
                u.z = f.z + (x * y.z + M * g.z),
                l.push(u.x, u.y, u.z),
                d.subVectors(u, f).normalize(),
                p.push(d.x, d.y, d.z),
                h.push(a / r),
                h.push(o / i)
            }
        }
        for (o = 1; o <= r; o++)
            for (a = 1; a <= i; a++) {
                var _ = (i + 1) * (o - 1) + (a - 1)
                  , S = (i + 1) * o + (a - 1)
                  , T = (i + 1) * o + a
                  , E = (i + 1) * (o - 1) + a;
                c.push(_, S, E),
                c.push(S, T, E)
            }
        function A(e, t, r, i, n) {
            var s = Math.cos(e)
              , a = Math.sin(e)
              , o = r / t * e
              , c = Math.cos(o);
            n.x = i * (2 + c) * .5 * s,
            n.y = i * (2 + c) * a * .5,
            n.z = i * Math.sin(o) * .5
        }
        this.setIndex(c),
        this.addAttribute("position", new ri(l,3)),
        this.addAttribute("normal", new ri(p,3)),
        this.addAttribute("uv", new ri(h,2))
    }
    function ga(e, t, r, i, n) {
        Zr.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: i,
            arc: n
        },
        this.fromBufferGeometry(new va(e,t,r,i,n)),
        this.mergeVertices()
    }
    function va(e, t, r, i, n) {
        oi.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: i,
            arc: n
        },
        e = e || 1,
        t = t || .4,
        r = Math.floor(r) || 8,
        i = Math.floor(i) || 6,
        n = n || 2 * Math.PI;
        var s, a, o = [], c = [], l = [], p = [], h = new Wt, u = new Wt, d = new Wt;
        for (s = 0; s <= r; s++)
            for (a = 0; a <= i; a++) {
                var f = a / i * n
                  , m = s / r * Math.PI * 2;
                u.x = (e + t * Math.cos(m)) * Math.cos(f),
                u.y = (e + t * Math.cos(m)) * Math.sin(f),
                u.z = t * Math.sin(m),
                c.push(u.x, u.y, u.z),
                h.x = e * Math.cos(f),
                h.y = e * Math.sin(f),
                d.subVectors(u, h).normalize(),
                l.push(d.x, d.y, d.z),
                p.push(a / i),
                p.push(s / r)
            }
        for (s = 1; s <= r; s++)
            for (a = 1; a <= i; a++) {
                var g = (i + 1) * s + a - 1
                  , v = (i + 1) * (s - 1) + a - 1
                  , y = (i + 1) * (s - 1) + a
                  , b = (i + 1) * s + a;
                o.push(g, v, b),
                o.push(v, y, b)
            }
        this.setIndex(o),
        this.addAttribute("position", new ri(c,3)),
        this.addAttribute("normal", new ri(l,3)),
        this.addAttribute("uv", new ri(p,2))
    }
    Object.assign(Ls.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new Ls(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(Is.prototype, {
        isFog: !0,
        clone: function() {
            return new Is(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    ks.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: ks,
        isScene: !0,
        copy: function(e, t) {
            return Hr.prototype.copy.call(this, e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        },
        toJSON: function(e) {
            var t = Hr.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(Ds.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Ds.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, r) {
            e *= this.stride,
            r *= t.stride;
            for (var i = 0, n = this.stride; i < n; i++)
                this.array[e + i] = t.array[r + i];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }),
    Object.defineProperties(zs.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(zs.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this
        },
        setXYZ: function(e, t, r, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = i,
            this
        },
        setXYZW: function(e, t, r, i, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = i,
            this.data.array[e + 3] = n,
            this
        }
    }),
    Bs.prototype = Object.create(di.prototype),
    Bs.prototype.constructor = Bs,
    Bs.prototype.isSpriteMaterial = !0,
    Bs.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
    ,
    Ns.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Ns,
        isSprite: !0,
        raycast: function() {
            var e = new Wt
              , t = new Wt
              , r = new Wt
              , i = new Ht
              , n = new Ht
              , s = new br
              , a = new Wt
              , o = new Wt
              , c = new Wt
              , l = new Ht
              , p = new Ht
              , h = new Ht;
            function u(e, t, r, a, o, c) {
                i.subVectors(e, r).addScalar(.5).multiply(a),
                void 0 !== o ? (n.x = c * i.x - o * i.y,
                n.y = o * i.x + c * i.y) : n.copy(i),
                e.copy(t),
                e.x += n.x,
                e.y += n.y,
                e.applyMatrix4(s)
            }
            return function(i, n) {
                t.setFromMatrixScale(this.matrixWorld),
                s.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
                r.setFromMatrixPosition(this.modelViewMatrix);
                var d, f, m = this.material.rotation;
                0 !== m && (f = Math.cos(m),
                d = Math.sin(m));
                var g = this.center;
                u(a.set(-.5, -.5, 0), r, g, t, d, f),
                u(o.set(.5, -.5, 0), r, g, t, d, f),
                u(c.set(.5, .5, 0), r, g, t, d, f),
                l.set(0, 0),
                p.set(1, 0),
                h.set(1, 1);
                var v = i.ray.intersectTriangle(a, o, c, !1, e);
                if (null !== v || (u(o.set(-.5, .5, 0), r, g, t, d, f),
                p.set(0, 1),
                null !== (v = i.ray.intersectTriangle(a, c, o, !1, e)))) {
                    var y = i.ray.origin.distanceTo(e);
                    y < i.near || y > i.far || n.push({
                        distance: y,
                        point: e.clone(),
                        uv: Ri.getUV(e, a, o, c, l, p, h, new Ht),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return Hr.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this
        }
    }),
    js.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: js,
        isLOD: !0,
        copy: function(e) {
            Hr.prototype.copy.call(this, e, !1);
            for (var t = e.levels, r = 0, i = t.length; r < i; r++) {
                var n = t[r];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0),
            t = Math.abs(t);
            for (var r = this.levels, i = 0; i < r.length && !(t < r[i].distance); i++)
                ;
            return r.splice(i, 0, {
                distance: t,
                object: e
            }),
            this.add(e),
            this
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, r = 1, i = t.length; r < i && !(e < t[r].distance); r++)
                ;
            return t[r - 1].object
        },
        raycast: (xs = new Wt,
        function(e, t) {
            xs.setFromMatrixPosition(this.matrixWorld);
            var r = e.ray.origin.distanceTo(xs);
            this.getObjectForDistance(r).raycast(e, t)
        }
        ),
        update: function() {
            var e = new Wt
              , t = new Wt;
            return function(r) {
                var i = this.levels;
                if (i.length > 1) {
                    e.setFromMatrixPosition(r.matrixWorld),
                    t.setFromMatrixPosition(this.matrixWorld);
                    var n = e.distanceTo(t);
                    i[0].object.visible = !0;
                    for (var s = 1, a = i.length; s < a && n >= i[s].distance; s++)
                        i[s - 1].object.visible = !1,
                        i[s].object.visible = !0;
                    for (; s < a; s++)
                        i[s].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            var t = Hr.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var r = this.levels, i = 0, n = r.length; i < n; i++) {
                var s = r[i];
                t.object.levels.push({
                    object: s.object.uuid,
                    distance: s.distance
                })
            }
            return t
        }
    }),
    Fs.prototype = Object.assign(Object.create(Li.prototype), {
        constructor: Fs,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new pr, t = this.geometry.attributes.skinWeight, r = 0, i = t.count; r < i; r++) {
                e.x = t.getX(r),
                e.y = t.getY(r),
                e.z = t.getZ(r),
                e.w = t.getW(r);
                var n = 1 / e.manhattanLength();
                n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
                t.setXYZW(r, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Li.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Object.assign(Us.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var r = new br;
                this.bones[e] && r.getInverse(this.bones[e].matrixWorld),
                this.boneInverses.push(r)
            }
        },
        pose: function() {
            var e, t, r;
            for (t = 0,
            r = this.bones.length; t < r; t++)
                (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0,
            r = this.bones.length; t < r; t++)
                (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: (Ms = new br,
        _s = new br,
        function() {
            for (var e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture, n = 0, s = e.length; n < s; n++) {
                var a = e[n] ? e[n].matrixWorld : _s;
                Ms.multiplyMatrices(a, t[n]),
                Ms.toArray(r, 16 * n)
            }
            void 0 !== i && (i.needsUpdate = !0)
        }
        ),
        clone: function() {
            return new Us(this.bones,this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, r = this.bones.length; t < r; t++) {
                var i = this.bones[t];
                if (i.name === e)
                    return i
            }
        }
    }),
    Gs.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Gs,
        isBone: !0
    }),
    Hs.prototype = Object.create(di.prototype),
    Hs.prototype.constructor = Hs,
    Hs.prototype.isLineBasicMaterial = !0,
    Hs.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this
    }
    ,
    Vs.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Vs,
        isLine: !0,
        computeLineDistances: (Ss = new Wt,
        Ts = new Wt,
        function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, r = [0], i = 1, n = t.count; i < n; i++)
                        Ss.fromBufferAttribute(t, i - 1),
                        Ts.fromBufferAttribute(t, i),
                        r[i] = r[i - 1],
                        r[i] += Ss.distanceTo(Ts);
                    e.addAttribute("lineDistance", new ri(r,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var s = e.vertices;
                for ((r = e.lineDistances)[0] = 0,
                i = 1,
                n = s.length; i < n; i++)
                    r[i] = r[i - 1],
                    r[i] += s[i - 1].distanceTo(s[i])
            }
            return this
        }
        ),
        raycast: function() {
            var e = new br
              , t = new Oi
              , r = new gr;
            return function(i, n) {
                var s = i.linePrecision
                  , a = this.geometry
                  , o = this.matrixWorld;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                r.copy(a.boundingSphere),
                r.applyMatrix4(o),
                r.radius += s,
                !1 !== i.ray.intersectsSphere(r)) {
                    e.getInverse(o),
                    t.copy(i.ray).applyMatrix4(e);
                    var c = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , l = c * c
                      , p = new Wt
                      , h = new Wt
                      , u = new Wt
                      , d = new Wt
                      , f = this && this.isLineSegments ? 2 : 1;
                    if (a.isBufferGeometry) {
                        var m = a.index
                          , g = a.attributes.position.array;
                        if (null !== m)
                            for (var v = m.array, y = 0, b = v.length - 1; y < b; y += f) {
                                var w = v[y]
                                  , x = v[y + 1];
                                if (p.fromArray(g, 3 * w),
                                h.fromArray(g, 3 * x),
                                !(t.distanceSqToSegment(p, h, d, u) > l))
                                    d.applyMatrix4(this.matrixWorld),
                                    (S = i.ray.origin.distanceTo(d)) < i.near || S > i.far || n.push({
                                        distance: S,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                        else
                            for (y = 0,
                            b = g.length / 3 - 1; y < b; y += f) {
                                if (p.fromArray(g, 3 * y),
                                h.fromArray(g, 3 * y + 3),
                                !(t.distanceSqToSegment(p, h, d, u) > l))
                                    d.applyMatrix4(this.matrixWorld),
                                    (S = i.ray.origin.distanceTo(d)) < i.near || S > i.far || n.push({
                                        distance: S,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                    } else if (a.isGeometry) {
                        var M = a.vertices
                          , _ = M.length;
                        for (y = 0; y < _ - 1; y += f) {
                            var S;
                            if (!(t.distanceSqToSegment(M[y], M[y + 1], d, u) > l))
                                d.applyMatrix4(this.matrixWorld),
                                (S = i.ray.origin.distanceTo(d)) < i.near || S > i.far || n.push({
                                    distance: S,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Ws.prototype = Object.assign(Object.create(Vs.prototype), {
        constructor: Ws,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = new Wt
              , t = new Wt;
            return function() {
                var r = this.geometry;
                if (r.isBufferGeometry)
                    if (null === r.index) {
                        for (var i = r.attributes.position, n = [], s = 0, a = i.count; s < a; s += 2)
                            e.fromBufferAttribute(i, s),
                            t.fromBufferAttribute(i, s + 1),
                            n[s] = 0 === s ? 0 : n[s - 1],
                            n[s + 1] = n[s] + e.distanceTo(t);
                        r.addAttribute("lineDistance", new ri(n,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (r.isGeometry) {
                    var o = r.vertices;
                    for (n = r.lineDistances,
                    s = 0,
                    a = o.length; s < a; s += 2)
                        e.copy(o[s]),
                        t.copy(o[s + 1]),
                        n[s] = 0 === s ? 0 : n[s - 1],
                        n[s + 1] = n[s] + e.distanceTo(t)
                }
                return this
            }
        }()
    }),
    Ys.prototype = Object.assign(Object.create(Vs.prototype), {
        constructor: Ys,
        isLineLoop: !0
    }),
    Zs.prototype = Object.create(di.prototype),
    Zs.prototype.constructor = Zs,
    Zs.prototype.isPointsMaterial = !0,
    Zs.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    Xs.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: Xs,
        isPoints: !0,
        raycast: function() {
            var e = new br
              , t = new Oi
              , r = new gr;
            return function(i, n) {
                var s = this
                  , a = this.geometry
                  , o = this.matrixWorld
                  , c = i.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                r.copy(a.boundingSphere),
                r.applyMatrix4(o),
                r.radius += c,
                !1 !== i.ray.intersectsSphere(r)) {
                    e.getInverse(o),
                    t.copy(i.ray).applyMatrix4(e);
                    var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , p = l * l
                      , h = new Wt
                      , u = new Wt;
                    if (a.isBufferGeometry) {
                        var d = a.index
                          , f = a.attributes.position.array;
                        if (null !== d)
                            for (var m = d.array, g = 0, v = m.length; g < v; g++) {
                                var y = m[g];
                                h.fromArray(f, 3 * y),
                                x(h, y)
                            }
                        else {
                            g = 0;
                            for (var b = f.length / 3; g < b; g++)
                                h.fromArray(f, 3 * g),
                                x(h, g)
                        }
                    } else {
                        var w = a.vertices;
                        for (g = 0,
                        b = w.length; g < b; g++)
                            x(w[g], g)
                    }
                }
                function x(e, r) {
                    var a = t.distanceSqToPoint(e);
                    if (a < p) {
                        t.closestPointToPoint(e, u),
                        u.applyMatrix4(o);
                        var c = i.ray.origin.distanceTo(u);
                        if (c < i.near || c > i.far)
                            return;
                        n.push({
                            distance: c,
                            distanceToRay: Math.sqrt(a),
                            point: u.clone(),
                            index: r,
                            face: null,
                            object: s
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    qs.prototype = Object.assign(Object.create(lr.prototype), {
        constructor: qs,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    Js.prototype = Object.create(lr.prototype),
    Js.prototype.constructor = Js,
    Js.prototype.isCompressedTexture = !0,
    Ks.prototype = Object.create(lr.prototype),
    Ks.prototype.constructor = Ks,
    Ks.prototype.isCanvasTexture = !0,
    Qs.prototype = Object.create(lr.prototype),
    Qs.prototype.constructor = Qs,
    Qs.prototype.isDepthTexture = !0,
    $s.prototype = Object.create(oi.prototype),
    $s.prototype.constructor = $s,
    ea.prototype = Object.create(Zr.prototype),
    ea.prototype.constructor = ea,
    ta.prototype = Object.create(oi.prototype),
    ta.prototype.constructor = ta,
    ra.prototype = Object.create(Zr.prototype),
    ra.prototype.constructor = ra,
    ia.prototype = Object.create(oi.prototype),
    ia.prototype.constructor = ia,
    na.prototype = Object.create(Zr.prototype),
    na.prototype.constructor = na,
    sa.prototype = Object.create(ia.prototype),
    sa.prototype.constructor = sa,
    aa.prototype = Object.create(Zr.prototype),
    aa.prototype.constructor = aa,
    oa.prototype = Object.create(ia.prototype),
    oa.prototype.constructor = oa,
    ca.prototype = Object.create(Zr.prototype),
    ca.prototype.constructor = ca,
    la.prototype = Object.create(ia.prototype),
    la.prototype.constructor = la,
    pa.prototype = Object.create(Zr.prototype),
    pa.prototype.constructor = pa,
    ha.prototype = Object.create(ia.prototype),
    ha.prototype.constructor = ha,
    ua.prototype = Object.create(Zr.prototype),
    ua.prototype.constructor = ua,
    da.prototype = Object.create(oi.prototype),
    da.prototype.constructor = da,
    da.prototype.toJSON = function() {
        var e = oi.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(),
        e
    }
    ,
    fa.prototype = Object.create(Zr.prototype),
    fa.prototype.constructor = fa,
    ma.prototype = Object.create(oi.prototype),
    ma.prototype.constructor = ma,
    ga.prototype = Object.create(Zr.prototype),
    ga.prototype.constructor = ga,
    va.prototype = Object.create(oi.prototype),
    va.prototype.constructor = va;
    var ya = function(e, t, r) {
        r = r || 2;
        var i, n, s, a, o, c, l, p = t && t.length, h = p ? t[0] * r : e.length, u = ba(e, 0, h, r, !0), d = [];
        if (!u)
            return d;
        if (p && (u = function(e, t, r, i) {
            var n, s, a, o, c, l = [];
            for (n = 0,
            s = t.length; n < s; n++)
                a = t[n] * i,
                o = n < s - 1 ? t[n + 1] * i : e.length,
                (c = ba(e, a, o, i, !1)) === c.next && (c.steiner = !0),
                l.push(Oa(c));
            for (l.sort(Ea),
            n = 0; n < l.length; n++)
                Aa(l[n], r),
                r = wa(r, r.next);
            return r
        }(e, t, u, r)),
        e.length > 80 * r) {
            i = s = e[0],
            n = a = e[1];
            for (var f = r; f < h; f += r)
                (o = e[f]) < i && (i = o),
                (c = e[f + 1]) < n && (n = c),
                o > s && (s = o),
                c > a && (a = c);
            l = 0 !== (l = Math.max(s - i, a - n)) ? 1 / l : 0
        }
        return xa(u, d, r, i, n, l),
        d
    };
    function ba(e, t, r, i, n) {
        var s, a;
        if (n === function(e, t, r, i) {
            for (var n = 0, s = t, a = r - i; s < r; s += i)
                n += (e[a] - e[s]) * (e[s + 1] + e[a + 1]),
                a = s;
            return n
        }(e, t, r, i) > 0)
            for (s = t; s < r; s += i)
                a = Ba(s, e[s], e[s + 1], a);
        else
            for (s = r - i; s >= t; s -= i)
                a = Ba(s, e[s], e[s + 1], a);
        return a && Ia(a, a.next) && (Na(a),
        a = a.next),
        a
    }
    function wa(e, t) {
        if (!e)
            return e;
        t || (t = e);
        var r, i = e;
        do {
            if (r = !1,
            i.steiner || !Ia(i, i.next) && 0 !== La(i.prev, i, i.next))
                i = i.next;
            else {
                if (Na(i),
                (i = t = i.prev) === i.next)
                    break;
                r = !0
            }
        } while (r || i !== t);return t
    }
    function xa(e, t, r, i, n, s, a) {
        if (e) {
            !a && s && function(e, t, r, i) {
                var n = e;
                do {
                    null === n.z && (n.z = Pa(n.x, n.y, t, r, i)),
                    n.prevZ = n.prev,
                    n.nextZ = n.next,
                    n = n.next
                } while (n !== e);n.prevZ.nextZ = null,
                n.prevZ = null,
                function(e) {
                    var t, r, i, n, s, a, o, c, l = 1;
                    do {
                        for (r = e,
                        e = null,
                        s = null,
                        a = 0; r; ) {
                            for (a++,
                            i = r,
                            o = 0,
                            t = 0; t < l && (o++,
                            i = i.nextZ); t++)
                                ;
                            for (c = l; o > 0 || c > 0 && i; )
                                0 !== o && (0 === c || !i || r.z <= i.z) ? (n = r,
                                r = r.nextZ,
                                o--) : (n = i,
                                i = i.nextZ,
                                c--),
                                s ? s.nextZ = n : e = n,
                                n.prevZ = s,
                                s = n;
                            r = i
                        }
                        s.nextZ = null,
                        l *= 2
                    } while (a > 1)
                }(n)
            }(e, i, n, s);
            for (var o, c, l = e; e.prev !== e.next; )
                if (o = e.prev,
                c = e.next,
                s ? _a(e, i, n, s) : Ma(e))
                    t.push(o.i / r),
                    t.push(e.i / r),
                    t.push(c.i / r),
                    Na(e),
                    e = c.next,
                    l = c.next;
                else if ((e = c) === l) {
                    a ? 1 === a ? xa(e = Sa(e, t, r), t, r, i, n, s, 2) : 2 === a && Ta(e, t, r, i, n, s) : xa(wa(e), t, r, i, n, s, 1);
                    break
                }
        }
    }
    function Ma(e) {
        var t = e.prev
          , r = e
          , i = e.next;
        if (La(t, r, i) >= 0)
            return !1;
        for (var n = e.next.next; n !== e.prev; ) {
            if (Ra(t.x, t.y, r.x, r.y, i.x, i.y, n.x, n.y) && La(n.prev, n, n.next) >= 0)
                return !1;
            n = n.next
        }
        return !0
    }
    function _a(e, t, r, i) {
        var n = e.prev
          , s = e
          , a = e.next;
        if (La(n, s, a) >= 0)
            return !1;
        for (var o = n.x < s.x ? n.x < a.x ? n.x : a.x : s.x < a.x ? s.x : a.x, c = n.y < s.y ? n.y < a.y ? n.y : a.y : s.y < a.y ? s.y : a.y, l = n.x > s.x ? n.x > a.x ? n.x : a.x : s.x > a.x ? s.x : a.x, p = n.y > s.y ? n.y > a.y ? n.y : a.y : s.y > a.y ? s.y : a.y, h = Pa(o, c, t, r, i), u = Pa(l, p, t, r, i), d = e.nextZ; d && d.z <= u; ) {
            if (d !== e.prev && d !== e.next && Ra(n.x, n.y, s.x, s.y, a.x, a.y, d.x, d.y) && La(d.prev, d, d.next) >= 0)
                return !1;
            d = d.nextZ
        }
        for (d = e.prevZ; d && d.z >= h; ) {
            if (d !== e.prev && d !== e.next && Ra(n.x, n.y, s.x, s.y, a.x, a.y, d.x, d.y) && La(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        return !0
    }
    function Sa(e, t, r) {
        var i = e;
        do {
            var n = i.prev
              , s = i.next.next;
            !Ia(n, s) && ka(n, i, i.next, s) && Da(n, s) && Da(s, n) && (t.push(n.i / r),
            t.push(i.i / r),
            t.push(s.i / r),
            Na(i),
            Na(i.next),
            i = e = s),
            i = i.next
        } while (i !== e);return i
    }
    function Ta(e, t, r, i, n, s) {
        var a = e;
        do {
            for (var o = a.next.next; o !== a.prev; ) {
                if (a.i !== o.i && Ca(a, o)) {
                    var c = za(a, o);
                    return a = wa(a, a.next),
                    c = wa(c, c.next),
                    xa(a, t, r, i, n, s),
                    void xa(c, t, r, i, n, s)
                }
                o = o.next
            }
            a = a.next
        } while (a !== e)
    }
    function Ea(e, t) {
        return e.x - t.x
    }
    function Aa(e, t) {
        if (t = function(e, t) {
            var r, i = t, n = e.x, s = e.y, a = -1 / 0;
            do {
                if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                    var o = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (o <= n && o > a) {
                        if (a = o,
                        o === n) {
                            if (s === i.y)
                                return i;
                            if (s === i.next.y)
                                return i.next
                        }
                        r = i.x < i.next.x ? i : i.next
                    }
                }
                i = i.next
            } while (i !== t);if (!r)
                return null;
            if (n === a)
                return r.prev;
            var c, l = r, p = r.x, h = r.y, u = 1 / 0;
            i = r.next;
            for (; i !== l; )
                n >= i.x && i.x >= p && n !== i.x && Ra(s < h ? n : a, s, p, h, s < h ? a : n, s, i.x, i.y) && ((c = Math.abs(s - i.y) / (n - i.x)) < u || c === u && i.x > r.x) && Da(i, e) && (r = i,
                u = c),
                i = i.next;
            return r
        }(e, t)) {
            var r = za(t, e);
            wa(r, r.next)
        }
    }
    function Pa(e, t, r, i, n) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }
    function Oa(e) {
        var t = e
          , r = e;
        do {
            t.x < r.x && (r = t),
            t = t.next
        } while (t !== e);return r
    }
    function Ra(e, t, r, i, n, s, a, o) {
        return (n - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (i - o) - (r - a) * (t - o) >= 0 && (r - a) * (s - o) - (n - a) * (i - o) >= 0
    }
    function Ca(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
            var r = e;
            do {
                if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && ka(r, r.next, e, t))
                    return !0;
                r = r.next
            } while (r !== e);return !1
        }(e, t) && Da(e, t) && Da(t, e) && function(e, t) {
            var r = e
              , i = !1
              , n = (e.x + t.x) / 2
              , s = (e.y + t.y) / 2;
            do {
                r.y > s != r.next.y > s && r.next.y !== r.y && n < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (i = !i),
                r = r.next
            } while (r !== e);return i
        }(e, t)
    }
    function La(e, t, r) {
        return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
    }
    function Ia(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function ka(e, t, r, i) {
        return !!(Ia(e, t) && Ia(r, i) || Ia(e, i) && Ia(r, t)) || La(e, t, r) > 0 != La(e, t, i) > 0 && La(r, i, e) > 0 != La(r, i, t) > 0
    }
    function Da(e, t) {
        return La(e.prev, e, e.next) < 0 ? La(e, t, e.next) >= 0 && La(e, e.prev, t) >= 0 : La(e, t, e.prev) < 0 || La(e, e.next, t) < 0
    }
    function za(e, t) {
        var r = new ja(e.i,e.x,e.y)
          , i = new ja(t.i,t.x,t.y)
          , n = e.next
          , s = t.prev;
        return e.next = t,
        t.prev = e,
        r.next = n,
        n.prev = r,
        i.next = r,
        r.prev = i,
        s.next = i,
        i.prev = s,
        i
    }
    function Ba(e, t, r, i) {
        var n = new ja(e,t,r);
        return i ? (n.next = i.next,
        n.prev = i,
        i.next.prev = n,
        i.next = n) : (n.prev = n,
        n.next = n),
        n
    }
    function Na(e) {
        e.next.prev = e.prev,
        e.prev.next = e.next,
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }
    function ja(e, t, r) {
        this.i = e,
        this.x = t,
        this.y = r,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var Fa = {
        area: function(e) {
            for (var t = e.length, r = 0, i = t - 1, n = 0; n < t; i = n++)
                r += e[i].x * e[n].y - e[n].x * e[i].y;
            return .5 * r
        },
        isClockWise: function(e) {
            return Fa.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var r = []
              , i = []
              , n = [];
            Ua(e),
            Ga(r, e);
            var s = e.length;
            t.forEach(Ua);
            for (var a = 0; a < t.length; a++)
                i.push(s),
                s += t[a].length,
                Ga(r, t[a]);
            var o = ya(r, i);
            for (a = 0; a < o.length; a += 3)
                n.push(o.slice(a, a + 3));
            return n
        }
    };
    function Ua(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }
    function Ga(e, t) {
        for (var r = 0; r < t.length; r++)
            e.push(t[r].x),
            e.push(t[r].y)
    }
    function Ha(e, t) {
        Zr.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        this.fromBufferGeometry(new Va(e,t)),
        this.mergeVertices()
    }
    function Va(e, t) {
        oi.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        for (var r = this, i = [], n = [], s = 0, a = e.length; s < a; s++) {
            o(e[s])
        }
        function o(e) {
            var s = []
              , a = void 0 !== t.curveSegments ? t.curveSegments : 12
              , o = void 0 !== t.steps ? t.steps : 1
              , c = void 0 !== t.depth ? t.depth : 100
              , l = void 0 === t.bevelEnabled || t.bevelEnabled
              , p = void 0 !== t.bevelThickness ? t.bevelThickness : 6
              , h = void 0 !== t.bevelSize ? t.bevelSize : p - 2
              , u = void 0 !== t.bevelOffset ? t.bevelOffset : 0
              , d = void 0 !== t.bevelSegments ? t.bevelSegments : 3
              , f = t.extrudePath
              , m = void 0 !== t.UVGenerator ? t.UVGenerator : Wa;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            c = t.amount);
            var g, v, y, b, w, x, M, _, S = !1;
            f && (g = f.getSpacedPoints(o),
            S = !0,
            l = !1,
            v = f.computeFrenetFrames(o, !1),
            y = new Wt,
            b = new Wt,
            w = new Wt),
            l || (d = 0,
            p = 0,
            h = 0,
            u = 0);
            var T = e.extractPoints(a)
              , E = T.shape
              , A = T.holes;
            if (!Fa.isClockWise(E))
                for (E = E.reverse(),
                M = 0,
                _ = A.length; M < _; M++)
                    x = A[M],
                    Fa.isClockWise(x) && (A[M] = x.reverse());
            var P = Fa.triangulateShape(E, A)
              , O = E;
            for (M = 0,
            _ = A.length; M < _; M++)
                x = A[M],
                E = E.concat(x);
            function R(e, t, r) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(r).add(e)
            }
            var C, L, I, k, D, z, B = E.length, N = P.length;
            function j(e, t, r) {
                var i, n, s, a = e.x - t.x, o = e.y - t.y, c = r.x - e.x, l = r.y - e.y, p = a * a + o * o, h = a * l - o * c;
                if (Math.abs(h) > Number.EPSILON) {
                    var u = Math.sqrt(p)
                      , d = Math.sqrt(c * c + l * l)
                      , f = t.x - o / u
                      , m = t.y + a / u
                      , g = ((r.x - l / d - f) * l - (r.y + c / d - m) * c) / (a * l - o * c)
                      , v = (i = f + a * g - e.x) * i + (n = m + o * g - e.y) * n;
                    if (v <= 2)
                        return new Ht(i,n);
                    s = Math.sqrt(v / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(o) === Math.sign(l) && (y = !0),
                    y ? (i = -o,
                    n = a,
                    s = Math.sqrt(p)) : (i = a,
                    n = o,
                    s = Math.sqrt(p / 2))
                }
                return new Ht(i / s,n / s)
            }
            for (var F = [], U = 0, G = O.length, H = G - 1, V = U + 1; U < G; U++,
            H++,
            V++)
                H === G && (H = 0),
                V === G && (V = 0),
                F[U] = j(O[U], O[H], O[V]);
            var W, Y, Z = [], X = F.concat();
            for (M = 0,
            _ = A.length; M < _; M++) {
                for (x = A[M],
                W = [],
                U = 0,
                H = (G = x.length) - 1,
                V = U + 1; U < G; U++,
                H++,
                V++)
                    H === G && (H = 0),
                    V === G && (V = 0),
                    W[U] = j(x[U], x[H], x[V]);
                Z.push(W),
                X = X.concat(W)
            }
            for (C = 0; C < d; C++) {
                for (I = C / d,
                k = p * Math.cos(I * Math.PI / 2),
                L = h * Math.sin(I * Math.PI / 2) + u,
                U = 0,
                G = O.length; U < G; U++)
                    J((D = R(O[U], F[U], L)).x, D.y, -k);
                for (M = 0,
                _ = A.length; M < _; M++)
                    for (x = A[M],
                    W = Z[M],
                    U = 0,
                    G = x.length; U < G; U++)
                        J((D = R(x[U], W[U], L)).x, D.y, -k)
            }
            for (L = h + u,
            U = 0; U < B; U++)
                D = l ? R(E[U], X[U], L) : E[U],
                S ? (b.copy(v.normals[0]).multiplyScalar(D.x),
                y.copy(v.binormals[0]).multiplyScalar(D.y),
                w.copy(g[0]).add(b).add(y),
                J(w.x, w.y, w.z)) : J(D.x, D.y, 0);
            for (Y = 1; Y <= o; Y++)
                for (U = 0; U < B; U++)
                    D = l ? R(E[U], X[U], L) : E[U],
                    S ? (b.copy(v.normals[Y]).multiplyScalar(D.x),
                    y.copy(v.binormals[Y]).multiplyScalar(D.y),
                    w.copy(g[Y]).add(b).add(y),
                    J(w.x, w.y, w.z)) : J(D.x, D.y, c / o * Y);
            for (C = d - 1; C >= 0; C--) {
                for (I = C / d,
                k = p * Math.cos(I * Math.PI / 2),
                L = h * Math.sin(I * Math.PI / 2) + u,
                U = 0,
                G = O.length; U < G; U++)
                    J((D = R(O[U], F[U], L)).x, D.y, c + k);
                for (M = 0,
                _ = A.length; M < _; M++)
                    for (x = A[M],
                    W = Z[M],
                    U = 0,
                    G = x.length; U < G; U++)
                        D = R(x[U], W[U], L),
                        S ? J(D.x, D.y + g[o - 1].y, g[o - 1].x + k) : J(D.x, D.y, c + k)
            }
            function q(e, t) {
                var r, i;
                for (U = e.length; --U >= 0; ) {
                    r = U,
                    (i = U - 1) < 0 && (i = e.length - 1);
                    var n = 0
                      , s = o + 2 * d;
                    for (n = 0; n < s; n++) {
                        var a = B * n
                          , c = B * (n + 1);
                        Q(t + r + a, t + i + a, t + i + c, t + r + c)
                    }
                }
            }
            function J(e, t, r) {
                s.push(e),
                s.push(t),
                s.push(r)
            }
            function K(e, t, n) {
                $(e),
                $(t),
                $(n);
                var s = i.length / 3
                  , a = m.generateTopUV(r, i, s - 3, s - 2, s - 1);
                ee(a[0]),
                ee(a[1]),
                ee(a[2])
            }
            function Q(e, t, n, s) {
                $(e),
                $(t),
                $(s),
                $(t),
                $(n),
                $(s);
                var a = i.length / 3
                  , o = m.generateSideWallUV(r, i, a - 6, a - 3, a - 2, a - 1);
                ee(o[0]),
                ee(o[1]),
                ee(o[3]),
                ee(o[1]),
                ee(o[2]),
                ee(o[3])
            }
            function $(e) {
                i.push(s[3 * e + 0]),
                i.push(s[3 * e + 1]),
                i.push(s[3 * e + 2])
            }
            function ee(e) {
                n.push(e.x),
                n.push(e.y)
            }
            !function() {
                var e = i.length / 3;
                if (l) {
                    var t = 0
                      , n = B * t;
                    for (U = 0; U < N; U++)
                        K((z = P[U])[2] + n, z[1] + n, z[0] + n);
                    for (n = B * (t = o + 2 * d),
                    U = 0; U < N; U++)
                        K((z = P[U])[0] + n, z[1] + n, z[2] + n)
                } else {
                    for (U = 0; U < N; U++)
                        K((z = P[U])[2], z[1], z[0]);
                    for (U = 0; U < N; U++)
                        K((z = P[U])[0] + B * o, z[1] + B * o, z[2] + B * o)
                }
                r.addGroup(e, i.length / 3 - e, 0)
            }(),
            function() {
                var e = i.length / 3
                  , t = 0;
                for (q(O, t),
                t += O.length,
                M = 0,
                _ = A.length; M < _; M++)
                    q(x = A[M], t),
                    t += x.length;
                r.addGroup(e, i.length / 3 - e, 1)
            }()
        }
        this.addAttribute("position", new ri(i,3)),
        this.addAttribute("uv", new ri(n,2)),
        this.computeVertexNormals()
    }
    Ha.prototype = Object.create(Zr.prototype),
    Ha.prototype.constructor = Ha,
    Ha.prototype.toJSON = function() {
        var e = Zr.prototype.toJSON.call(this);
        return Ya(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    Va.prototype = Object.create(oi.prototype),
    Va.prototype.constructor = Va,
    Va.prototype.toJSON = function() {
        var e = oi.prototype.toJSON.call(this);
        return Ya(this.parameters.shapes, this.parameters.options, e)
    }
    ;
    var Wa = {
        generateTopUV: function(e, t, r, i, n) {
            var s = t[3 * r]
              , a = t[3 * r + 1]
              , o = t[3 * i]
              , c = t[3 * i + 1]
              , l = t[3 * n]
              , p = t[3 * n + 1];
            return [new Ht(s,a), new Ht(o,c), new Ht(l,p)]
        },
        generateSideWallUV: function(e, t, r, i, n, s) {
            var a = t[3 * r]
              , o = t[3 * r + 1]
              , c = t[3 * r + 2]
              , l = t[3 * i]
              , p = t[3 * i + 1]
              , h = t[3 * i + 2]
              , u = t[3 * n]
              , d = t[3 * n + 1]
              , f = t[3 * n + 2]
              , m = t[3 * s]
              , g = t[3 * s + 1]
              , v = t[3 * s + 2];
            return Math.abs(o - p) < .01 ? [new Ht(a,1 - c), new Ht(l,1 - h), new Ht(u,1 - f), new Ht(m,1 - v)] : [new Ht(o,1 - c), new Ht(p,1 - h), new Ht(d,1 - f), new Ht(g,1 - v)]
        }
    };
    function Ya(e, t, r) {
        if (r.shapes = [],
        Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                r.shapes.push(s.uuid)
            }
        else
            r.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()),
        r
    }
    function Za(e, t) {
        Zr.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: e,
            parameters: t
        },
        this.fromBufferGeometry(new Xa(e,t)),
        this.mergeVertices()
    }
    function Xa(e, t) {
        var r = (t = t || {}).font;
        if (!r || !r.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new Zr;
        var i = r.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50,
        void 0 === t.bevelThickness && (t.bevelThickness = 10),
        void 0 === t.bevelSize && (t.bevelSize = 8),
        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
        Va.call(this, i, t),
        this.type = "TextBufferGeometry"
    }
    function qa(e, t, r, i, n, s, a) {
        Zr.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: i,
            phiLength: n,
            thetaStart: s,
            thetaLength: a
        },
        this.fromBufferGeometry(new Ja(e,t,r,i,n,s,a)),
        this.mergeVertices()
    }
    function Ja(e, t, r, i, n, s, a) {
        oi.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: i,
            phiLength: n,
            thetaStart: s,
            thetaLength: a
        },
        e = e || 1,
        t = Math.max(3, Math.floor(t) || 8),
        r = Math.max(2, Math.floor(r) || 6),
        i = void 0 !== i ? i : 0,
        n = void 0 !== n ? n : 2 * Math.PI,
        s = void 0 !== s ? s : 0,
        a = void 0 !== a ? a : Math.PI;
        var o, c, l = Math.min(s + a, Math.PI), p = 0, h = [], u = new Wt, d = new Wt, f = [], m = [], g = [], v = [];
        for (c = 0; c <= r; c++) {
            var y = []
              , b = c / r
              , w = 0;
            for (0 == c && 0 == s ? w = .5 / t : c == r && l == Math.PI && (w = -.5 / t),
            o = 0; o <= t; o++) {
                var x = o / t;
                u.x = -e * Math.cos(i + x * n) * Math.sin(s + b * a),
                u.y = e * Math.cos(s + b * a),
                u.z = e * Math.sin(i + x * n) * Math.sin(s + b * a),
                m.push(u.x, u.y, u.z),
                d.copy(u).normalize(),
                g.push(d.x, d.y, d.z),
                v.push(x + w, 1 - b),
                y.push(p++)
            }
            h.push(y)
        }
        for (c = 0; c < r; c++)
            for (o = 0; o < t; o++) {
                var M = h[c][o + 1]
                  , _ = h[c][o]
                  , S = h[c + 1][o]
                  , T = h[c + 1][o + 1];
                (0 !== c || s > 0) && f.push(M, _, T),
                (c !== r - 1 || l < Math.PI) && f.push(_, S, T)
            }
        this.setIndex(f),
        this.addAttribute("position", new ri(m,3)),
        this.addAttribute("normal", new ri(g,3)),
        this.addAttribute("uv", new ri(v,2))
    }
    function Ka(e, t, r, i, n, s) {
        Zr.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: i,
            thetaStart: n,
            thetaLength: s
        },
        this.fromBufferGeometry(new Qa(e,t,r,i,n,s)),
        this.mergeVertices()
    }
    function Qa(e, t, r, i, n, s) {
        oi.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: i,
            thetaStart: n,
            thetaLength: s
        },
        e = e || .5,
        t = t || 1,
        n = void 0 !== n ? n : 0,
        s = void 0 !== s ? s : 2 * Math.PI,
        r = void 0 !== r ? Math.max(3, r) : 8;
        var a, o, c, l = [], p = [], h = [], u = [], d = e, f = (t - e) / (i = void 0 !== i ? Math.max(1, i) : 1), m = new Wt, g = new Ht;
        for (o = 0; o <= i; o++) {
            for (c = 0; c <= r; c++)
                a = n + c / r * s,
                m.x = d * Math.cos(a),
                m.y = d * Math.sin(a),
                p.push(m.x, m.y, m.z),
                h.push(0, 0, 1),
                g.x = (m.x / t + 1) / 2,
                g.y = (m.y / t + 1) / 2,
                u.push(g.x, g.y);
            d += f
        }
        for (o = 0; o < i; o++) {
            var v = o * (r + 1);
            for (c = 0; c < r; c++) {
                var y = a = c + v
                  , b = a + r + 1
                  , w = a + r + 2
                  , x = a + 1;
                l.push(y, b, x),
                l.push(b, w, x)
            }
        }
        this.setIndex(l),
        this.addAttribute("position", new ri(p,3)),
        this.addAttribute("normal", new ri(h,3)),
        this.addAttribute("uv", new ri(u,2))
    }
    function $a(e, t, r, i) {
        Zr.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: i
        },
        this.fromBufferGeometry(new eo(e,t,r,i)),
        this.mergeVertices()
    }
    function eo(e, t, r, i) {
        oi.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: i
        },
        t = Math.floor(t) || 12,
        r = r || 0,
        i = i || 2 * Math.PI,
        i = Gt.clamp(i, 0, 2 * Math.PI);
        var n, s, a, o = [], c = [], l = [], p = 1 / t, h = new Wt, u = new Ht;
        for (s = 0; s <= t; s++) {
            var d = r + s * p * i
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (a = 0; a <= e.length - 1; a++)
                h.x = e[a].x * f,
                h.y = e[a].y,
                h.z = e[a].x * m,
                c.push(h.x, h.y, h.z),
                u.x = s / t,
                u.y = a / (e.length - 1),
                l.push(u.x, u.y)
        }
        for (s = 0; s < t; s++)
            for (a = 0; a < e.length - 1; a++) {
                var g = n = a + s * e.length
                  , v = n + e.length
                  , y = n + e.length + 1
                  , b = n + 1;
                o.push(g, v, b),
                o.push(v, y, b)
            }
        if (this.setIndex(o),
        this.addAttribute("position", new ri(c,3)),
        this.addAttribute("uv", new ri(l,2)),
        this.computeVertexNormals(),
        i === 2 * Math.PI) {
            var w = this.attributes.normal.array
              , x = new Wt
              , M = new Wt
              , _ = new Wt;
            for (n = t * e.length * 3,
            s = 0,
            a = 0; s < e.length; s++,
            a += 3)
                x.x = w[a + 0],
                x.y = w[a + 1],
                x.z = w[a + 2],
                M.x = w[n + a + 0],
                M.y = w[n + a + 1],
                M.z = w[n + a + 2],
                _.addVectors(x, M).normalize(),
                w[a + 0] = w[n + a + 0] = _.x,
                w[a + 1] = w[n + a + 1] = _.y,
                w[a + 2] = w[n + a + 2] = _.z
        }
    }
    function to(e, t) {
        Zr.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        t = t.curveSegments),
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        this.fromBufferGeometry(new ro(e,t)),
        this.mergeVertices()
    }
    function ro(e, t) {
        oi.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        t = t || 12;
        var r = []
          , i = []
          , n = []
          , s = []
          , a = 0
          , o = 0;
        if (!1 === Array.isArray(e))
            l(e);
        else
            for (var c = 0; c < e.length; c++)
                l(e[c]),
                this.addGroup(a, o, c),
                a += o,
                o = 0;
        function l(e) {
            var a, c, l, p = i.length / 3, h = e.extractPoints(t), u = h.shape, d = h.holes;
            for (!1 === Fa.isClockWise(u) && (u = u.reverse()),
            a = 0,
            c = d.length; a < c; a++)
                l = d[a],
                !0 === Fa.isClockWise(l) && (d[a] = l.reverse());
            var f = Fa.triangulateShape(u, d);
            for (a = 0,
            c = d.length; a < c; a++)
                l = d[a],
                u = u.concat(l);
            for (a = 0,
            c = u.length; a < c; a++) {
                var m = u[a];
                i.push(m.x, m.y, 0),
                n.push(0, 0, 1),
                s.push(m.x, m.y)
            }
            for (a = 0,
            c = f.length; a < c; a++) {
                var g = f[a]
                  , v = g[0] + p
                  , y = g[1] + p
                  , b = g[2] + p;
                r.push(v, y, b),
                o += 3
            }
        }
        this.setIndex(r),
        this.addAttribute("position", new ri(i,3)),
        this.addAttribute("normal", new ri(n,3)),
        this.addAttribute("uv", new ri(s,2))
    }
    function io(e, t) {
        if (t.shapes = [],
        Array.isArray(e))
            for (var r = 0, i = e.length; r < i; r++) {
                var n = e[r];
                t.shapes.push(n.uuid)
            }
        else
            t.shapes.push(e.uuid);
        return t
    }
    function no(e, t) {
        oi.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: t
        },
        t = void 0 !== t ? t : 1;
        var r, i, n, s, a = [], o = Math.cos(Gt.DEG2RAD * t), c = [0, 0], l = {}, p = ["a", "b", "c"];
        e.isBufferGeometry ? (s = new Zr).fromBufferGeometry(e) : s = e.clone(),
        s.mergeVertices(),
        s.computeFaceNormals();
        for (var h = s.vertices, u = s.faces, d = 0, f = u.length; d < f; d++)
            for (var m = u[d], g = 0; g < 3; g++)
                r = m[p[g]],
                i = m[p[(g + 1) % 3]],
                c[0] = Math.min(r, i),
                c[1] = Math.max(r, i),
                void 0 === l[n = c[0] + "," + c[1]] ? l[n] = {
                    index1: c[0],
                    index2: c[1],
                    face1: d,
                    face2: void 0
                } : l[n].face2 = d;
        for (n in l) {
            var v = l[n];
            if (void 0 === v.face2 || u[v.face1].normal.dot(u[v.face2].normal) <= o) {
                var y = h[v.index1];
                a.push(y.x, y.y, y.z),
                y = h[v.index2],
                a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new ri(a,3))
    }
    function so(e, t, r, i, n, s, a, o) {
        Zr.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: i,
            heightSegments: n,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        },
        this.fromBufferGeometry(new ao(e,t,r,i,n,s,a,o)),
        this.mergeVertices()
    }
    function ao(e, t, r, i, n, s, a, o) {
        oi.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: i,
            heightSegments: n,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        };
        var c = this;
        e = void 0 !== e ? e : 1,
        t = void 0 !== t ? t : 1,
        r = r || 1,
        i = Math.floor(i) || 8,
        n = Math.floor(n) || 1,
        s = void 0 !== s && s,
        a = void 0 !== a ? a : 0,
        o = void 0 !== o ? o : 2 * Math.PI;
        var l = []
          , p = []
          , h = []
          , u = []
          , d = 0
          , f = []
          , m = r / 2
          , g = 0;
        function v(r) {
            var n, s, f, v = new Ht, y = new Wt, b = 0, w = !0 === r ? e : t, x = !0 === r ? 1 : -1;
            for (s = d,
            n = 1; n <= i; n++)
                p.push(0, m * x, 0),
                h.push(0, x, 0),
                u.push(.5, .5),
                d++;
            for (f = d,
            n = 0; n <= i; n++) {
                var M = n / i * o + a
                  , _ = Math.cos(M)
                  , S = Math.sin(M);
                y.x = w * S,
                y.y = m * x,
                y.z = w * _,
                p.push(y.x, y.y, y.z),
                h.push(0, x, 0),
                v.x = .5 * _ + .5,
                v.y = .5 * S * x + .5,
                u.push(v.x, v.y),
                d++
            }
            for (n = 0; n < i; n++) {
                var T = s + n
                  , E = f + n;
                !0 === r ? l.push(E, E + 1, T) : l.push(E + 1, E, T),
                b += 3
            }
            c.addGroup(g, b, !0 === r ? 1 : 2),
            g += b
        }
        !function() {
            var s, v, y = new Wt, b = new Wt, w = 0, x = (t - e) / r;
            for (v = 0; v <= n; v++) {
                var M = []
                  , _ = v / n
                  , S = _ * (t - e) + e;
                for (s = 0; s <= i; s++) {
                    var T = s / i
                      , E = T * o + a
                      , A = Math.sin(E)
                      , P = Math.cos(E);
                    b.x = S * A,
                    b.y = -_ * r + m,
                    b.z = S * P,
                    p.push(b.x, b.y, b.z),
                    y.set(A, x, P).normalize(),
                    h.push(y.x, y.y, y.z),
                    u.push(T, 1 - _),
                    M.push(d++)
                }
                f.push(M)
            }
            for (s = 0; s < i; s++)
                for (v = 0; v < n; v++) {
                    var O = f[v][s]
                      , R = f[v + 1][s]
                      , C = f[v + 1][s + 1]
                      , L = f[v][s + 1];
                    l.push(O, R, L),
                    l.push(R, C, L),
                    w += 6
                }
            c.addGroup(g, w, 0),
            g += w
        }(),
        !1 === s && (e > 0 && v(!0),
        t > 0 && v(!1)),
        this.setIndex(l),
        this.addAttribute("position", new ri(p,3)),
        this.addAttribute("normal", new ri(h,3)),
        this.addAttribute("uv", new ri(u,2))
    }
    function oo(e, t, r, i, n, s, a) {
        so.call(this, 0, e, t, r, i, n, s, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: i,
            openEnded: n,
            thetaStart: s,
            thetaLength: a
        }
    }
    function co(e, t, r, i, n, s, a) {
        ao.call(this, 0, e, t, r, i, n, s, a),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: i,
            openEnded: n,
            thetaStart: s,
            thetaLength: a
        }
    }
    function lo(e, t, r, i) {
        Zr.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: i
        },
        this.fromBufferGeometry(new po(e,t,r,i)),
        this.mergeVertices()
    }
    function po(e, t, r, i) {
        oi.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: i
        },
        e = e || 1,
        t = void 0 !== t ? Math.max(3, t) : 8,
        r = void 0 !== r ? r : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var n, s, a = [], o = [], c = [], l = [], p = new Wt, h = new Ht;
        for (o.push(0, 0, 0),
        c.push(0, 0, 1),
        l.push(.5, .5),
        s = 0,
        n = 3; s <= t; s++,
        n += 3) {
            var u = r + s / t * i;
            p.x = e * Math.cos(u),
            p.y = e * Math.sin(u),
            o.push(p.x, p.y, p.z),
            c.push(0, 0, 1),
            h.x = (o[n] / e + 1) / 2,
            h.y = (o[n + 1] / e + 1) / 2,
            l.push(h.x, h.y)
        }
        for (n = 1; n <= t; n++)
            a.push(n, n + 1, 0);
        this.setIndex(a),
        this.addAttribute("position", new ri(o,3)),
        this.addAttribute("normal", new ri(c,3)),
        this.addAttribute("uv", new ri(l,2))
    }
    Za.prototype = Object.create(Zr.prototype),
    Za.prototype.constructor = Za,
    Xa.prototype = Object.create(Va.prototype),
    Xa.prototype.constructor = Xa,
    qa.prototype = Object.create(Zr.prototype),
    qa.prototype.constructor = qa,
    Ja.prototype = Object.create(oi.prototype),
    Ja.prototype.constructor = Ja,
    Ka.prototype = Object.create(Zr.prototype),
    Ka.prototype.constructor = Ka,
    Qa.prototype = Object.create(oi.prototype),
    Qa.prototype.constructor = Qa,
    $a.prototype = Object.create(Zr.prototype),
    $a.prototype.constructor = $a,
    eo.prototype = Object.create(oi.prototype),
    eo.prototype.constructor = eo,
    to.prototype = Object.create(Zr.prototype),
    to.prototype.constructor = to,
    to.prototype.toJSON = function() {
        var e = Zr.prototype.toJSON.call(this);
        return io(this.parameters.shapes, e)
    }
    ,
    ro.prototype = Object.create(oi.prototype),
    ro.prototype.constructor = ro,
    ro.prototype.toJSON = function() {
        var e = oi.prototype.toJSON.call(this);
        return io(this.parameters.shapes, e)
    }
    ,
    no.prototype = Object.create(oi.prototype),
    no.prototype.constructor = no,
    so.prototype = Object.create(Zr.prototype),
    so.prototype.constructor = so,
    ao.prototype = Object.create(oi.prototype),
    ao.prototype.constructor = ao,
    oo.prototype = Object.create(so.prototype),
    oo.prototype.constructor = oo,
    co.prototype = Object.create(ao.prototype),
    co.prototype.constructor = co,
    lo.prototype = Object.create(Zr.prototype),
    lo.prototype.constructor = lo,
    po.prototype = Object.create(oi.prototype),
    po.prototype.constructor = po;
    var ho = Object.freeze({
        WireframeGeometry: $s,
        ParametricGeometry: ea,
        ParametricBufferGeometry: ta,
        TetrahedronGeometry: na,
        TetrahedronBufferGeometry: sa,
        OctahedronGeometry: aa,
        OctahedronBufferGeometry: oa,
        IcosahedronGeometry: ca,
        IcosahedronBufferGeometry: la,
        DodecahedronGeometry: pa,
        DodecahedronBufferGeometry: ha,
        PolyhedronGeometry: ra,
        PolyhedronBufferGeometry: ia,
        TubeGeometry: ua,
        TubeBufferGeometry: da,
        TorusKnotGeometry: fa,
        TorusKnotBufferGeometry: ma,
        TorusGeometry: ga,
        TorusBufferGeometry: va,
        TextGeometry: Za,
        TextBufferGeometry: Xa,
        SphereGeometry: qa,
        SphereBufferGeometry: Ja,
        RingGeometry: Ka,
        RingBufferGeometry: Qa,
        PlaneGeometry: pi,
        PlaneBufferGeometry: hi,
        LatheGeometry: $a,
        LatheBufferGeometry: eo,
        ShapeGeometry: to,
        ShapeBufferGeometry: ro,
        ExtrudeGeometry: Ha,
        ExtrudeBufferGeometry: Va,
        EdgesGeometry: no,
        ConeGeometry: oo,
        ConeBufferGeometry: co,
        CylinderGeometry: so,
        CylinderBufferGeometry: ao,
        CircleGeometry: lo,
        CircleBufferGeometry: po,
        BoxGeometry: ci,
        BoxBufferGeometry: li
    });
    function uo(e) {
        di.call(this),
        this.type = "ShadowMaterial",
        this.color = new Pr(0),
        this.transparent = !0,
        this.setValues(e)
    }
    function fo(e) {
        Pi.call(this, e),
        this.type = "RawShaderMaterial"
    }
    function mo(e) {
        di.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Pr(16777215),
        this.roughness = .5,
        this.metalness = .5,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Pr(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ft,
        this.normalScale = new Ht(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function go(e) {
        mo.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoat = 0,
        this.clearCoatRoughness = 0,
        this.setValues(e)
    }
    function vo(e) {
        di.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new Pr(16777215),
        this.specular = new Pr(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Pr(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ft,
        this.normalScale = new Ht(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = re,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function yo(e) {
        vo.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(e)
    }
    function bo(e) {
        di.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ft,
        this.normalScale = new Ht(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function wo(e) {
        di.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new Pr(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Pr(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = re,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function xo(e) {
        di.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Pr(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Ft,
        this.normalScale = new Ht(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Mo(e) {
        Hs.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    uo.prototype = Object.create(di.prototype),
    uo.prototype.constructor = uo,
    uo.prototype.isShadowMaterial = !0,
    uo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this
    }
    ,
    fo.prototype = Object.create(Pi.prototype),
    fo.prototype.constructor = fo,
    fo.prototype.isRawShaderMaterial = !0,
    mo.prototype = Object.create(di.prototype),
    mo.prototype.constructor = mo,
    mo.prototype.isMeshStandardMaterial = !0,
    mo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    go.prototype = Object.create(mo.prototype),
    go.prototype.constructor = go,
    go.prototype.isMeshPhysicalMaterial = !0,
    go.prototype.copy = function(e) {
        return mo.prototype.copy.call(this, e),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = e.reflectivity,
        this.clearCoat = e.clearCoat,
        this.clearCoatRoughness = e.clearCoatRoughness,
        this
    }
    ,
    vo.prototype = Object.create(di.prototype),
    vo.prototype.constructor = vo,
    vo.prototype.isMeshPhongMaterial = !0,
    vo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    yo.prototype = Object.create(vo.prototype),
    yo.prototype.constructor = yo,
    yo.prototype.isMeshToonMaterial = !0,
    yo.prototype.copy = function(e) {
        return vo.prototype.copy.call(this, e),
        this.gradientMap = e.gradientMap,
        this
    }
    ,
    bo.prototype = Object.create(di.prototype),
    bo.prototype.constructor = bo,
    bo.prototype.isMeshNormalMaterial = !0,
    bo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    wo.prototype = Object.create(di.prototype),
    wo.prototype.constructor = wo,
    wo.prototype.isMeshLambertMaterial = !0,
    wo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    xo.prototype = Object.create(di.prototype),
    xo.prototype.constructor = xo,
    xo.prototype.isMeshMatcapMaterial = !0,
    xo.prototype.copy = function(e) {
        return di.prototype.copy.call(this, e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Mo.prototype = Object.create(Hs.prototype),
    Mo.prototype.constructor = Mo,
    Mo.prototype.isLineDashedMaterial = !0,
    Mo.prototype.copy = function(e) {
        return Hs.prototype.copy.call(this, e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
    ;
    var _o = Object.freeze({
        ShadowMaterial: uo,
        SpriteMaterial: Bs,
        RawShaderMaterial: fo,
        ShaderMaterial: Pi,
        PointsMaterial: Zs,
        MeshPhysicalMaterial: go,
        MeshStandardMaterial: mo,
        MeshPhongMaterial: vo,
        MeshToonMaterial: yo,
        MeshNormalMaterial: bo,
        MeshLambertMaterial: wo,
        MeshDepthMaterial: ps,
        MeshDistanceMaterial: hs,
        MeshBasicMaterial: Ci,
        MeshMatcapMaterial: xo,
        LineDashedMaterial: Mo,
        LineBasicMaterial: Hs,
        Material: di
    })
      , So = {
        arraySlice: function(e, t, r) {
            return So.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== r ? r : e.length)) : e.slice(t, r)
        },
        convertArray: function(e, t, r) {
            return !e || !r && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(e) {
            for (var t = e.length, r = new Array(t), i = 0; i !== t; ++i)
                r[i] = i;
            return r.sort(function(t, r) {
                return e[t] - e[r]
            }),
            r
        },
        sortedArray: function(e, t, r) {
            for (var i = e.length, n = new e.constructor(i), s = 0, a = 0; a !== i; ++s)
                for (var o = r[s] * t, c = 0; c !== t; ++c)
                    n[a++] = e[o + c];
            return n
        },
        flattenJSON: function(e, t, r, i) {
            for (var n = 1, s = e[0]; void 0 !== s && void 0 === s[i]; )
                s = e[n++];
            if (void 0 !== s) {
                var a = s[i];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = s[i]) && (t.push(s.time),
                            r.push.apply(r, a)),
                            s = e[n++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = s[i]) && (t.push(s.time),
                            a.toArray(r, r.length)),
                            s = e[n++]
                        } while (void 0 !== s);
                    else
                        do {
                            void 0 !== (a = s[i]) && (t.push(s.time),
                            r.push(a)),
                            s = e[n++]
                        } while (void 0 !== s)
            }
        }
    };
    function To(e, t, r, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new t.constructor(r),
        this.sampleValues = t,
        this.valueSize = r
    }
    function Eo(e, t, r, i) {
        To.call(this, e, t, r, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function Ao(e, t, r, i) {
        To.call(this, e, t, r, i)
    }
    function Po(e, t, r, i) {
        To.call(this, e, t, r, i)
    }
    function Oo(e, t, r, i) {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = So.convertArray(t, this.TimeBufferType),
        this.values = So.convertArray(r, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    function Ro(e, t, r) {
        Oo.call(this, e, t, r)
    }
    function Co(e, t, r, i) {
        Oo.call(this, e, t, r, i)
    }
    function Lo(e, t, r, i) {
        Oo.call(this, e, t, r, i)
    }
    function Io(e, t, r, i) {
        To.call(this, e, t, r, i)
    }
    function ko(e, t, r, i) {
        Oo.call(this, e, t, r, i)
    }
    function Do(e, t, r, i) {
        Oo.call(this, e, t, r, i)
    }
    function zo(e, t, r, i) {
        Oo.call(this, e, t, r, i)
    }
    function Bo(e, t, r) {
        this.name = e,
        this.tracks = r,
        this.duration = void 0 !== t ? t : -1,
        this.uuid = Gt.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function No(e) {
        if (void 0 === e.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Lo;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return zo;
            case "color":
                return Co;
            case "quaternion":
                return ko;
            case "bool":
            case "boolean":
                return Ro;
            case "string":
                return Do
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var r = []
              , i = [];
            So.flattenJSON(e.keys, r, i, "value"),
            e.times = r,
            e.values = i
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
    }
    Object.assign(To.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions
              , r = this._cachedIndex
              , i = t[r]
              , n = t[r - 1];
            e: {
                t: {
                    var s;
                    r: {
                        i: if (!(e < i)) {
                            for (var a = r + 2; ; ) {
                                if (void 0 === i) {
                                    if (e < n)
                                        break i;
                                    return r = t.length,
                                    this._cachedIndex = r,
                                    this.afterEnd_(r - 1, e, n)
                                }
                                if (r === a)
                                    break;
                                if (n = i,
                                e < (i = t[++r]))
                                    break t
                            }
                            s = t.length;
                            break r
                        }
                        if (e >= n)
                            break e;
                        var o = t[1];
                        e < o && (r = 2,
                        n = o);
                        for (a = r - 2; ; ) {
                            if (void 0 === n)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, i);
                            if (r === a)
                                break;
                            if (i = n,
                            e >= (n = t[--r - 1]))
                                break t
                        }
                        s = r,
                        r = 0
                    }
                    for (; r < s; ) {
                        var c = r + s >>> 1;
                        e < t[c] ? s = c : r = c + 1
                    }
                    if (i = t[r],
                    void 0 === (n = t[r - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, i);
                    if (void 0 === i)
                        return r = t.length,
                        this._cachedIndex = r,
                        this.afterEnd_(r - 1, n, e)
                }
                this._cachedIndex = r,
                this.intervalChanged_(r, n, i)
            }
            return this.interpolate_(r, n, e, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            for (var t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, n = e * i, s = 0; s !== i; ++s)
                t[s] = r[n + s];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(To.prototype, {
        beforeStart_: To.prototype.copySampleValue_,
        afterEnd_: To.prototype.copySampleValue_
    }),
    Eo.prototype = Object.assign(Object.create(To.prototype), {
        constructor: Eo,
        DefaultSettings_: {
            endingStart: St,
            endingEnd: St
        },
        intervalChanged_: function(e, t, r) {
            var i = this.parameterPositions
              , n = e - 2
              , s = e + 1
              , a = i[n]
              , o = i[s];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case Tt:
                    n = e,
                    a = 2 * t - r;
                    break;
                case Et:
                    a = t + i[n = i.length - 2] - i[n + 1];
                    break;
                default:
                    n = e,
                    a = r
                }
            if (void 0 === o)
                switch (this.getSettings_().endingEnd) {
                case Tt:
                    s = e,
                    o = 2 * r - t;
                    break;
                case Et:
                    s = 1,
                    o = r + i[1] - i[0];
                    break;
                default:
                    s = e - 1,
                    o = t
                }
            var c = .5 * (r - t)
              , l = this.valueSize;
            this._weightPrev = c / (t - a),
            this._weightNext = c / (o - r),
            this._offsetPrev = n * l,
            this._offsetNext = s * l
        },
        interpolate_: function(e, t, r, i) {
            for (var n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, c = o - a, l = this._offsetPrev, p = this._offsetNext, h = this._weightPrev, u = this._weightNext, d = (r - t) / (i - t), f = d * d, m = f * d, g = -h * m + 2 * h * f - h * d, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * d + 1, y = (-1 - u) * m + (1.5 + u) * f + .5 * d, b = u * m - u * f, w = 0; w !== a; ++w)
                n[w] = g * s[l + w] + v * s[c + w] + y * s[o + w] + b * s[p + w];
            return n
        }
    }),
    Ao.prototype = Object.assign(Object.create(To.prototype), {
        constructor: Ao,
        interpolate_: function(e, t, r, i) {
            for (var n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, c = o - a, l = (r - t) / (i - t), p = 1 - l, h = 0; h !== a; ++h)
                n[h] = s[c + h] * p + s[o + h] * l;
            return n
        }
    }),
    Po.prototype = Object.assign(Object.create(To.prototype), {
        constructor: Po,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Object.assign(Oo, {
        toJSON: function(e) {
            var t, r = e.constructor;
            if (void 0 !== r.toJSON)
                t = r.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: So.convertArray(e.times, Array),
                    values: So.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName,
            t
        }
    }),
    Object.assign(Oo.prototype, {
        constructor: Oo,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: Mt,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new Po(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new Ao(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new Eo(this.times,this.values,this.getValueSize(),e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
            case xt:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case Mt:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case _t:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw new Error(r);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", r),
                this
            }
            return this.createInterpolant = t,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return xt;
            case this.InterpolantFactoryMethodLinear:
                return Mt;
            case this.InterpolantFactoryMethodSmooth:
                return _t
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, r = 0, i = t.length; r !== i; ++r)
                    t[r] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, r = 0, i = t.length; r !== i; ++r)
                    t[r] *= e;
            return this
        },
        trim: function(e, t) {
            for (var r = this.times, i = r.length, n = 0, s = i - 1; n !== i && r[n] < e; )
                ++n;
            for (; -1 !== s && r[s] > t; )
                --s;
            if (++s,
            0 !== n || s !== i) {
                n >= s && (n = (s = Math.max(s, 1)) - 1);
                var a = this.getValueSize();
                this.times = So.arraySlice(r, n, s),
                this.values = So.arraySlice(this.values, n * a, s * a)
            }
            return this
        },
        validate: function() {
            var e = !0
              , t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1);
            var r = this.times
              , i = this.values
              , n = r.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            for (var s = null, a = 0; a !== n; a++) {
                var o = r[a];
                if ("number" == typeof o && isNaN(o)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, o),
                    e = !1;
                    break
                }
                if (null !== s && s > o) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, o, s),
                    e = !1;
                    break
                }
                s = o
            }
            if (void 0 !== i && So.isTypedArray(i)) {
                a = 0;
                for (var c = i.length; a !== c; ++a) {
                    var l = i[a];
                    if (isNaN(l)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l),
                        e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, r = this.getValueSize(), i = this.getInterpolation() === _t, n = 1, s = e.length - 1, a = 1; a < s; ++a) {
                var o = !1
                  , c = e[a];
                if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                    if (i)
                        o = !0;
                    else
                        for (var l = a * r, p = l - r, h = l + r, u = 0; u !== r; ++u) {
                            var d = t[l + u];
                            if (d !== t[p + u] || d !== t[h + u]) {
                                o = !0;
                                break
                            }
                        }
                if (o) {
                    if (a !== n) {
                        e[n] = e[a];
                        var f = a * r
                          , m = n * r;
                        for (u = 0; u !== r; ++u)
                            t[m + u] = t[f + u]
                    }
                    ++n
                }
            }
            if (s > 0) {
                e[n] = e[s];
                for (f = s * r,
                m = n * r,
                u = 0; u !== r; ++u)
                    t[m + u] = t[f + u];
                ++n
            }
            return n !== e.length && (this.times = So.arraySlice(e, 0, n),
            this.values = So.arraySlice(t, 0, n * r)),
            this
        },
        clone: function() {
            var e = So.arraySlice(this.times, 0)
              , t = So.arraySlice(this.values, 0)
              , r = new (0,
            this.constructor)(this.name,e,t);
            return r.createInterpolant = this.createInterpolant,
            r
        }
    }),
    Ro.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: Ro,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: xt,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Co.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: Co,
        ValueTypeName: "color"
    }),
    Lo.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: Lo,
        ValueTypeName: "number"
    }),
    Io.prototype = Object.assign(Object.create(To.prototype), {
        constructor: Io,
        interpolate_: function(e, t, r, i) {
            for (var n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, c = (r - t) / (i - t), l = o + a; o !== l; o += 4)
                Vt.slerpFlat(n, 0, s, o - a, s, o, c);
            return n
        }
    }),
    ko.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: ko,
        ValueTypeName: "quaternion",
        DefaultInterpolation: Mt,
        InterpolantFactoryMethodLinear: function(e) {
            return new Io(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Do.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: Do,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: xt,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    zo.prototype = Object.assign(Object.create(Oo.prototype), {
        constructor: zo,
        ValueTypeName: "vector"
    }),
    Object.assign(Bo, {
        parse: function(e) {
            for (var t = [], r = e.tracks, i = 1 / (e.fps || 1), n = 0, s = r.length; n !== s; ++n)
                t.push(No(r[n]).scale(i));
            return new Bo(e.name,e.duration,t)
        },
        toJSON: function(e) {
            for (var t = [], r = e.tracks, i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            }, n = 0, s = r.length; n !== s; ++n)
                t.push(Oo.toJSON(r[n]));
            return i
        },
        CreateFromMorphTargetSequence: function(e, t, r, i) {
            for (var n = t.length, s = [], a = 0; a < n; a++) {
                var o = []
                  , c = [];
                o.push((a + n - 1) % n, a, (a + 1) % n),
                c.push(0, 1, 0);
                var l = So.getKeyframeOrder(o);
                o = So.sortedArray(o, 1, l),
                c = So.sortedArray(c, 1, l),
                i || 0 !== o[0] || (o.push(n),
                c.push(c[0])),
                s.push(new Lo(".morphTargetInfluences[" + t[a].name + "]",o,c).scale(1 / r))
            }
            return new Bo(e,-1,s)
        },
        findByName: function(e, t) {
            var r = e;
            if (!Array.isArray(e)) {
                var i = e;
                r = i.geometry && i.geometry.animations || i.animations
            }
            for (var n = 0; n < r.length; n++)
                if (r[n].name === t)
                    return r[n];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, r) {
            for (var i = {}, n = /^([\w-]*?)([\d]+)$/, s = 0, a = e.length; s < a; s++) {
                var o = e[s]
                  , c = o.name.match(n);
                if (c && c.length > 1) {
                    var l = i[h = c[1]];
                    l || (i[h] = l = []),
                    l.push(o)
                }
            }
            var p = [];
            for (var h in i)
                p.push(Bo.CreateFromMorphTargetSequence(h, i[h], t, r));
            return p
        },
        parseAnimation: function(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            for (var r = function(e, t, r, i, n) {
                if (0 !== r.length) {
                    var s = []
                      , a = [];
                    So.flattenJSON(r, s, a, i),
                    0 !== s.length && n.push(new e(t,s,a))
                }
            }, i = [], n = e.name || "default", s = e.length || -1, a = e.fps || 30, o = e.hierarchy || [], c = 0; c < o.length; c++) {
                var l = o[c].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        for (var p = {}, h = 0; h < l.length; h++)
                            if (l[h].morphTargets)
                                for (var u = 0; u < l[h].morphTargets.length; u++)
                                    p[l[h].morphTargets[u]] = -1;
                        for (var d in p) {
                            var f = []
                              , m = [];
                            for (u = 0; u !== l[h].morphTargets.length; ++u) {
                                var g = l[h];
                                f.push(g.time),
                                m.push(g.morphTarget === d ? 1 : 0)
                            }
                            i.push(new Lo(".morphTargetInfluence[" + d + "]",f,m))
                        }
                        s = p.length * (a || 1)
                    } else {
                        var v = ".bones[" + t[c].name + "]";
                        r(zo, v + ".position", l, "pos", i),
                        r(ko, v + ".quaternion", l, "rot", i),
                        r(zo, v + ".scale", l, "scl", i)
                    }
            }
            return 0 === i.length ? null : new Bo(n,s,i)
        }
    }),
    Object.assign(Bo.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, r = this.tracks.length; t !== r; ++t) {
                var i = this.tracks[t];
                e = Math.max(e, i.times[i.times.length - 1])
            }
            return this.duration = e,
            this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new Bo(this.name,this.duration,e)
        }
    });
    var jo = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    function Fo(e, t, r) {
        var i = this
          , n = !1
          , s = 0
          , a = 0
          , o = void 0;
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(e) {
            a++,
            !1 === n && void 0 !== i.onStart && i.onStart(e, s, a),
            n = !0
        }
        ,
        this.itemEnd = function(e) {
            s++,
            void 0 !== i.onProgress && i.onProgress(e, s, a),
            s === a && (n = !1,
            void 0 !== i.onLoad && i.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== i.onError && i.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return o ? o(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return o = e,
            this
        }
    }
    var Uo = new Fo
      , Go = {};
    function Ho(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function Vo(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function Wo(e) {
        this.manager = void 0 !== e ? e : Uo,
        this._parser = null
    }
    function Yo(e) {
        this.manager = void 0 !== e ? e : Uo,
        this._parser = null
    }
    function Zo(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function Xo(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function qo(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function Jo() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Ko(e, t, r, i, n, s, a, o) {
        Jo.call(this),
        this.type = "EllipseCurve",
        this.aX = e || 0,
        this.aY = t || 0,
        this.xRadius = r || 1,
        this.yRadius = i || 1,
        this.aStartAngle = n || 0,
        this.aEndAngle = s || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = o || 0
    }
    function Qo(e, t, r, i, n, s) {
        Ko.call(this, e, t, r, r, i, n, s),
        this.type = "ArcCurve"
    }
    function $o() {
        var e = 0
          , t = 0
          , r = 0
          , i = 0;
        function n(n, s, a, o) {
            e = n,
            t = a,
            r = -3 * n + 3 * s - 2 * a - o,
            i = 2 * n - 2 * s + a + o
        }
        return {
            initCatmullRom: function(e, t, r, i, s) {
                n(t, r, s * (r - e), s * (i - t))
            },
            initNonuniformCatmullRom: function(e, t, r, i, s, a, o) {
                var c = (t - e) / s - (r - e) / (s + a) + (r - t) / a
                  , l = (r - t) / a - (i - t) / (a + o) + (i - r) / o;
                n(t, r, c *= a, l *= a)
            },
            calc: function(n) {
                var s = n * n;
                return e + t * n + r * s + i * (s * n)
            }
        }
    }
    Object.assign(Ho.prototype, {
        load: function(e, t, r, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var n = this
              , s = jo.get(e);
            if (void 0 !== s)
                return n.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    n.manager.itemEnd(e)
                }, 0),
                s;
            if (void 0 === Go[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var o = a[1]
                      , c = !!a[2]
                      , l = a[3];
                    l = decodeURIComponent(l),
                    c && (l = atob(l));
                    try {
                        var p, h = (this.responseType || "").toLowerCase();
                        switch (h) {
                        case "arraybuffer":
                        case "blob":
                            for (var u = new Uint8Array(l.length), d = 0; d < l.length; d++)
                                u[d] = l.charCodeAt(d);
                            p = "blob" === h ? new Blob([u.buffer],{
                                type: o
                            }) : u.buffer;
                            break;
                        case "document":
                            var f = new DOMParser;
                            p = f.parseFromString(l, o);
                            break;
                        case "json":
                            p = JSON.parse(l);
                            break;
                        default:
                            p = l
                        }
                        setTimeout(function() {
                            t && t(p),
                            n.manager.itemEnd(e)
                        }, 0)
                    } catch (t) {
                        setTimeout(function() {
                            i && i(t),
                            n.manager.itemError(e),
                            n.manager.itemEnd(e)
                        }, 0)
                    }
                } else {
                    Go[e] = [],
                    Go[e].push({
                        onLoad: t,
                        onProgress: r,
                        onError: i
                    });
                    var m = new XMLHttpRequest;
                    for (var g in m.open("GET", e, !0),
                    m.addEventListener("load", function(t) {
                        var r = this.response;
                        jo.add(e, r);
                        var i = Go[e];
                        if (delete Go[e],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var s = 0, a = i.length; s < a; s++) {
                                (o = i[s]).onLoad && o.onLoad(r)
                            }
                            n.manager.itemEnd(e)
                        } else {
                            for (s = 0,
                            a = i.length; s < a; s++) {
                                var o;
                                (o = i[s]).onError && o.onError(t)
                            }
                            n.manager.itemError(e),
                            n.manager.itemEnd(e)
                        }
                    }, !1),
                    m.addEventListener("progress", function(t) {
                        for (var r = Go[e], i = 0, n = r.length; i < n; i++) {
                            var s = r[i];
                            s.onProgress && s.onProgress(t)
                        }
                    }, !1),
                    m.addEventListener("error", function(t) {
                        var r = Go[e];
                        delete Go[e];
                        for (var i = 0, s = r.length; i < s; i++) {
                            var a = r[i];
                            a.onError && a.onError(t)
                        }
                        n.manager.itemError(e),
                        n.manager.itemEnd(e)
                    }, !1),
                    m.addEventListener("abort", function(t) {
                        var r = Go[e];
                        delete Go[e];
                        for (var i = 0, s = r.length; i < s; i++) {
                            var a = r[i];
                            a.onError && a.onError(t)
                        }
                        n.manager.itemError(e),
                        n.manager.itemEnd(e)
                    }, !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        m.setRequestHeader(g, this.requestHeader[g]);
                    m.send(null)
                }
                return n.manager.itemStart(e),
                m
            }
            Go[e].push({
                onLoad: t,
                onProgress: r,
                onError: i
            })
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    }),
    Object.assign(Vo.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = new Ho(n.manager);
            s.setPath(n.path),
            s.load(e, function(e) {
                t(n.parse(JSON.parse(e)))
            }, r, i)
        },
        parse: function(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var i = Bo.parse(e[r]);
                t.push(i)
            }
            return t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Wo.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = []
              , a = new Js;
            a.image = s;
            var o = new Ho(this.manager);
            function c(c) {
                o.load(e[c], function(e) {
                    var r = n._parser(e, !0);
                    s[c] = {
                        width: r.width,
                        height: r.height,
                        format: r.format,
                        mipmaps: r.mipmaps
                    },
                    6 === (l += 1) && (1 === r.mipmapCount && (a.minFilter = Te),
                    a.format = r.format,
                    a.needsUpdate = !0,
                    t && t(a))
                }, r, i)
            }
            if (o.setPath(this.path),
            o.setResponseType("arraybuffer"),
            Array.isArray(e))
                for (var l = 0, p = 0, h = e.length; p < h; ++p)
                    c(p);
            else
                o.load(e, function(e) {
                    var r = n._parser(e, !0);
                    if (r.isCubemap)
                        for (var i = r.mipmaps.length / r.mipmapCount, o = 0; o < i; o++) {
                            s[o] = {
                                mipmaps: []
                            };
                            for (var c = 0; c < r.mipmapCount; c++)
                                s[o].mipmaps.push(r.mipmaps[o * r.mipmapCount + c]),
                                s[o].format = r.format,
                                s[o].width = r.width,
                                s[o].height = r.height
                        }
                    else
                        a.image.width = r.width,
                        a.image.height = r.height,
                        a.mipmaps = r.mipmaps;
                    1 === r.mipmapCount && (a.minFilter = Te),
                    a.format = r.format,
                    a.needsUpdate = !0,
                    t && t(a)
                }, r, i);
            return a
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Yo.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = new fr
              , a = new Ho(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.load(e, function(e) {
                var r = n._parser(e);
                r && (void 0 !== r.image ? s.image = r.image : void 0 !== r.data && (s.image.width = r.width,
                s.image.height = r.height,
                s.image.data = r.data),
                s.wrapS = void 0 !== r.wrapS ? r.wrapS : we,
                s.wrapT = void 0 !== r.wrapT ? r.wrapT : we,
                s.magFilter = void 0 !== r.magFilter ? r.magFilter : Te,
                s.minFilter = void 0 !== r.minFilter ? r.minFilter : Ae,
                s.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1,
                void 0 !== r.format && (s.format = r.format),
                void 0 !== r.type && (s.type = r.type),
                void 0 !== r.mipmaps && (s.mipmaps = r.mipmaps),
                1 === r.mipmapCount && (s.minFilter = Te),
                s.needsUpdate = !0,
                t && t(s, r))
            }, r, i),
            s
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Zo.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var n = this
              , s = jo.get(e);
            if (void 0 !== s)
                return n.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    n.manager.itemEnd(e)
                }, 0),
                s;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function o() {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", c, !1),
                jo.add(e, this),
                t && t(this),
                n.manager.itemEnd(e)
            }
            function c(t) {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", c, !1),
                i && i(t),
                n.manager.itemError(e),
                n.manager.itemEnd(e)
            }
            return a.addEventListener("load", o, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            n.manager.itemStart(e),
            a.src = e,
            a
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Xo.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, i) {
            var n = new Vi
              , s = new Zo(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            var a = 0;
            function o(r) {
                s.load(e[r], function(e) {
                    n.images[r] = e,
                    6 === ++a && (n.needsUpdate = !0,
                    t && t(n))
                }, void 0, i)
            }
            for (var c = 0; c < e.length; ++c)
                o(c);
            return n
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(qo.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, i) {
            var n = new lr
              , s = new Zo(this.manager);
            return s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(e, function(r) {
                n.image = r;
                var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                n.format = i ? Ue : Ge,
                n.needsUpdate = !0,
                void 0 !== t && t(n)
            }, r, i),
            n
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Jo.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(e, t) {
            var r = this.getUtoTmapping(e);
            return this.getPoint(r, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPointAt(r / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, r, i = [], n = this.getPoint(0), s = 0;
            for (i.push(0),
            r = 1; r <= e; r++)
                s += (t = this.getPoint(r / e)).distanceTo(n),
                i.push(s),
                n = t;
            return this.cacheArcLengths = i,
            i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var r, i = this.getLengths(), n = 0, s = i.length;
            r = t || e * i[s - 1];
            for (var a, o = 0, c = s - 1; o <= c; )
                if ((a = i[n = Math.floor(o + (c - o) / 2)] - r) < 0)
                    o = n + 1;
                else {
                    if (!(a > 0)) {
                        c = n;
                        break
                    }
                    c = n - 1
                }
            if (i[n = c] === r)
                return n / (s - 1);
            var l = i[n];
            return (n + (r - l) / (i[n + 1] - l)) / (s - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4
              , r = e + 1e-4;
            t < 0 && (t = 0),
            r > 1 && (r = 1);
            var i = this.getPoint(t);
            return this.getPoint(r).clone().sub(i).normalize()
        },
        getTangentAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function(e, t) {
            var r, i, n, s = new Wt, a = [], o = [], c = [], l = new Wt, p = new br;
            for (r = 0; r <= e; r++)
                i = r / e,
                a[r] = this.getTangentAt(i),
                a[r].normalize();
            o[0] = new Wt,
            c[0] = new Wt;
            var h = Number.MAX_VALUE
              , u = Math.abs(a[0].x)
              , d = Math.abs(a[0].y)
              , f = Math.abs(a[0].z);
            for (u <= h && (h = u,
            s.set(1, 0, 0)),
            d <= h && (h = d,
            s.set(0, 1, 0)),
            f <= h && s.set(0, 0, 1),
            l.crossVectors(a[0], s).normalize(),
            o[0].crossVectors(a[0], l),
            c[0].crossVectors(a[0], o[0]),
            r = 1; r <= e; r++)
                o[r] = o[r - 1].clone(),
                c[r] = c[r - 1].clone(),
                l.crossVectors(a[r - 1], a[r]),
                l.length() > Number.EPSILON && (l.normalize(),
                n = Math.acos(Gt.clamp(a[r - 1].dot(a[r]), -1, 1)),
                o[r].applyMatrix4(p.makeRotationAxis(l, n))),
                c[r].crossVectors(a[r], o[r]);
            if (!0 === t)
                for (n = Math.acos(Gt.clamp(o[0].dot(o[e]), -1, 1)),
                n /= e,
                a[0].dot(l.crossVectors(o[0], o[e])) > 0 && (n = -n),
                r = 1; r <= e; r++)
                    o[r].applyMatrix4(p.makeRotationAxis(a[r], n * r)),
                    c[r].crossVectors(a[r], o[r]);
            return {
                tangents: a,
                normals: o,
                binormals: c
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }),
    Ko.prototype = Object.create(Jo.prototype),
    Ko.prototype.constructor = Ko,
    Ko.prototype.isEllipseCurve = !0,
    Ko.prototype.getPoint = function(e, t) {
        for (var r = t || new Ht, i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, s = Math.abs(n) < Number.EPSILON; n < 0; )
            n += i;
        for (; n > i; )
            n -= i;
        n < Number.EPSILON && (n = s ? 0 : i),
        !0 !== this.aClockwise || s || (n === i ? n = -i : n -= i);
        var a = this.aStartAngle + e * n
          , o = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var l = Math.cos(this.aRotation)
              , p = Math.sin(this.aRotation)
              , h = o - this.aX
              , u = c - this.aY;
            o = h * l - u * p + this.aX,
            c = h * p + u * l + this.aY
        }
        return r.set(o, c)
    }
    ,
    Ko.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Ko.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    ,
    Ko.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Qo.prototype = Object.create(Ko.prototype),
    Qo.prototype.constructor = Qo,
    Qo.prototype.isArcCurve = !0;
    var ec = new Wt
      , tc = new $o
      , rc = new $o
      , ic = new $o;
    function nc(e, t, r, i) {
        Jo.call(this),
        this.type = "CatmullRomCurve3",
        this.points = e || [],
        this.closed = t || !1,
        this.curveType = r || "centripetal",
        this.tension = i || .5
    }
    function sc(e, t, r, i, n) {
        var s = .5 * (i - t)
          , a = .5 * (n - r)
          , o = e * e;
        return (2 * r - 2 * i + s + a) * (e * o) + (-3 * r + 3 * i - 2 * s - a) * o + s * e + r
    }
    function ac(e, t, r, i) {
        return function(e, t) {
            var r = 1 - e;
            return r * r * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, r) + function(e, t) {
            return e * e * t
        }(e, i)
    }
    function oc(e, t, r, i, n) {
        return function(e, t) {
            var r = 1 - e;
            return r * r * r * t
        }(e, t) + function(e, t) {
            var r = 1 - e;
            return 3 * r * r * e * t
        }(e, r) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, i) + function(e, t) {
            return e * e * e * t
        }(e, n)
    }
    function cc(e, t, r, i) {
        Jo.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = e || new Ht,
        this.v1 = t || new Ht,
        this.v2 = r || new Ht,
        this.v3 = i || new Ht
    }
    function lc(e, t, r, i) {
        Jo.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = e || new Wt,
        this.v1 = t || new Wt,
        this.v2 = r || new Wt,
        this.v3 = i || new Wt
    }
    function pc(e, t) {
        Jo.call(this),
        this.type = "LineCurve",
        this.v1 = e || new Ht,
        this.v2 = t || new Ht
    }
    function hc(e, t) {
        Jo.call(this),
        this.type = "LineCurve3",
        this.v1 = e || new Wt,
        this.v2 = t || new Wt
    }
    function uc(e, t, r) {
        Jo.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = e || new Ht,
        this.v1 = t || new Ht,
        this.v2 = r || new Ht
    }
    function dc(e, t, r) {
        Jo.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = e || new Wt,
        this.v1 = t || new Wt,
        this.v2 = r || new Wt
    }
    function fc(e) {
        Jo.call(this),
        this.type = "SplineCurve",
        this.points = e || []
    }
    nc.prototype = Object.create(Jo.prototype),
    nc.prototype.constructor = nc,
    nc.prototype.isCatmullRomCurve3 = !0,
    nc.prototype.getPoint = function(e, t) {
        var r, i, n, s, a = t || new Wt, o = this.points, c = o.length, l = (c - (this.closed ? 0 : 1)) * e, p = Math.floor(l), h = l - p;
        if (this.closed ? p += p > 0 ? 0 : (Math.floor(Math.abs(p) / c) + 1) * c : 0 === h && p === c - 1 && (p = c - 2,
        h = 1),
        this.closed || p > 0 ? r = o[(p - 1) % c] : (ec.subVectors(o[0], o[1]).add(o[0]),
        r = ec),
        i = o[p % c],
        n = o[(p + 1) % c],
        this.closed || p + 2 < c ? s = o[(p + 2) % c] : (ec.subVectors(o[c - 1], o[c - 2]).add(o[c - 1]),
        s = ec),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var u = "chordal" === this.curveType ? .5 : .25
              , d = Math.pow(r.distanceToSquared(i), u)
              , f = Math.pow(i.distanceToSquared(n), u)
              , m = Math.pow(n.distanceToSquared(s), u);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            tc.initNonuniformCatmullRom(r.x, i.x, n.x, s.x, d, f, m),
            rc.initNonuniformCatmullRom(r.y, i.y, n.y, s.y, d, f, m),
            ic.initNonuniformCatmullRom(r.z, i.z, n.z, s.z, d, f, m)
        } else
            "catmullrom" === this.curveType && (tc.initCatmullRom(r.x, i.x, n.x, s.x, this.tension),
            rc.initCatmullRom(r.y, i.y, n.y, s.y, this.tension),
            ic.initCatmullRom(r.z, i.z, n.z, s.z, this.tension));
        return a.set(tc.calc(h), rc.calc(h), ic.calc(h)),
        a
    }
    ,
    nc.prototype.copy = function(e) {
        Jo.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    nc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, r = this.points.length; t < r; t++) {
            var i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    ,
    nc.prototype.fromJSON = function(e) {
        Jo.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var i = e.points[t];
            this.points.push((new Wt).fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    cc.prototype = Object.create(Jo.prototype),
    cc.prototype.constructor = cc,
    cc.prototype.isCubicBezierCurve = !0,
    cc.prototype.getPoint = function(e, t) {
        var r = t || new Ht
          , i = this.v0
          , n = this.v1
          , s = this.v2
          , a = this.v3;
        return r.set(oc(e, i.x, n.x, s.x, a.x), oc(e, i.y, n.y, s.y, a.y)),
        r
    }
    ,
    cc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    cc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    cc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    lc.prototype = Object.create(Jo.prototype),
    lc.prototype.constructor = lc,
    lc.prototype.isCubicBezierCurve3 = !0,
    lc.prototype.getPoint = function(e, t) {
        var r = t || new Wt
          , i = this.v0
          , n = this.v1
          , s = this.v2
          , a = this.v3;
        return r.set(oc(e, i.x, n.x, s.x, a.x), oc(e, i.y, n.y, s.y, a.y), oc(e, i.z, n.z, s.z, a.z)),
        r
    }
    ,
    lc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    lc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    lc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    pc.prototype = Object.create(Jo.prototype),
    pc.prototype.constructor = pc,
    pc.prototype.isLineCurve = !0,
    pc.prototype.getPoint = function(e, t) {
        var r = t || new Ht;
        return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    ,
    pc.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    pc.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    pc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    pc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    pc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    hc.prototype = Object.create(Jo.prototype),
    hc.prototype.constructor = hc,
    hc.prototype.isLineCurve3 = !0,
    hc.prototype.getPoint = function(e, t) {
        var r = t || new Wt;
        return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    ,
    hc.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    hc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    hc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    hc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    uc.prototype = Object.create(Jo.prototype),
    uc.prototype.constructor = uc,
    uc.prototype.isQuadraticBezierCurve = !0,
    uc.prototype.getPoint = function(e, t) {
        var r = t || new Ht
          , i = this.v0
          , n = this.v1
          , s = this.v2;
        return r.set(ac(e, i.x, n.x, s.x), ac(e, i.y, n.y, s.y)),
        r
    }
    ,
    uc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    uc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    uc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    dc.prototype = Object.create(Jo.prototype),
    dc.prototype.constructor = dc,
    dc.prototype.isQuadraticBezierCurve3 = !0,
    dc.prototype.getPoint = function(e, t) {
        var r = t || new Wt
          , i = this.v0
          , n = this.v1
          , s = this.v2;
        return r.set(ac(e, i.x, n.x, s.x), ac(e, i.y, n.y, s.y), ac(e, i.z, n.z, s.z)),
        r
    }
    ,
    dc.prototype.copy = function(e) {
        return Jo.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    dc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    dc.prototype.fromJSON = function(e) {
        return Jo.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    fc.prototype = Object.create(Jo.prototype),
    fc.prototype.constructor = fc,
    fc.prototype.isSplineCurve = !0,
    fc.prototype.getPoint = function(e, t) {
        var r = t || new Ht
          , i = this.points
          , n = (i.length - 1) * e
          , s = Math.floor(n)
          , a = n - s
          , o = i[0 === s ? s : s - 1]
          , c = i[s]
          , l = i[s > i.length - 2 ? i.length - 1 : s + 1]
          , p = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return r.set(sc(a, o.x, c.x, l.x, p.x), sc(a, o.y, c.y, l.y, p.y)),
        r
    }
    ,
    fc.prototype.copy = function(e) {
        Jo.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    ,
    fc.prototype.toJSON = function() {
        var e = Jo.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, r = this.points.length; t < r; t++) {
            var i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    ,
    fc.prototype.fromJSON = function(e) {
        Jo.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var i = e.points[t];
            this.points.push((new Ht).fromArray(i))
        }
        return this
    }
    ;
    var mc = Object.freeze({
        ArcCurve: Qo,
        CatmullRomCurve3: nc,
        CubicBezierCurve: cc,
        CubicBezierCurve3: lc,
        EllipseCurve: Ko,
        LineCurve: pc,
        LineCurve3: hc,
        QuadraticBezierCurve: uc,
        QuadraticBezierCurve3: dc,
        SplineCurve: fc
    });
    function gc() {
        Jo.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function vc(e) {
        gc.call(this),
        this.type = "Path",
        this.currentPoint = new Ht,
        e && this.setFromPoints(e)
    }
    function yc(e) {
        vc.call(this, e),
        this.uuid = Gt.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function bc(e, t) {
        Hr.call(this),
        this.type = "Light",
        this.color = new Pr(e),
        this.intensity = void 0 !== t ? t : 1,
        this.receiveShadow = void 0
    }
    function wc(e, t, r) {
        bc.call(this, e, r),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(Hr.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new Pr(t)
    }
    function xc(e) {
        this.camera = e,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new Ht(512,512),
        this.map = null,
        this.matrix = new br
    }
    function Mc() {
        xc.call(this, new ys(50,1,.5,500))
    }
    function _c(e, t, r, i, n, s) {
        bc.call(this, e, t),
        this.type = "SpotLight",
        this.position.copy(Hr.DefaultUp),
        this.updateMatrix(),
        this.target = new Hr,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }),
        this.distance = void 0 !== r ? r : 0,
        this.angle = void 0 !== i ? i : Math.PI / 3,
        this.penumbra = void 0 !== n ? n : 0,
        this.decay = void 0 !== s ? s : 1,
        this.shadow = new Mc
    }
    function Sc(e, t, r, i) {
        bc.call(this, e, t),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== r ? r : 0,
        this.decay = void 0 !== i ? i : 1,
        this.shadow = new xc(new ys(90,1,.5,500))
    }
    function Tc(e, t, r, i, n, s) {
        vs.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== e ? e : -1,
        this.right = void 0 !== t ? t : 1,
        this.top = void 0 !== r ? r : 1,
        this.bottom = void 0 !== i ? i : -1,
        this.near = void 0 !== n ? n : .1,
        this.far = void 0 !== s ? s : 2e3,
        this.updateProjectionMatrix()
    }
    function Ec() {
        xc.call(this, new Tc(-5,5,5,-5,.5,500))
    }
    function Ac(e, t) {
        bc.call(this, e, t),
        this.type = "DirectionalLight",
        this.position.copy(Hr.DefaultUp),
        this.updateMatrix(),
        this.target = new Hr,
        this.shadow = new Ec
    }
    function Pc(e, t) {
        bc.call(this, e, t),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function Oc(e, t, r, i) {
        bc.call(this, e, t),
        this.type = "RectAreaLight",
        this.width = void 0 !== r ? r : 10,
        this.height = void 0 !== i ? i : 10
    }
    function Rc(e) {
        this.manager = void 0 !== e ? e : Uo,
        this.textures = {}
    }
    gc.prototype = Object.assign(Object.create(Jo.prototype), {
        constructor: gc,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new pc(t,e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), r = this.getCurveLengths(), i = 0; i < r.length; ) {
                if (r[i] >= t) {
                    var n = r[i] - t
                      , s = this.curves[i]
                      , a = s.getLength()
                      , o = 0 === a ? 0 : 1 - n / a;
                    return s.getPointAt(o)
                }
                i++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, r = 0, i = this.curves.length; r < i; r++)
                t += this.curves[r].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return this.autoClose && t.push(t[0]),
            t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, r = [], i = 0, n = this.curves; i < n.length; i++)
                for (var s = n[i], a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e, o = s.getPoints(a), c = 0; c < o.length; c++) {
                    var l = o[c];
                    t && t.equals(l) || (r.push(l),
                    t = l)
                }
            return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]),
            r
        },
        copy: function(e) {
            Jo.prototype.copy.call(this, e),
            this.curves = [];
            for (var t = 0, r = e.curves.length; t < r; t++) {
                var i = e.curves[t];
                this.curves.push(i.clone())
            }
            return this.autoClose = e.autoClose,
            this
        },
        toJSON: function() {
            var e = Jo.prototype.toJSON.call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, r = this.curves.length; t < r; t++) {
                var i = this.curves[t];
                e.curves.push(i.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            Jo.prototype.fromJSON.call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, r = e.curves.length; t < r; t++) {
                var i = e.curves[t];
                this.curves.push((new mc[i.type]).fromJSON(i))
            }
            return this
        }
    }),
    vc.prototype = Object.assign(Object.create(gc.prototype), {
        constructor: vc,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, r = e.length; t < r; t++)
                this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var r = new pc(this.currentPoint.clone(),new Ht(e,t));
            this.curves.push(r),
            this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, r, i) {
            var n = new uc(this.currentPoint.clone(),new Ht(e,t),new Ht(r,i));
            this.curves.push(n),
            this.currentPoint.set(r, i)
        },
        bezierCurveTo: function(e, t, r, i, n, s) {
            var a = new cc(this.currentPoint.clone(),new Ht(e,t),new Ht(r,i),new Ht(n,s));
            this.curves.push(a),
            this.currentPoint.set(n, s)
        },
        splineThru: function(e) {
            var t = new fc([this.currentPoint.clone()].concat(e));
            this.curves.push(t),
            this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, r, i, n, s) {
            var a = this.currentPoint.x
              , o = this.currentPoint.y;
            this.absarc(e + a, t + o, r, i, n, s)
        },
        absarc: function(e, t, r, i, n, s) {
            this.absellipse(e, t, r, r, i, n, s)
        },
        ellipse: function(e, t, r, i, n, s, a, o) {
            var c = this.currentPoint.x
              , l = this.currentPoint.y;
            this.absellipse(e + c, t + l, r, i, n, s, a, o)
        },
        absellipse: function(e, t, r, i, n, s, a, o) {
            var c = new Ko(e,t,r,i,n,s,a,o);
            if (this.curves.length > 0) {
                var l = c.getPoint(0);
                l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
            }
            this.curves.push(c);
            var p = c.getPoint(1);
            this.currentPoint.copy(p)
        },
        copy: function(e) {
            return gc.prototype.copy.call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        },
        toJSON: function() {
            var e = gc.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        },
        fromJSON: function(e) {
            return gc.prototype.fromJSON.call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }),
    yc.prototype = Object.assign(Object.create(vc.prototype), {
        constructor: yc,
        getPointsHoles: function(e) {
            for (var t = [], r = 0, i = this.holes.length; r < i; r++)
                t[r] = this.holes[r].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            vc.prototype.copy.call(this, e),
            this.holes = [];
            for (var t = 0, r = e.holes.length; t < r; t++) {
                var i = e.holes[t];
                this.holes.push(i.clone())
            }
            return this
        },
        toJSON: function() {
            var e = vc.prototype.toJSON.call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, r = this.holes.length; t < r; t++) {
                var i = this.holes[t];
                e.holes.push(i.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            vc.prototype.fromJSON.call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, r = e.holes.length; t < r; t++) {
                var i = e.holes[t];
                this.holes.push((new vc).fromJSON(i))
            }
            return this
        }
    }),
    bc.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: bc,
        isLight: !0,
        copy: function(e) {
            return Hr.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            var t = Hr.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    wc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: wc,
        isHemisphereLight: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }),
    Object.assign(xc.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }),
    Mc.prototype = Object.assign(Object.create(xc.prototype), {
        constructor: Mc,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera
              , r = 2 * Gt.RAD2DEG * e.angle
              , i = this.mapSize.width / this.mapSize.height
              , n = e.distance || t.far;
            r === t.fov && i === t.aspect && n === t.far || (t.fov = r,
            t.aspect = i,
            t.far = n,
            t.updateProjectionMatrix())
        }
    }),
    _c.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: _c,
        isSpotLight: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Sc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Sc,
        isPointLight: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Tc.prototype = Object.assign(Object.create(vs.prototype), {
        constructor: Tc,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return vs.prototype.copy.call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        },
        setViewOffset: function(e, t, r, i, n, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = i,
            this.view.width = n,
            this.view.height = s,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , r = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2
              , n = r - e
              , s = r + e
              , a = i + t
              , o = i - t;
            if (null !== this.view && this.view.enabled) {
                var c = this.zoom / (this.view.width / this.view.fullWidth)
                  , l = this.zoom / (this.view.height / this.view.fullHeight)
                  , p = (this.right - this.left) / this.view.width
                  , h = (this.top - this.bottom) / this.view.height;
                s = (n += p * (this.view.offsetX / c)) + p * (this.view.width / c),
                o = (a -= h * (this.view.offsetY / l)) - h * (this.view.height / l)
            }
            this.projectionMatrix.makeOrthographic(n, s, a, o, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Hr.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    Ec.prototype = Object.assign(Object.create(xc.prototype), {
        constructor: Ec
    }),
    Ac.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Ac,
        isDirectionalLight: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Pc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Pc,
        isAmbientLight: !0
    }),
    Oc.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: Oc,
        isRectAreaLight: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        },
        toJSON: function(e) {
            var t = bc.prototype.toJSON.call(this, e);
            return t.object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Object.assign(Rc.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = new Ho(n.manager);
            s.setPath(n.path),
            s.load(e, function(e) {
                t(n.parse(JSON.parse(e)))
            }, r, i)
        },
        parse: function(e) {
            var t = this.textures;
            function r(e) {
                return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                t[e]
            }
            var i = new _o[e.type];
            if (void 0 !== e.uuid && (i.uuid = e.uuid),
            void 0 !== e.name && (i.name = e.name),
            void 0 !== e.color && i.color.setHex(e.color),
            void 0 !== e.roughness && (i.roughness = e.roughness),
            void 0 !== e.metalness && (i.metalness = e.metalness),
            void 0 !== e.emissive && i.emissive.setHex(e.emissive),
            void 0 !== e.specular && i.specular.setHex(e.specular),
            void 0 !== e.shininess && (i.shininess = e.shininess),
            void 0 !== e.clearCoat && (i.clearCoat = e.clearCoat),
            void 0 !== e.clearCoatRoughness && (i.clearCoatRoughness = e.clearCoatRoughness),
            void 0 !== e.vertexColors && (i.vertexColors = e.vertexColors),
            void 0 !== e.fog && (i.fog = e.fog),
            void 0 !== e.flatShading && (i.flatShading = e.flatShading),
            void 0 !== e.blending && (i.blending = e.blending),
            void 0 !== e.combine && (i.combine = e.combine),
            void 0 !== e.side && (i.side = e.side),
            void 0 !== e.opacity && (i.opacity = e.opacity),
            void 0 !== e.transparent && (i.transparent = e.transparent),
            void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
            void 0 !== e.depthTest && (i.depthTest = e.depthTest),
            void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
            void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
            void 0 !== e.wireframe && (i.wireframe = e.wireframe),
            void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth),
            void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap),
            void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin),
            void 0 !== e.rotation && (i.rotation = e.rotation),
            1 !== e.linewidth && (i.linewidth = e.linewidth),
            void 0 !== e.dashSize && (i.dashSize = e.dashSize),
            void 0 !== e.gapSize && (i.gapSize = e.gapSize),
            void 0 !== e.scale && (i.scale = e.scale),
            void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
            void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor),
            void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== e.skinning && (i.skinning = e.skinning),
            void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets),
            void 0 !== e.dithering && (i.dithering = e.dithering),
            void 0 !== e.visible && (i.visible = e.visible),
            void 0 !== e.userData && (i.userData = e.userData),
            void 0 !== e.uniforms)
                for (var n in e.uniforms) {
                    var s = e.uniforms[n];
                    switch (i.uniforms[n] = {},
                    s.type) {
                    case "t":
                        i.uniforms[n].value = r(s.value);
                        break;
                    case "c":
                        i.uniforms[n].value = (new Pr).setHex(s.value);
                        break;
                    case "v2":
                        i.uniforms[n].value = (new Ht).fromArray(s.value);
                        break;
                    case "v3":
                        i.uniforms[n].value = (new Wt).fromArray(s.value);
                        break;
                    case "v4":
                        i.uniforms[n].value = (new pr).fromArray(s.value);
                        break;
                    case "m3":
                        i.uniforms[n].value = (new Yt).fromArray(s.value);
                    case "m4":
                        i.uniforms[n].value = (new br).fromArray(s.value);
                        break;
                    default:
                        i.uniforms[n].value = s.value
                    }
                }
            if (void 0 !== e.defines && (i.defines = e.defines),
            void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader),
            void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader),
            void 0 !== e.extensions)
                for (var a in e.extensions)
                    i.extensions[a] = e.extensions[a];
            if (void 0 !== e.shading && (i.flatShading = 1 === e.shading),
            void 0 !== e.size && (i.size = e.size),
            void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation),
            void 0 !== e.map && (i.map = r(e.map)),
            void 0 !== e.matcap && (i.matcap = r(e.matcap)),
            void 0 !== e.alphaMap && (i.alphaMap = r(e.alphaMap),
            i.transparent = !0),
            void 0 !== e.bumpMap && (i.bumpMap = r(e.bumpMap)),
            void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
            void 0 !== e.normalMap && (i.normalMap = r(e.normalMap)),
            void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
            void 0 !== e.normalScale) {
                var o = e.normalScale;
                !1 === Array.isArray(o) && (o = [o, o]),
                i.normalScale = (new Ht).fromArray(o)
            }
            return void 0 !== e.displacementMap && (i.displacementMap = r(e.displacementMap)),
            void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale),
            void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias),
            void 0 !== e.roughnessMap && (i.roughnessMap = r(e.roughnessMap)),
            void 0 !== e.metalnessMap && (i.metalnessMap = r(e.metalnessMap)),
            void 0 !== e.emissiveMap && (i.emissiveMap = r(e.emissiveMap)),
            void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity),
            void 0 !== e.specularMap && (i.specularMap = r(e.specularMap)),
            void 0 !== e.envMap && (i.envMap = r(e.envMap)),
            void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity),
            void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
            void 0 !== e.lightMap && (i.lightMap = r(e.lightMap)),
            void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity),
            void 0 !== e.aoMap && (i.aoMap = r(e.aoMap)),
            void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity),
            void 0 !== e.gradientMap && (i.gradientMap = r(e.gradientMap)),
            i
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setTextures: function(e) {
            return this.textures = e,
            this
        }
    });
    var Cc = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(e);
            for (var t = "", r = 0, i = e.length; r < i; r++)
                t += String.fromCharCode(e[r]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };
    function Lc() {
        oi.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function Ic(e, t, r, i) {
        "number" == typeof r && (i = r,
        r = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        Xr.call(this, e, t, r),
        this.meshPerAttribute = i || 1
    }
    function kc(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    Lc.prototype = Object.assign(Object.create(oi.prototype), {
        constructor: Lc,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return oi.prototype.copy.call(this, e),
            this.maxInstancedCount = e.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = oi.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount,
            e.isInstancedBufferGeometry = !0,
            e
        }
    }),
    Ic.prototype = Object.assign(Object.create(Xr.prototype), {
        constructor: Ic,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return Xr.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        },
        toJSON: function() {
            var e = Xr.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute,
            e.isInstancedBufferAttribute = !0,
            e
        }
    }),
    Object.assign(kc.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = new Ho(n.manager);
            s.setPath(n.path),
            s.load(e, function(e) {
                t(n.parse(JSON.parse(e)))
            }, r, i)
        },
        parse: function(e) {
            var t = e.isInstancedBufferGeometry ? new Lc : new oi
              , r = e.data.index;
            if (void 0 !== r) {
                var i = new Dc[r.type](r.array);
                t.setIndex(new Xr(i,1))
            }
            var n = e.data.attributes;
            for (var s in n) {
                var a = n[s]
                  , o = (i = new Dc[a.type](a.array),
                new (a.isInstancedBufferAttribute ? Ic : Xr)(i,a.itemSize,a.normalized));
                void 0 !== a.name && (o.name = a.name),
                t.addAttribute(s, o)
            }
            var c = e.data.morphAttributes;
            if (c)
                for (var s in c) {
                    for (var l = c[s], p = [], h = 0, u = l.length; h < u; h++) {
                        a = l[h],
                        o = new Xr(i = new Dc[a.type](a.array),a.itemSize,a.normalized);
                        void 0 !== a.name && (o.name = a.name),
                        p.push(o)
                    }
                    t.morphAttributes[s] = p
                }
            var d = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== d) {
                h = 0;
                for (var f = d.length; h !== f; ++h) {
                    var m = d[h];
                    t.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var g = e.data.boundingSphere;
            if (void 0 !== g) {
                var v = new Wt;
                void 0 !== g.center && v.fromArray(g.center),
                t.boundingSphere = new gr(v,g.radius)
            }
            return e.name && (t.name = e.name),
            e.userData && (t.userData = e.userData),
            t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    });
    var Dc = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function zc(e) {
        this.manager = void 0 !== e ? e : Uo,
        this.resourcePath = ""
    }
    Object.assign(zc.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, i) {
            var n = this
              , s = void 0 === this.path ? Cc.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || s;
            var a = new Ho(n.manager);
            a.setPath(this.path),
            a.load(e, function(r) {
                var s = null;
                try {
                    s = JSON.parse(r)
                } catch (t) {
                    return void 0 !== i && i(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                var a = s.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? n.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e)
            }, r, i)
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        parse: function(e, t) {
            var r = this.parseShape(e.shapes)
              , i = this.parseGeometries(e.geometries, r)
              , n = this.parseImages(e.images, function() {
                void 0 !== t && t(o)
            })
              , s = this.parseTextures(e.textures, n)
              , a = this.parseMaterials(e.materials, s)
              , o = this.parseObject(e.object, i, a);
            return e.animations && (o.animations = this.parseAnimations(e.animations)),
            void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(o),
            o
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var r = 0, i = e.length; r < i; r++) {
                    var n = (new yc).fromJSON(e[r]);
                    t[n.uuid] = n
                }
            return t
        },
        parseGeometries: function(e, t) {
            var r = {};
            if (void 0 !== e)
                for (var i = new kc, n = 0, s = e.length; n < s; n++) {
                    var a, o = e[n];
                    switch (o.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        a = new ho[o.type](o.width,o.height,o.widthSegments,o.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        a = new ho[o.type](o.width,o.height,o.depth,o.widthSegments,o.heightSegments,o.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        a = new ho[o.type](o.radius,o.segments,o.thetaStart,o.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        a = new ho[o.type](o.radiusTop,o.radiusBottom,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        a = new ho[o.type](o.radius,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        a = new ho[o.type](o.radius,o.widthSegments,o.heightSegments,o.phiStart,o.phiLength,o.thetaStart,o.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        a = new ho[o.type](o.radius,o.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        a = new ho[o.type](o.innerRadius,o.outerRadius,o.thetaSegments,o.phiSegments,o.thetaStart,o.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        a = new ho[o.type](o.radius,o.tube,o.radialSegments,o.tubularSegments,o.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        a = new ho[o.type](o.radius,o.tube,o.tubularSegments,o.radialSegments,o.p,o.q);
                        break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                        a = new ho[o.type]((new mc[o.path.type]).fromJSON(o.path),o.tubularSegments,o.radius,o.radialSegments,o.closed);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        a = new ho[o.type](o.points,o.segments,o.phiStart,o.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        a = new ho[o.type](o.vertices,o.indices,o.radius,o.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var c = [], l = 0, p = o.shapes.length; l < p; l++) {
                            var h = t[o.shapes[l]];
                            c.push(h)
                        }
                        a = new ho[o.type](c,o.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (c = [],
                        l = 0,
                        p = o.shapes.length; l < p; l++) {
                            h = t[o.shapes[l]];
                            c.push(h)
                        }
                        var u = o.options.extrudePath;
                        void 0 !== u && (o.options.extrudePath = (new mc[u.type]).fromJSON(u)),
                        a = new ho[o.type](c,o.options);
                        break;
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        a = i.parse(o);
                        break;
                    case "Geometry":
                        if ("THREE"in window && "LegacyJSONLoader"in THREE)
                            a = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry;
                        else
                            console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                        continue
                    }
                    a.uuid = o.uuid,
                    void 0 !== o.name && (a.name = o.name),
                    !0 === a.isBufferGeometry && void 0 !== o.userData && (a.userData = o.userData),
                    r[o.uuid] = a
                }
            return r
        },
        parseMaterials: function(e, t) {
            var r = {}
              , i = {};
            if (void 0 !== e) {
                var n = new Rc;
                n.setTextures(t);
                for (var s = 0, a = e.length; s < a; s++) {
                    var o = e[s];
                    if ("MultiMaterial" === o.type) {
                        for (var c = [], l = 0; l < o.materials.length; l++) {
                            var p = o.materials[l];
                            void 0 === r[p.uuid] && (r[p.uuid] = n.parse(p)),
                            c.push(r[p.uuid])
                        }
                        i[o.uuid] = c
                    } else
                        void 0 === r[o.uuid] && (r[o.uuid] = n.parse(o)),
                        i[o.uuid] = r[o.uuid]
                }
            }
            return i
        },
        parseAnimations: function(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var i = e[r]
                  , n = Bo.parse(i);
                void 0 !== i.uuid && (n.uuid = i.uuid),
                t.push(n)
            }
            return t
        },
        parseImages: function(e, t) {
            var r = this
              , i = {};
            function n(e) {
                return r.manager.itemStart(e),
                s.load(e, function() {
                    r.manager.itemEnd(e)
                }, void 0, function() {
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                })
            }
            if (void 0 !== e && e.length > 0) {
                var s = new Zo(new Fo(t));
                s.setCrossOrigin(this.crossOrigin);
                for (var a = 0, o = e.length; a < o; a++) {
                    var c = e[a]
                      , l = c.url;
                    if (Array.isArray(l)) {
                        i[c.uuid] = [];
                        for (var p = 0, h = l.length; p < h; p++) {
                            var u = l[p]
                              , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u;
                            i[c.uuid].push(n(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : r.resourcePath + c.url;
                        i[c.uuid] = n(d)
                    }
                }
            }
            return i
        },
        parseTextures: function(e, t) {
            function r(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                t[e])
            }
            var i = {};
            if (void 0 !== e)
                for (var n = 0, s = e.length; n < s; n++) {
                    var a, o = e[n];
                    void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
                    void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image),
                    (a = Array.isArray(t[o.image]) ? new Vi(t[o.image]) : new lr(t[o.image])).needsUpdate = !0,
                    a.uuid = o.uuid,
                    void 0 !== o.name && (a.name = o.name),
                    void 0 !== o.mapping && (a.mapping = r(o.mapping, Gc)),
                    void 0 !== o.offset && a.offset.fromArray(o.offset),
                    void 0 !== o.repeat && a.repeat.fromArray(o.repeat),
                    void 0 !== o.center && a.center.fromArray(o.center),
                    void 0 !== o.rotation && (a.rotation = o.rotation),
                    void 0 !== o.wrap && (a.wrapS = r(o.wrap[0], Hc),
                    a.wrapT = r(o.wrap[1], Hc)),
                    void 0 !== o.format && (a.format = o.format),
                    void 0 !== o.type && (a.type = o.type),
                    void 0 !== o.encoding && (a.encoding = o.encoding),
                    void 0 !== o.minFilter && (a.minFilter = r(o.minFilter, Vc)),
                    void 0 !== o.magFilter && (a.magFilter = r(o.magFilter, Vc)),
                    void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy),
                    void 0 !== o.flipY && (a.flipY = o.flipY),
                    void 0 !== o.premultiplyAlpha && (a.premultiplyAlpha = o.premultiplyAlpha),
                    void 0 !== o.unpackAlignment && (a.unpackAlignment = o.unpackAlignment),
                    i[o.uuid] = a
                }
            return i
        },
        parseObject: function(e, t, r) {
            var i;
            function n(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                t[e]
            }
            function s(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], i = 0, n = e.length; i < n; i++) {
                            var s = e[i];
                            void 0 === r[s] && console.warn("THREE.ObjectLoader: Undefined material", s),
                            t.push(r[s])
                        }
                        return t
                    }
                    return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                    r[e]
                }
            }
            switch (e.type) {
            case "Scene":
                i = new ks,
                void 0 !== e.background && Number.isInteger(e.background) && (i.background = new Pr(e.background)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Is(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new Ls(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                i = new ys(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (i.focus = e.focus),
                void 0 !== e.zoom && (i.zoom = e.zoom),
                void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset),
                void 0 !== e.view && (i.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                i = new Tc(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (i.zoom = e.zoom),
                void 0 !== e.view && (i.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                i = new Pc(e.color,e.intensity);
                break;
            case "DirectionalLight":
                i = new Ac(e.color,e.intensity);
                break;
            case "PointLight":
                i = new Sc(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                i = new Oc(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                i = new _c(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                i = new wc(e.color,e.groundColor,e.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var a = n(e.geometry)
                  , o = s(e.material);
                i = a.bones && a.bones.length > 0 ? new Fs(a,o) : new Li(a,o),
                void 0 !== e.drawMode && i.setDrawMode(e.drawMode);
                break;
            case "LOD":
                i = new js;
                break;
            case "Line":
                i = new Vs(n(e.geometry),s(e.material),e.mode);
                break;
            case "LineLoop":
                i = new Ys(n(e.geometry),s(e.material));
                break;
            case "LineSegments":
                i = new Ws(n(e.geometry),s(e.material));
                break;
            case "PointCloud":
            case "Points":
                i = new Xs(n(e.geometry),s(e.material));
                break;
            case "Sprite":
                i = new Ns(s(e.material));
                break;
            case "Group":
                i = new gs;
                break;
            default:
                i = new Hr
            }
            if (i.uuid = e.uuid,
            void 0 !== e.name && (i.name = e.name),
            void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate),
            i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position),
            void 0 !== e.rotation && i.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && i.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (i.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (i.visible = e.visible),
            void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder),
            void 0 !== e.userData && (i.userData = e.userData),
            void 0 !== e.layers && (i.layers.mask = e.layers),
            void 0 !== e.children)
                for (var c = e.children, l = 0; l < c.length; l++)
                    i.add(this.parseObject(c[l], t, r));
            if ("LOD" === e.type)
                for (var p = e.levels, h = 0; h < p.length; h++) {
                    var u = p[h]
                      , d = i.getObjectByProperty("uuid", u.object);
                    void 0 !== d && i.addLevel(d, u.distance)
                }
            return i
        }
    });
    var Bc, Nc, jc, Fc, Uc, Gc = {
        UVMapping: he,
        CubeReflectionMapping: ue,
        CubeRefractionMapping: de,
        EquirectangularReflectionMapping: fe,
        EquirectangularRefractionMapping: me,
        SphericalReflectionMapping: ge,
        CubeUVReflectionMapping: ve,
        CubeUVRefractionMapping: ye
    }, Hc = {
        RepeatWrapping: be,
        ClampToEdgeWrapping: we,
        MirroredRepeatWrapping: xe
    }, Vc = {
        NearestFilter: Me,
        NearestMipMapNearestFilter: _e,
        NearestMipMapLinearFilter: Se,
        LinearFilter: Te,
        LinearMipMapNearestFilter: Ee,
        LinearMipMapLinearFilter: Ae
    };
    function Wc(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.manager = void 0 !== e ? e : Uo,
        this.options = void 0
    }
    function Yc() {
        this.type = "ShapePath",
        this.color = new Pr,
        this.subPaths = [],
        this.currentPath = null
    }
    function Zc(e) {
        this.type = "Font",
        this.data = e
    }
    function Xc(e, t, r, i, n) {
        var s = n.glyphs[e] || n.glyphs["?"];
        if (s) {
            var a, o, c, l, p, h, u, d, f = new Yc;
            if (s.o)
                for (var m = s._cachedOutline || (s._cachedOutline = s.o.split(" ")), g = 0, v = m.length; g < v; ) {
                    switch (m[g++]) {
                    case "m":
                        a = m[g++] * t + r,
                        o = m[g++] * t + i,
                        f.moveTo(a, o);
                        break;
                    case "l":
                        a = m[g++] * t + r,
                        o = m[g++] * t + i,
                        f.lineTo(a, o);
                        break;
                    case "q":
                        c = m[g++] * t + r,
                        l = m[g++] * t + i,
                        p = m[g++] * t + r,
                        h = m[g++] * t + i,
                        f.quadraticCurveTo(p, h, c, l);
                        break;
                    case "b":
                        c = m[g++] * t + r,
                        l = m[g++] * t + i,
                        p = m[g++] * t + r,
                        h = m[g++] * t + i,
                        u = m[g++] * t + r,
                        d = m[g++] * t + i,
                        f.bezierCurveTo(p, h, u, d, c, l)
                    }
                }
            return {
                offsetX: s.ha * t,
                path: f
            }
        }
    }
    function qc(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function Jc() {}
    Wc.prototype = {
        constructor: Wc,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(e, t, r, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var n = this
              , s = jo.get(e);
            if (void 0 !== s)
                return n.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    n.manager.itemEnd(e)
                }, 0),
                s;
            fetch(e).then(function(e) {
                return e.blob()
            }).then(function(e) {
                return void 0 === n.options ? createImageBitmap(e) : createImageBitmap(e, n.options)
            }).then(function(r) {
                jo.add(e, r),
                t && t(r),
                n.manager.itemEnd(e)
            }).catch(function(t) {
                i && i(t),
                n.manager.itemError(e),
                n.manager.itemEnd(e)
            }),
            n.manager.itemStart(e)
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    },
    Object.assign(Yc.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new vc,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, r, i) {
            this.currentPath.quadraticCurveTo(e, t, r, i)
        },
        bezierCurveTo: function(e, t, r, i, n, s) {
            this.currentPath.bezierCurveTo(e, t, r, i, n, s)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function r(e) {
                for (var t = [], r = 0, i = e.length; r < i; r++) {
                    var n = e[r]
                      , s = new yc;
                    s.curves = n.curves,
                    t.push(s)
                }
                return t
            }
            function i(e, t) {
                for (var r = t.length, i = !1, n = r - 1, s = 0; s < r; n = s++) {
                    var a = t[n]
                      , o = t[s]
                      , c = o.x - a.x
                      , l = o.y - a.y;
                    if (Math.abs(l) > Number.EPSILON) {
                        if (l < 0 && (a = t[s],
                        c = -c,
                        o = t[n],
                        l = -l),
                        e.y < a.y || e.y > o.y)
                            continue;
                        if (e.y === a.y) {
                            if (e.x === a.x)
                                return !0
                        } else {
                            var p = l * (e.x - a.x) - c * (e.y - a.y);
                            if (0 === p)
                                return !0;
                            if (p < 0)
                                continue;
                            i = !i
                        }
                    } else {
                        if (e.y !== a.y)
                            continue;
                        if (o.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= o.x)
                            return !0
                    }
                }
                return i
            }
            var n = Fa.isClockWise
              , s = this.subPaths;
            if (0 === s.length)
                return [];
            if (!0 === t)
                return r(s);
            var a, o, c, l = [];
            if (1 === s.length)
                return o = s[0],
                (c = new yc).curves = o.curves,
                l.push(c),
                l;
            var p = !n(s[0].getPoints());
            p = e ? !p : p;
            var h, u, d = [], f = [], m = [], g = 0;
            f[g] = void 0,
            m[g] = [];
            for (var v = 0, y = s.length; v < y; v++)
                a = n(h = (o = s[v]).getPoints()),
                (a = e ? !a : a) ? (!p && f[g] && g++,
                f[g] = {
                    s: new yc,
                    p: h
                },
                f[g].s.curves = o.curves,
                p && g++,
                m[g] = []) : m[g].push({
                    h: o,
                    p: h[0]
                });
            if (!f[0])
                return r(s);
            if (f.length > 1) {
                for (var b = !1, w = [], x = 0, M = f.length; x < M; x++)
                    d[x] = [];
                for (x = 0,
                M = f.length; x < M; x++)
                    for (var _ = m[x], S = 0; S < _.length; S++) {
                        for (var T = _[S], E = !0, A = 0; A < f.length; A++)
                            i(T.p, f[A].p) && (x !== A && w.push({
                                froms: x,
                                tos: A,
                                hole: S
                            }),
                            E ? (E = !1,
                            d[A].push(T)) : b = !0);
                        E && d[x].push(T)
                    }
                w.length > 0 && (b || (m = d))
            }
            v = 0;
            for (var P = f.length; v < P; v++) {
                c = f[v].s,
                l.push(c);
                for (var O = 0, R = (u = m[v]).length; O < R; O++)
                    c.holes.push(u[O].h)
            }
            return l
        }
    }),
    Object.assign(Zc.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            for (var r = [], i = function(e, t, r) {
                for (var i = Array.from ? Array.from(e) : String(e).split(""), n = t / r.resolution, s = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * n, a = [], o = 0, c = 0, l = 0; l < i.length; l++) {
                    var p = i[l];
                    if ("\n" === p)
                        o = 0,
                        c -= s;
                    else {
                        var h = Xc(p, n, o, c, r);
                        o += h.offsetX,
                        a.push(h.path)
                    }
                }
                return a
            }(e, t, this.data), n = 0, s = i.length; n < s; n++)
                Array.prototype.push.apply(r, i[n].toShapes());
            return r
        }
    }),
    Object.assign(qc.prototype, {
        load: function(e, t, r, i) {
            var n = this
              , s = new Ho(this.manager);
            s.setPath(this.path),
            s.load(e, function(e) {
                var r;
                try {
                    r = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    r = JSON.parse(e.substring(65, e.length - 2))
                }
                var i = n.parse(r);
                t && t(i)
            }, r, i)
        },
        parse: function(e) {
            return new Zc(e)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Jc.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, r = 0, i = t.length; r < i; r += 2) {
                var n = t[r]
                  , s = t[r + 1];
                if (n.test(e))
                    return s
            }
            return null
        }
    },
    Object.assign(Jc.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, r) {
            for (var i = [], n = 0; n < e.length; ++n)
                i[n] = this.createMaterial(e[n], t, r);
            return i
        },
        createMaterial: (Bc = {
            NoBlending: E,
            NormalBlending: A,
            AdditiveBlending: P,
            SubtractiveBlending: O,
            MultiplyBlending: R,
            CustomBlending: C
        },
        Nc = new Pr,
        jc = new qo,
        Fc = new Rc,
        function(e, t, r) {
            var i = {};
            function n(e, n, s, a, o) {
                var c, l = t + e, p = Jc.Handlers.get(l);
                null !== p ? c = p.load(l) : (jc.setCrossOrigin(r),
                c = jc.load(l)),
                void 0 !== n && (c.repeat.fromArray(n),
                1 !== n[0] && (c.wrapS = be),
                1 !== n[1] && (c.wrapT = be)),
                void 0 !== s && c.offset.fromArray(s),
                void 0 !== a && ("repeat" === a[0] && (c.wrapS = be),
                "mirror" === a[0] && (c.wrapS = xe),
                "repeat" === a[1] && (c.wrapT = be),
                "mirror" === a[1] && (c.wrapT = xe)),
                void 0 !== o && (c.anisotropy = o);
                var h = Gt.generateUUID();
                return i[h] = c,
                h
            }
            var s = {
                uuid: Gt.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (var a in e) {
                var o = e[a];
                switch (a) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                    break;
                case "DbgName":
                    s.name = o;
                    break;
                case "blending":
                    s.blending = Bc[o];
                    break;
                case "colorAmbient":
                case "mapAmbient":
                    console.warn("THREE.Loader.createMaterial:", a, "is no longer supported.");
                    break;
                case "colorDiffuse":
                    s.color = Nc.fromArray(o).getHex();
                    break;
                case "colorSpecular":
                    s.specular = Nc.fromArray(o).getHex();
                    break;
                case "colorEmissive":
                    s.emissive = Nc.fromArray(o).getHex();
                    break;
                case "specularCoef":
                    s.shininess = o;
                    break;
                case "shading":
                    "basic" === o.toLowerCase() && (s.type = "MeshBasicMaterial"),
                    "phong" === o.toLowerCase() && (s.type = "MeshPhongMaterial"),
                    "standard" === o.toLowerCase() && (s.type = "MeshStandardMaterial");
                    break;
                case "mapDiffuse":
                    s.map = n(o, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                    break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                    break;
                case "mapEmissive":
                    s.emissiveMap = n(o, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                    break;
                case "mapEmissiveRepeat":
                case "mapEmissiveOffset":
                case "mapEmissiveWrap":
                case "mapEmissiveAnisotropy":
                    break;
                case "mapLight":
                    s.lightMap = n(o, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                    break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                    break;
                case "mapAO":
                    s.aoMap = n(o, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                    break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                    break;
                case "mapBump":
                    s.bumpMap = n(o, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                    break;
                case "mapBumpScale":
                    s.bumpScale = o;
                    break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                    break;
                case "mapNormal":
                    s.normalMap = n(o, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                    break;
                case "mapNormalFactor":
                    s.normalScale = o;
                    break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                    break;
                case "mapSpecular":
                    s.specularMap = n(o, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                    break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                    break;
                case "mapMetalness":
                    s.metalnessMap = n(o, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                    break;
                case "mapMetalnessRepeat":
                case "mapMetalnessOffset":
                case "mapMetalnessWrap":
                case "mapMetalnessAnisotropy":
                    break;
                case "mapRoughness":
                    s.roughnessMap = n(o, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                    break;
                case "mapRoughnessRepeat":
                case "mapRoughnessOffset":
                case "mapRoughnessWrap":
                case "mapRoughnessAnisotropy":
                    break;
                case "mapAlpha":
                    s.alphaMap = n(o, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                    break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                    break;
                case "flipSided":
                    s.side = b;
                    break;
                case "doubleSided":
                    s.side = w;
                    break;
                case "transparency":
                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                    s.opacity = o;
                    break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                    s[a] = o;
                    break;
                case "vertexColors":
                    !0 === o && (s.vertexColors = T),
                    "face" === o && (s.vertexColors = S);
                    break;
                default:
                    console.error("THREE.Loader.createMaterial: Unsupported", a, o)
                }
            }
            return "MeshBasicMaterial" === s.type && delete s.emissive,
            "MeshPhongMaterial" !== s.type && delete s.specular,
            s.opacity < 1 && (s.transparent = !0),
            Fc.setTextures(i),
            Fc.parse(s)
        }
        )
    });
    var Kc = {
        getContext: function() {
            return void 0 === Uc && (Uc = new (window.AudioContext || window.webkitAudioContext)),
            Uc
        },
        setContext: function(e) {
            Uc = e
        }
    };
    function Qc(e) {
        this.manager = void 0 !== e ? e : Uo
    }
    function $c() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++)
            this.coefficients.push(new Wt)
    }
    function el(e, t) {
        bc.call(this, void 0, t),
        this.sh = void 0 !== e ? e : new $c
    }
    function tl(e, t, r) {
        el.call(this, void 0, r);
        var i = (new Pr).set(e)
          , n = (new Pr).set(t)
          , s = new Wt(i.r,i.g,i.b)
          , a = new Wt(n.r,n.g,n.b)
          , o = Math.sqrt(Math.PI)
          , c = o * Math.sqrt(.75);
        this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
        this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(c)
    }
    function rl(e, t) {
        el.call(this, void 0, t);
        var r = (new Pr).set(e);
        this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    function il() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new ys,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new ys,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    Object.assign(Qc.prototype, {
        load: function(e, t, r, i) {
            var n = new Ho(this.manager);
            n.setResponseType("arraybuffer"),
            n.setPath(this.path),
            n.load(e, function(e) {
                var r = e.slice(0);
                Kc.getContext().decodeAudioData(r, function(e) {
                    t(e)
                })
            }, r, i)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign($c.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , s = this.coefficients;
            return t = .282095 * s[0],
            t += .488603 * s[1] * i,
            t += .488603 * s[2] * n,
            t += .488603 * s[3] * r,
            t += 1.092548 * s[4] * (r * i),
            t += 1.092548 * s[5] * (i * n),
            t += .315392 * s[6] * (3 * n * n - 1),
            t += 1.092548 * s[7] * (r * n),
            t += .546274 * s[8] * (r * r - i * i)
        },
        getIrradianceAt: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , s = this.coefficients;
            return t = .886227 * s[0],
            t += 2 * s[1] * .511664 * i,
            t += 2 * s[2] * .511664 * n,
            t += 2 * s[3] * .511664 * r,
            t += 2 * s[4] * .429043 * r * i,
            t += 2 * s[5] * .429043 * i * n,
            t += s[6] * (.743125 * n * n - .247708),
            t += 2 * s[7] * .429043 * r * n,
            t += .429043 * s[8] * (r * r - i * i)
        },
        add: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var r = 0; r < 9; r++)
                this.coefficients[r].lerp(e.coefficients[r], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t]))
                    return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e) {
            for (var t = this.coefficients, r = 0; r < 9; r++)
                t[r].fromArray(e, 3 * r);
            return this
        },
        toArray: function() {
            for (var e = [], t = this.coefficients, r = 0; r < 9; r++)
                t[r].toArray(e, 3 * r);
            return e
        }
    }),
    Object.assign($c, {
        getBasisAt: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z;
            t[0] = .282095,
            t[1] = .488603 * i,
            t[2] = .488603 * n,
            t[3] = .488603 * r,
            t[4] = 1.092548 * r * i,
            t[5] = 1.092548 * i * n,
            t[6] = .315392 * (3 * n * n - 1),
            t[7] = 1.092548 * r * n,
            t[8] = .546274 * (r * r - i * i)
        }
    }),
    el.prototype = Object.assign(Object.create(bc.prototype), {
        constructor: el,
        isLightProbe: !0,
        copy: function(e) {
            return bc.prototype.copy.call(this, e),
            this.sh.copy(e.sh),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            return bc.prototype.toJSON.call(this, e)
        }
    }),
    tl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: tl,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return el.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return el.prototype.toJSON.call(this, e)
        }
    }),
    rl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: rl,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return el.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return el.prototype.toJSON.call(this, e)
        }
    }),
    Object.assign(il.prototype, {
        update: function() {
            var e, t, r, i, n, s, a, o, c = new br, l = new br;
            return function(p) {
                if (e !== this || t !== p.focus || r !== p.fov || i !== p.aspect * this.aspect || n !== p.near || s !== p.far || a !== p.zoom || o !== this.eyeSep) {
                    e = this,
                    t = p.focus,
                    r = p.fov,
                    i = p.aspect * this.aspect,
                    n = p.near,
                    s = p.far,
                    a = p.zoom;
                    var h, u, d = p.projectionMatrix.clone(), f = (o = this.eyeSep / 2) * n / t, m = n * Math.tan(Gt.DEG2RAD * r * .5) / a;
                    l.elements[12] = -o,
                    c.elements[12] = o,
                    h = -m * i + f,
                    u = m * i + f,
                    d.elements[0] = 2 * n / (u - h),
                    d.elements[8] = (u + h) / (u - h),
                    this.cameraL.projectionMatrix.copy(d),
                    h = -m * i - f,
                    u = m * i - f,
                    d.elements[0] = 2 * n / (u - h),
                    d.elements[8] = (u + h) / (u - h),
                    this.cameraR.projectionMatrix.copy(d)
                }
                this.cameraL.matrixWorld.copy(p.matrixWorld).multiply(l),
                this.cameraR.matrixWorld.copy(p.matrixWorld).multiply(c)
            }
        }()
    });
    var nl = 90
      , sl = 1;
    function al(e, t, r, i) {
        Hr.call(this),
        this.type = "CubeCamera";
        var n = new ys(nl,sl,e,t);
        n.up.set(0, -1, 0),
        n.lookAt(new Wt(1,0,0)),
        this.add(n);
        var s = new ys(nl,sl,e,t);
        s.up.set(0, -1, 0),
        s.lookAt(new Wt(-1,0,0)),
        this.add(s);
        var a = new ys(nl,sl,e,t);
        a.up.set(0, 0, 1),
        a.lookAt(new Wt(0,1,0)),
        this.add(a);
        var o = new ys(nl,sl,e,t);
        o.up.set(0, 0, -1),
        o.lookAt(new Wt(0,-1,0)),
        this.add(o);
        var c = new ys(nl,sl,e,t);
        c.up.set(0, -1, 0),
        c.lookAt(new Wt(0,0,1)),
        this.add(c);
        var l = new ys(nl,sl,e,t);
        l.up.set(0, -1, 0),
        l.lookAt(new Wt(0,0,-1)),
        this.add(l),
        i = i || {
            format: Ue,
            magFilter: Te,
            minFilter: Te
        },
        this.renderTarget = new dr(r,r,i),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var r = e.getRenderTarget()
              , i = this.renderTarget
              , p = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1,
            e.setRenderTarget(i, 0),
            e.render(t, n),
            e.setRenderTarget(i, 1),
            e.render(t, s),
            e.setRenderTarget(i, 2),
            e.render(t, a),
            e.setRenderTarget(i, 3),
            e.render(t, o),
            e.setRenderTarget(i, 4),
            e.render(t, c),
            i.texture.generateMipmaps = p,
            e.setRenderTarget(i, 5),
            e.render(t, l),
            e.setRenderTarget(r)
        }
        ,
        this.clear = function(e, t, r, i) {
            for (var n = e.getRenderTarget(), s = this.renderTarget, a = 0; a < 6; a++)
                e.setRenderTarget(s, a),
                e.clear(t, r, i);
            e.setRenderTarget(n)
        }
    }
    function ol(e) {
        this.autoStart = void 0 === e || e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    function cl() {
        Hr.call(this),
        this.type = "AudioListener",
        this.context = Kc.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0
    }
    function ll(e) {
        Hr.call(this),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.startTime = 0,
        this.offset = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function pl(e) {
        ll.call(this, e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    function hl(e, t) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== t ? t : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    function ul(e, t, r) {
        this.binding = e,
        this.valueSize = r;
        var i, n = Float64Array;
        switch (t) {
        case "quaternion":
            i = this._slerp;
            break;
        case "string":
        case "bool":
            n = Array,
            i = this._select;
            break;
        default:
            i = this._lerp
        }
        this.buffer = new n(4 * r),
        this._mixBufferRegion = i,
        this.cumulativeWeight = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    al.prototype = Object.create(Hr.prototype),
    al.prototype.constructor = al,
    Object.assign(ol.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    }),
    cl.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: cl,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function() {
            var e = new Wt
              , t = new Vt
              , r = new Wt
              , i = new Wt
              , n = new ol;
            return function(s) {
                Hr.prototype.updateMatrixWorld.call(this, s);
                var a = this.context.listener
                  , o = this.up;
                if (this.timeDelta = n.getDelta(),
                this.matrixWorld.decompose(e, t, r),
                i.set(0, 0, -1).applyQuaternion(t),
                a.positionX) {
                    var c = this.context.currentTime + this.timeDelta;
                    a.positionX.linearRampToValueAtTime(e.x, c),
                    a.positionY.linearRampToValueAtTime(e.y, c),
                    a.positionZ.linearRampToValueAtTime(e.z, c),
                    a.forwardX.linearRampToValueAtTime(i.x, c),
                    a.forwardY.linearRampToValueAtTime(i.y, c),
                    a.forwardZ.linearRampToValueAtTime(i.z, c),
                    a.upX.linearRampToValueAtTime(o.x, c),
                    a.upY.linearRampToValueAtTime(o.y, c),
                    a.upZ.linearRampToValueAtTime(o.z, c)
                } else
                    a.setPosition(e.x, e.y, e.z),
                    a.setOrientation(i.x, i.y, i.z, o.x, o.y, o.z)
            }
        }()
    }),
    ll.prototype = Object.assign(Object.create(Hr.prototype), {
        constructor: ll,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        },
        setBuffer: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer,
                    e.loop = this.loop,
                    e.onended = this.onEnded.bind(this),
                    this.startTime = this.context.currentTime,
                    e.start(this.startTime, this.offset),
                    this.isPlaying = !0,
                    this.source = e,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else
                console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.source.onended = null,
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.source.onended = null,
                this.offset = 0,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = e,
            this.connect()) : this.filters = e,
            this
        },
        setDetune: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }),
    pl.prototype = Object.assign(Object.create(ll.prototype), {
        constructor: pl,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e,
            this
        },
        setDirectionalCone: function(e, t, r) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = r,
            this
        },
        updateMatrixWorld: function() {
            var e = new Wt
              , t = new Vt
              , r = new Wt
              , i = new Wt;
            return function(n) {
                if (Hr.prototype.updateMatrixWorld.call(this, n),
                !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                    this.matrixWorld.decompose(e, t, r),
                    i.set(0, 0, 1).applyQuaternion(t);
                    var s = this.panner;
                    if (s.positionX) {
                        var a = this.context.currentTime + this.listener.timeDelta;
                        s.positionX.linearRampToValueAtTime(e.x, a),
                        s.positionY.linearRampToValueAtTime(e.y, a),
                        s.positionZ.linearRampToValueAtTime(e.z, a),
                        s.orientationX.linearRampToValueAtTime(i.x, a),
                        s.orientationY.linearRampToValueAtTime(i.y, a),
                        s.orientationZ.linearRampToValueAtTime(i.z, a)
                    } else
                        s.setPosition(e.x, e.y, e.z),
                        s.setOrientation(i.x, i.y, i.z)
                }
            }
        }()
    }),
    Object.assign(hl.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), r = 0; r < t.length; r++)
                e += t[r];
            return e / t.length
        }
    }),
    Object.assign(ul.prototype, {
        accumulate: function(e, t) {
            var r = this.buffer
              , i = this.valueSize
              , n = e * i + i
              , s = this.cumulativeWeight;
            if (0 === s) {
                for (var a = 0; a !== i; ++a)
                    r[n + a] = r[a];
                s = t
            } else {
                var o = t / (s += t);
                this._mixBufferRegion(r, n, 0, o, i)
            }
            this.cumulativeWeight = s
        },
        apply: function(e) {
            var t = this.valueSize
              , r = this.buffer
              , i = e * t + t
              , n = this.cumulativeWeight
              , s = this.binding;
            if (this.cumulativeWeight = 0,
            n < 1) {
                var a = 3 * t;
                this._mixBufferRegion(r, i, a, 1 - n, t)
            }
            for (var o = t, c = t + t; o !== c; ++o)
                if (r[o] !== r[o + t]) {
                    s.setValue(r, i);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding
              , t = this.buffer
              , r = this.valueSize
              , i = 3 * r;
            e.getValue(t, i);
            for (var n = r, s = i; n !== s; ++n)
                t[n] = t[i + n % r];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _select: function(e, t, r, i, n) {
            if (i >= .5)
                for (var s = 0; s !== n; ++s)
                    e[t + s] = e[r + s]
        },
        _slerp: function(e, t, r, i) {
            Vt.slerpFlat(e, t, e, t, e, r, i)
        },
        _lerp: function(e, t, r, i, n) {
            for (var s = 1 - i, a = 0; a !== n; ++a) {
                var o = t + a;
                e[o] = e[o] * s + e[r + a] * i
            }
        }
    });
    var dl, fl, ml, gl, vl, yl, bl, wl, xl, Ml, _l, Sl, Tl, El, Al;
    function Pl(e, t, r) {
        var i = r || Ol.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    function Ol(e, t, r) {
        this.path = t,
        this.parsedPath = r || Ol.parseTrackName(t),
        this.node = Ol.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function Rl() {
        this.uuid = Gt.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, r = arguments.length; t !== r; ++t)
            e[arguments[t].uuid] = t;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {
                get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }
    function Cl(e, t, r) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = r || null;
        for (var i = t.tracks, n = i.length, s = new Array(n), a = {
            endingStart: St,
            endingEnd: St
        }, o = 0; o !== n; ++o) {
            var c = i[o].createInterpolant(null);
            s[o] = c,
            c.settings = a
        }
        this._interpolantSettings = a,
        this._interpolants = s,
        this._propertyBindings = new Array(n),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = bt,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function Ll(e) {
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function Il(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = arguments[1]),
        this.value = e
    }
    function kl(e, t, r) {
        Ds.call(this, e, t),
        this.meshPerAttribute = r || 1
    }
    function Dl(e, t, r, i) {
        this.ray = new Oi(e,t),
        this.near = r || 0,
        this.far = i || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function zl(e, t) {
        return e.distance - t.distance
    }
    function Bl(e, t, r, i) {
        if (!1 !== e.visible && (e.raycast(t, r),
        !0 === i))
            for (var n = e.children, s = 0, a = n.length; s < a; s++)
                Bl(n[s], t, r, !0)
    }
    function Nl(e, t, r) {
        return this.radius = void 0 !== e ? e : 1,
        this.phi = void 0 !== t ? t : 0,
        this.theta = void 0 !== r ? r : 0,
        this
    }
    function jl(e, t, r) {
        return this.radius = void 0 !== e ? e : 1,
        this.theta = void 0 !== t ? t : 0,
        this.y = void 0 !== r ? r : 0,
        this
    }
    function Fl(e, t) {
        this.min = void 0 !== e ? e : new Ht(1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Ht(-1 / 0,-1 / 0)
    }
    function Ul(e, t) {
        this.start = void 0 !== e ? e : new Wt,
        this.end = void 0 !== t ? t : new Wt
    }
    function Gl(e) {
        Hr.call(this),
        this.material = e,
        this.render = function() {}
    }
    function Hl(e, t, r, i) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var n = void 0 !== r ? r : 16711680
          , s = void 0 !== i ? i : 1
          , a = 0
          , o = this.object.geometry;
        o && o.isGeometry ? a = 3 * o.faces.length : o && o.isBufferGeometry && (a = o.attributes.normal.count);
        var c = new oi
          , l = new ri(2 * a * 3,3);
        c.addAttribute("position", l),
        Ws.call(this, c, new Hs({
            color: n,
            linewidth: s
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Vl(e, t) {
        Hr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t;
        for (var r = new oi, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, s = 1; n < 32; n++,
        s++) {
            var a = n / 32 * Math.PI * 2
              , o = s / 32 * Math.PI * 2;
            i.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1)
        }
        r.addAttribute("position", new ri(i,3));
        var c = new Hs({
            fog: !1
        });
        this.cone = new Ws(r,c),
        this.add(this.cone),
        this.update()
    }
    function Wl(e) {
        for (var t = function e(t) {
            var r = [];
            t && t.isBone && r.push(t);
            for (var i = 0; i < t.children.length; i++)
                r.push.apply(r, e(t.children[i]));
            return r
        }(e), r = new oi, i = [], n = [], s = new Pr(0,0,1), a = new Pr(0,1,0), o = 0; o < t.length; o++) {
            var c = t[o];
            c.parent && c.parent.isBone && (i.push(0, 0, 0),
            i.push(0, 0, 0),
            n.push(s.r, s.g, s.b),
            n.push(a.r, a.g, a.b))
        }
        r.addAttribute("position", new ri(i,3)),
        r.addAttribute("color", new ri(n,3));
        var l = new Hs({
            vertexColors: T,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Ws.call(this, r, l),
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function Yl(e, t, r) {
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = r;
        var i = new Ja(t,4,2)
          , n = new Ci({
            wireframe: !0,
            fog: !1
        });
        Li.call(this, i, n),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Zl(e, t) {
        this.type = "RectAreaLightHelper",
        this.light = e,
        this.color = t;
        var r = new oi;
        r.addAttribute("position", new ri([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        r.computeBoundingSphere();
        var i = new Hs({
            fog: !1
        });
        Vs.call(this, r, i);
        var n = new oi;
        n.addAttribute("position", new ri([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        n.computeBoundingSphere(),
        this.add(new Li(n,new Ci({
            side: b,
            fog: !1
        }))),
        this.update()
    }
    function Xl(e, t, r) {
        Hr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r;
        var i = new oa(t);
        i.rotateY(.5 * Math.PI),
        this.material = new Ci({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = T);
        var n = i.getAttribute("position")
          , s = new Float32Array(3 * n.count);
        i.addAttribute("color", new Xr(s,3)),
        this.add(new Li(i,this.material)),
        this.update()
    }
    function ql(e, t) {
        this.lightProbe = e,
        this.size = t;
        var r = {
            GAMMA_OUTPUT: ""
        }
          , i = new Pi({
            defines: r,
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
        })
          , n = new Ja(1,32,16);
        Li.call(this, n, i),
        this.onBeforeRender()
    }
    function Jl(e, t, r, i) {
        e = e || 10,
        t = t || 10,
        r = new Pr(void 0 !== r ? r : 4473924),
        i = new Pr(void 0 !== i ? i : 8947848);
        for (var n = t / 2, s = e / t, a = e / 2, o = [], c = [], l = 0, p = 0, h = -a; l <= t; l++,
        h += s) {
            o.push(-a, 0, h, a, 0, h),
            o.push(h, 0, -a, h, 0, a);
            var u = l === n ? r : i;
            u.toArray(c, p),
            p += 3,
            u.toArray(c, p),
            p += 3,
            u.toArray(c, p),
            p += 3,
            u.toArray(c, p),
            p += 3
        }
        var d = new oi;
        d.addAttribute("position", new ri(o,3)),
        d.addAttribute("color", new ri(c,3));
        var f = new Hs({
            vertexColors: T
        });
        Ws.call(this, d, f)
    }
    function Kl(e, t, r, i, n, s) {
        e = e || 10,
        t = t || 16,
        r = r || 8,
        i = i || 64,
        n = new Pr(void 0 !== n ? n : 4473924),
        s = new Pr(void 0 !== s ? s : 8947848);
        var a, o, c, l, p, h, u, d = [], f = [];
        for (l = 0; l <= t; l++)
            c = l / t * (2 * Math.PI),
            a = Math.sin(c) * e,
            o = Math.cos(c) * e,
            d.push(0, 0, 0),
            d.push(a, 0, o),
            u = 1 & l ? n : s,
            f.push(u.r, u.g, u.b),
            f.push(u.r, u.g, u.b);
        for (l = 0; l <= r; l++)
            for (u = 1 & l ? n : s,
            h = e - e / r * l,
            p = 0; p < i; p++)
                c = p / i * (2 * Math.PI),
                a = Math.sin(c) * h,
                o = Math.cos(c) * h,
                d.push(a, 0, o),
                f.push(u.r, u.g, u.b),
                c = (p + 1) / i * (2 * Math.PI),
                a = Math.sin(c) * h,
                o = Math.cos(c) * h,
                d.push(a, 0, o),
                f.push(u.r, u.g, u.b);
        var m = new oi;
        m.addAttribute("position", new ri(d,3)),
        m.addAttribute("color", new ri(f,3));
        var g = new Hs({
            vertexColors: T
        });
        Ws.call(this, m, g)
    }
    function Ql(e, t, r, i) {
        this.audio = e,
        this.range = t || 1,
        this.divisionsInnerAngle = r || 16,
        this.divisionsOuterAngle = i || 2;
        var n = new oi
          , s = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle
          , a = new Float32Array(3 * (3 * s + 3));
        n.addAttribute("position", new Xr(a,3));
        var o = new Hs({
            color: 65280
        })
          , c = new Hs({
            color: 16776960
        });
        Vs.call(this, n, [c, o]),
        this.update()
    }
    function $l(e, t, r, i) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var n = void 0 !== r ? r : 16776960
          , s = void 0 !== i ? i : 1
          , a = 0
          , o = this.object.geometry;
        o && o.isGeometry ? a = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new oi
          , l = new ri(2 * a * 3,3);
        c.addAttribute("position", l),
        Ws.call(this, c, new Hs({
            color: n,
            linewidth: s
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function ep(e, t, r) {
        Hr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r,
        void 0 === t && (t = 1);
        var i = new oi;
        i.addAttribute("position", new ri([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        var n = new Hs({
            fog: !1
        });
        this.lightPlane = new Vs(i,n),
        this.add(this.lightPlane),
        (i = new oi).addAttribute("position", new ri([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Vs(i,n),
        this.add(this.targetLine),
        this.update()
    }
    function tp(e) {
        var t = new oi
          , r = new Hs({
            color: 16777215,
            vertexColors: S
        })
          , i = []
          , n = []
          , s = {}
          , a = new Pr(16755200)
          , o = new Pr(16711680)
          , c = new Pr(43775)
          , l = new Pr(16777215)
          , p = new Pr(3355443);
        function h(e, t, r) {
            u(e, r),
            u(t, r)
        }
        function u(e, t) {
            i.push(0, 0, 0),
            n.push(t.r, t.g, t.b),
            void 0 === s[e] && (s[e] = []),
            s[e].push(i.length / 3 - 1)
        }
        h("n1", "n2", a),
        h("n2", "n4", a),
        h("n4", "n3", a),
        h("n3", "n1", a),
        h("f1", "f2", a),
        h("f2", "f4", a),
        h("f4", "f3", a),
        h("f3", "f1", a),
        h("n1", "f1", a),
        h("n2", "f2", a),
        h("n3", "f3", a),
        h("n4", "f4", a),
        h("p", "n1", o),
        h("p", "n2", o),
        h("p", "n3", o),
        h("p", "n4", o),
        h("u1", "u2", c),
        h("u2", "u3", c),
        h("u3", "u1", c),
        h("c", "t", l),
        h("p", "c", p),
        h("cn1", "cn2", p),
        h("cn3", "cn4", p),
        h("cf1", "cf2", p),
        h("cf3", "cf4", p),
        t.addAttribute("position", new ri(i,3)),
        t.addAttribute("color", new ri(n,3)),
        Ws.call(this, t, r),
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update()
    }
    function rp(e, t) {
        this.object = e,
        void 0 === t && (t = 16776960);
        var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new Float32Array(24)
          , n = new oi;
        n.setIndex(new Xr(r,1)),
        n.addAttribute("position", new Xr(i,3)),
        Ws.call(this, n, new Hs({
            color: t
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function ip(e, t) {
        this.type = "Box3Helper",
        this.box = e;
        var r = void 0 !== t ? t : 16776960
          , i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , n = new oi;
        n.setIndex(new Xr(i,1)),
        n.addAttribute("position", new ri([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        Ws.call(this, n, new Hs({
            color: r
        })),
        this.geometry.computeBoundingSphere()
    }
    function np(e, t, r) {
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = void 0 === t ? 1 : t;
        var i = void 0 !== r ? r : 16776960
          , n = new oi;
        n.addAttribute("position", new ri([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        n.computeBoundingSphere(),
        Vs.call(this, n, new Hs({
            color: i
        }));
        var s = new oi;
        s.addAttribute("position", new ri([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        s.computeBoundingSphere(),
        this.add(new Li(s,new Ci({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function sp(e, t, r, i, n, s) {
        Hr.call(this),
        void 0 === e && (e = new Wt(0,0,1)),
        void 0 === t && (t = new Wt(0,0,0)),
        void 0 === r && (r = 1),
        void 0 === i && (i = 16776960),
        void 0 === n && (n = .2 * r),
        void 0 === s && (s = .2 * n),
        void 0 === Sl && ((Sl = new oi).addAttribute("position", new ri([0, 0, 0, 0, 1, 0],3)),
        (Tl = new ao(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Vs(Sl,new Hs({
            color: i
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Li(Tl,new Ci({
            color: i
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(r, n, s)
    }
    function ap(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , r = new oi;
        r.addAttribute("position", new ri(t,3)),
        r.addAttribute("color", new ri([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var i = new Hs({
            vertexColors: T
        });
        Ws.call(this, r, i)
    }
    function op(e, t, r, i, n, s, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new kr(e,t,r,n,s,a)
    }
    Object.assign(Pl.prototype, {
        getValue: function(e, t) {
            this.bind();
            var r = this._targetGroup.nCachedObjects_
              , i = this._bindings[r];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var r = this._bindings, i = this._targetGroup.nCachedObjects_, n = r.length; i !== n; ++i)
                r[i].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(Ol, {
        Composite: Pl,
        create: function(e, t, r) {
            return e && e.isAnimationObjectGroup ? new Ol.Composite(e,t,r) : new Ol(e,t,r)
        },
        sanitizeNodeName: (xl = new RegExp("[\\[\\]\\.:\\/]","g"),
        function(e) {
            return e.replace(/\s/g, "_").replace(xl, "")
        }
        ),
        parseTrackName: (dl = "[^\\[\\]\\.:\\/]",
        fl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        ml = /((?:WC+[\/:])*)/.source.replace("WC", dl),
        gl = /(WCOD+)?/.source.replace("WCOD", fl),
        vl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", dl),
        yl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", dl),
        bl = new RegExp("^" + ml + gl + vl + yl + "$"),
        wl = ["material", "materials", "bones"],
        function(e) {
            var t = bl.exec(e);
            if (!t)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var r = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , i = r.nodeName && r.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                var n = r.nodeName.substring(i + 1);
                -1 !== wl.indexOf(n) && (r.nodeName = r.nodeName.substring(0, i),
                r.objectName = n)
            }
            if (null === r.propertyName || 0 === r.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return r
        }
        ),
        findNode: function(e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                var r = e.skeleton.getBoneByName(t);
                if (void 0 !== r)
                    return r
            }
            if (e.children) {
                var i = function(e) {
                    for (var r = 0; r < e.length; r++) {
                        var n = e[r];
                        if (n.name === t || n.uuid === t)
                            return n;
                        var s = i(n.children);
                        if (s)
                            return s
                    }
                    return null
                }
                  , n = i(e.children);
                if (n)
                    return n
            }
            return null
        }
    }),
    Object.assign(Ol.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                e[t++] = r[i]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++]
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            var e = this.node
              , t = this.parsedPath
              , r = t.objectName
              , i = t.propertyName
              , n = t.propertyIndex;
            if (e || (e = Ol.findNode(this.rootNode, t.nodeName) || this.rootNode,
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            e) {
                if (r) {
                    var s = t.objectIndex;
                    switch (r) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (var a = 0; a < e.length; a++)
                            if (e[a].name === s) {
                                s = a;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[r])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[r]
                    }
                    if (void 0 !== s) {
                        if (void 0 === e[s])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[s]
                    }
                }
                var o = e[i];
                if (void 0 !== o) {
                    var c = this.Versioning.None;
                    this.targetObject = e,
                    void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var l = this.BindingType.Direct;
                    if (void 0 !== n) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (e.geometry.morphAttributes.position[a].name === n) {
                                        n = a;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (e.geometry.morphTargets[a].name === n) {
                                        n = a;
                                        break
                                    }
                            }
                        }
                        l = this.BindingType.ArrayElement,
                        this.resolvedProperty = o,
                        this.propertyIndex = n
                    } else
                        void 0 !== o.fromArray && void 0 !== o.toArray ? (l = this.BindingType.HasFromToArray,
                        this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
                        this.resolvedProperty = o) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[l],
                    this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                } else {
                    var p = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + p + "." + i + " but it wasn't found.", e)
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(Ol.prototype, {
        _getValue_unbound: Ol.prototype.getValue,
        _setValue_unbound: Ol.prototype.setValue
    }),
    Object.assign(Rl.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, r = this.nCachedObjects_, i = this._indicesByUUID, n = this._paths, s = this._parsedPaths, a = this._bindings, o = a.length, c = void 0, l = 0, p = arguments.length; l !== p; ++l) {
                var h = arguments[l]
                  , u = h.uuid
                  , d = i[u];
                if (void 0 === d) {
                    d = t++,
                    i[u] = d,
                    e.push(h);
                    for (var f = 0, m = o; f !== m; ++f)
                        a[f].push(new Ol(h,n[f],s[f]))
                } else if (d < r) {
                    c = e[d];
                    var g = --r
                      , v = e[g];
                    i[v.uuid] = d,
                    e[d] = v,
                    i[u] = g,
                    e[g] = h;
                    for (f = 0,
                    m = o; f !== m; ++f) {
                        var y = a[f]
                          , b = y[g]
                          , w = y[d];
                        y[d] = b,
                        void 0 === w && (w = new Ol(h,n[f],s[f])),
                        y[g] = w
                    }
                } else
                    e[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = r
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, n = i.length, s = 0, a = arguments.length; s !== a; ++s) {
                var o = arguments[s]
                  , c = o.uuid
                  , l = r[c];
                if (void 0 !== l && l >= t) {
                    var p = t++
                      , h = e[p];
                    r[h.uuid] = l,
                    e[l] = h,
                    r[c] = p,
                    e[p] = o;
                    for (var u = 0, d = n; u !== d; ++u) {
                        var f = i[u]
                          , m = f[p]
                          , g = f[l];
                        f[l] = m,
                        f[p] = g
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, r = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, s = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var c = arguments[a].uuid
                  , l = i[c];
                if (void 0 !== l)
                    if (delete i[c],
                    l < r) {
                        var p = --r
                          , h = e[p]
                          , u = e[v = --t];
                        i[h.uuid] = l,
                        e[l] = h,
                        i[u.uuid] = p,
                        e[p] = u,
                        e.pop();
                        for (var d = 0, f = s; d !== f; ++d) {
                            var m = (y = n[d])[p]
                              , g = y[v];
                            y[l] = m,
                            y[p] = g,
                            y.pop()
                        }
                    } else {
                        var v;
                        i[(u = e[v = --t]).uuid] = l,
                        e[l] = u,
                        e.pop();
                        for (d = 0,
                        f = s; d !== f; ++d) {
                            var y;
                            (y = n[d])[l] = y[v],
                            y.pop()
                        }
                    }
            }
            this.nCachedObjects_ = r
        },
        subscribe_: function(e, t) {
            var r = this._bindingsIndicesByPath
              , i = r[e]
              , n = this._bindings;
            if (void 0 !== i)
                return n[i];
            var s = this._paths
              , a = this._parsedPaths
              , o = this._objects
              , c = o.length
              , l = this.nCachedObjects_
              , p = new Array(c);
            i = n.length,
            r[e] = i,
            s.push(e),
            a.push(t),
            n.push(p);
            for (var h = l, u = o.length; h !== u; ++h) {
                var d = o[h];
                p[h] = new Ol(d,e,t)
            }
            return p
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath
              , r = t[e];
            if (void 0 !== r) {
                var i = this._paths
                  , n = this._parsedPaths
                  , s = this._bindings
                  , a = s.length - 1
                  , o = s[a];
                t[e[a]] = r,
                s[r] = o,
                s.pop(),
                n[r] = n[a],
                n.pop(),
                i[r] = i[a],
                i.pop()
            }
        }
    }),
    Object.assign(Cl.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e,
            this
        },
        setLoop: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, r) {
            if (e.fadeOut(t),
            this.fadeIn(t),
            r) {
                var i = this._clip.duration
                  , n = e._clip.duration
                  , s = n / i
                  , a = i / n;
                e.warp(1, s, t),
                this.warp(a, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, r) {
            return e.crossFadeFrom(this, t, r)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, r) {
            var i = this._mixer
              , n = i.time
              , s = this._timeScaleInterpolant
              , a = this.timeScale;
            null === s && (s = i._lendControlInterpolant(),
            this._timeScaleInterpolant = s);
            var o = s.parameterPositions
              , c = s.sampleValues;
            return o[0] = n,
            o[1] = n + r,
            c[0] = e / a,
            c[1] = t / a,
            this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, r, i) {
            if (this.enabled) {
                var n = this._startTime;
                if (null !== n) {
                    var s = (e - n) * r;
                    if (s < 0 || 0 === r)
                        return;
                    this._startTime = null,
                    t = r * s
                }
                t *= this._updateTimeScale(e);
                var a = this._updateTime(t)
                  , o = this._updateWeight(e);
                if (o > 0)
                    for (var c = this._interpolants, l = this._propertyBindings, p = 0, h = c.length; p !== h; ++p)
                        c[p].evaluate(a),
                        l[p].accumulate(i, o)
            } else
                this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var r = this._weightInterpolant;
                if (null !== r) {
                    var i = r.evaluate(e)[0];
                    t *= i,
                    e > r.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t,
            t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var r = this._timeScaleInterpolant;
                if (null !== r)
                    t *= r.evaluate(e)[0],
                    e > r.parameterPositions[1] && (this.stopWarping(),
                    0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t,
            t
        },
        _updateTime: function(e) {
            var t = this.time + e
              , r = this._clip.duration
              , i = this.loop
              , n = this._loopCount
              , s = i === wt;
            if (0 === e)
                return -1 === n ? t : s && 1 == (1 & n) ? r - t : t;
            if (i === yt) {
                -1 === n && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                e: {
                    if (t >= r)
                        t = r;
                    else {
                        if (!(t < 0)) {
                            this.time = t;
                            break e
                        }
                        t = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = t,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === n && (e >= 0 ? (n = 0,
                this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                t >= r || t < 0) {
                    var a = Math.floor(t / r);
                    t -= r * a,
                    n += Math.abs(a);
                    var o = this.repetitions - n;
                    if (o <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        t = e > 0 ? r : 0,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                    else {
                        if (1 === o) {
                            var c = e < 0;
                            this._setEndings(c, !c, s)
                        } else
                            this._setEndings(!1, !1, s);
                        this._loopCount = n,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                } else
                    this.time = t;
                if (s && 1 == (1 & n))
                    return r - t
            }
            return t
        },
        _setEndings: function(e, t, r) {
            var i = this._interpolantSettings;
            r ? (i.endingStart = Tt,
            i.endingEnd = Tt) : (i.endingStart = e ? this.zeroSlopeAtStart ? Tt : St : Et,
            i.endingEnd = t ? this.zeroSlopeAtEnd ? Tt : St : Et)
        },
        _scheduleFading: function(e, t, r) {
            var i = this._mixer
              , n = i.time
              , s = this._weightInterpolant;
            null === s && (s = i._lendControlInterpolant(),
            this._weightInterpolant = s);
            var a = s.parameterPositions
              , o = s.sampleValues;
            return a[0] = n,
            o[0] = t,
            a[1] = n + e,
            o[1] = r,
            this
        }
    }),
    Ll.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Ll,
        _bindAction: function(e, t) {
            var r = e._localRoot || this._root
              , i = e._clip.tracks
              , n = i.length
              , s = e._propertyBindings
              , a = e._interpolants
              , o = r.uuid
              , c = this._bindingsByRootAndName
              , l = c[o];
            void 0 === l && (l = {},
            c[o] = l);
            for (var p = 0; p !== n; ++p) {
                var h = i[p]
                  , u = h.name
                  , d = l[u];
                if (void 0 !== d)
                    s[p] = d;
                else {
                    if (void 0 !== (d = s[p])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, o, u));
                        continue
                    }
                    var f = t && t._propertyBindings[p].binding.parsedPath;
                    ++(d = new ul(Ol.create(r, u, f),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, o, u),
                    s[p] = d
                }
                a[p].resultBuffer = d.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid
                      , r = e._clip.uuid
                      , i = this._actionsByClip[r];
                    this._bindAction(e, i && i.knownActions[0]),
                    this._addInactiveAction(e, r, t)
                }
                for (var n = e._propertyBindings, s = 0, a = n.length; s !== a; ++s) {
                    var o = n[s];
                    0 == o.useCount++ && (this._lendBinding(o),
                    o.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, r = 0, i = t.length; r !== i; ++r) {
                    var n = t[r];
                    0 == --n.useCount && (n.restoreOriginalState(),
                    this._takeBackBinding(n))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        },
        _addInactiveAction: function(e, t, r) {
            var i = this._actions
              , n = this._actionsByClip
              , s = n[t];
            if (void 0 === s)
                s = {
                    knownActions: [e],
                    actionByRoot: {}
                },
                e._byClipCacheIndex = 0,
                n[t] = s;
            else {
                var a = s.knownActions;
                e._byClipCacheIndex = a.length,
                a.push(e)
            }
            e._cacheIndex = i.length,
            i.push(e),
            s.actionByRoot[r] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions
              , r = t[t.length - 1]
              , i = e._cacheIndex;
            r._cacheIndex = i,
            t[i] = r,
            t.pop(),
            e._cacheIndex = null;
            var n = e._clip.uuid
              , s = this._actionsByClip
              , a = s[n]
              , o = a.knownActions
              , c = o[o.length - 1]
              , l = e._byClipCacheIndex;
            c._byClipCacheIndex = l,
            o[l] = c,
            o.pop(),
            e._byClipCacheIndex = null,
            delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === o.length && delete s[n],
            this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = e._propertyBindings, r = 0, i = t.length; r !== i; ++r) {
                var n = t[r];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , i = this._nActiveActions++
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        },
        _takeBackAction: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , i = --this._nActiveActions
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        },
        _addInactiveBinding: function(e, t, r) {
            var i = this._bindingsByRootAndName
              , n = i[t]
              , s = this._bindings;
            void 0 === n && (n = {},
            i[t] = n),
            n[r] = e,
            e._cacheIndex = s.length,
            s.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings
              , r = e.binding
              , i = r.rootNode.uuid
              , n = r.path
              , s = this._bindingsByRootAndName
              , a = s[i]
              , o = t[t.length - 1]
              , c = e._cacheIndex;
            o._cacheIndex = c,
            t[c] = o,
            t.pop(),
            delete a[n];
            e: {
                for (var l in a)
                    break e;
                delete s[i]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , i = this._nActiveBindings++
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        },
        _takeBackBinding: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , i = --this._nActiveBindings
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , r = e[t];
            return void 0 === r && ((r = new Ao(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t,
            e[t] = r),
            r
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants
              , r = e.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , n = t[i];
            e.__cacheIndex = i,
            t[i] = e,
            n.__cacheIndex = r,
            t[r] = n
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var r = t || this._root
              , i = r.uuid
              , n = "string" == typeof e ? Bo.findByName(r, e) : e
              , s = null !== n ? n.uuid : e
              , a = this._actionsByClip[s]
              , o = null;
            if (void 0 !== a) {
                var c = a.actionByRoot[i];
                if (void 0 !== c)
                    return c;
                o = a.knownActions[0],
                null === n && (n = o._clip)
            }
            if (null === n)
                return null;
            var l = new Cl(this,n,t);
            return this._bindAction(l, o),
            this._addInactiveAction(l, s, i),
            l
        },
        existingAction: function(e, t) {
            var r = t || this._root
              , i = r.uuid
              , n = "string" == typeof e ? Bo.findByName(r, e) : e
              , s = n ? n.uuid : e
              , a = this._actionsByClip[s];
            return void 0 !== a && a.actionByRoot[i] || null
        },
        stopAllAction: function() {
            var e = this._actions
              , t = this._nActiveActions
              , r = this._bindings
              , i = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var n = 0; n !== t; ++n)
                e[n].reset();
            for (n = 0; n !== i; ++n)
                r[n].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, r = this._nActiveActions, i = this.time += e, n = Math.sign(e), s = this._accuIndex ^= 1, a = 0; a !== r; ++a) {
                t[a]._update(i, e, n, s)
            }
            var o = this._bindings
              , c = this._nActiveBindings;
            for (a = 0; a !== c; ++a)
                o[a].apply(s);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions
              , r = e.uuid
              , i = this._actionsByClip
              , n = i[r];
            if (void 0 !== n) {
                for (var s = n.knownActions, a = 0, o = s.length; a !== o; ++a) {
                    var c = s[a];
                    this._deactivateAction(c);
                    var l = c._cacheIndex
                      , p = t[t.length - 1];
                    c._cacheIndex = null,
                    c._byClipCacheIndex = null,
                    p._cacheIndex = l,
                    t[l] = p,
                    t.pop(),
                    this._removeInactiveBindingsForAction(c)
                }
                delete i[r]
            }
        },
        uncacheRoot: function(e) {
            var t = e.uuid
              , r = this._actionsByClip;
            for (var i in r) {
                var n = r[i].actionByRoot[t];
                void 0 !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
            var s = this._bindingsByRootAndName[t];
            if (void 0 !== s)
                for (var a in s) {
                    var o = s[a];
                    o.restoreOriginalState(),
                    this._removeInactiveBinding(o)
                }
        },
        uncacheAction: function(e, t) {
            var r = this.existingAction(e, t);
            null !== r && (this._deactivateAction(r),
            this._removeInactiveAction(r))
        }
    }),
    Il.prototype.clone = function() {
        return new Il(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    kl.prototype = Object.assign(Object.create(Ds.prototype), {
        constructor: kl,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return Ds.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Object.assign(Dl.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, r) {
            var i = r || [];
            return Bl(e, this, i, t),
            i.sort(zl),
            i
        },
        intersectObjects: function(e, t, r) {
            var i = r || [];
            if (!1 === Array.isArray(e))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                i;
            for (var n = 0, s = e.length; n < s; n++)
                Bl(e[n], this, i, t);
            return i.sort(zl),
            i
        }
    }),
    Object.assign(Nl.prototype, {
        set: function(e, t, r) {
            return this.radius = e,
            this.phi = t,
            this.theta = r,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, r) {
            return this.radius = Math.sqrt(e * e + t * t + r * r),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, r),
            this.phi = Math.acos(Gt.clamp(t / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(jl.prototype, {
        set: function(e, t, r) {
            return this.radius = e,
            this.theta = t,
            this.y = r,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, r) {
            return this.radius = Math.sqrt(e * e + r * r),
            this.theta = Math.atan2(e, r),
            this.y = t,
            this
        }
    }),
    Object.assign(Fl.prototype, {
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new Ht;
            return function(t, r) {
                var i = e.copy(r).multiplyScalar(.5);
                return this.min.copy(t).sub(i),
                this.max.copy(t).add(i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"),
            e = new Ht),
            this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"),
            e = new Ht),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"),
            t = new Ht),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            t = new Ht),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new Ht;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(Ul.prototype, {
        set: function(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"),
            e = new Wt),
            e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"),
            e = new Wt),
            e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"),
            t = new Wt),
            this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: (Ml = new Wt,
        _l = new Wt,
        function(e, t) {
            Ml.subVectors(e, this.start),
            _l.subVectors(this.end, this.start);
            var r = _l.dot(_l)
              , i = _l.dot(Ml) / r;
            return t && (i = Gt.clamp(i, 0, 1)),
            i
        }
        ),
        closestPointToPoint: function(e, t, r) {
            var i = this.closestPointToPointParameter(e, t);
            return void 0 === r && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            r = new Wt),
            this.delta(r).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }),
    Gl.prototype = Object.create(Hr.prototype),
    Gl.prototype.constructor = Gl,
    Gl.prototype.isImmediateRenderObject = !0,
    Hl.prototype = Object.create(Ws.prototype),
    Hl.prototype.constructor = Hl,
    Hl.prototype.update = function() {
        var e = new Wt
          , t = new Wt
          , r = new Yt;
        return function() {
            var i = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
            r.getNormalMatrix(this.object.matrixWorld);
            var n = this.object.matrixWorld
              , s = this.geometry.attributes.position
              , a = this.object.geometry;
            if (a && a.isGeometry)
                for (var o = a.vertices, c = a.faces, l = 0, p = 0, h = c.length; p < h; p++)
                    for (var u = c[p], d = 0, f = u.vertexNormals.length; d < f; d++) {
                        var m = o[u[i[d]]]
                          , g = u.vertexNormals[d];
                        e.copy(m).applyMatrix4(n),
                        t.copy(g).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                        s.setXYZ(l, e.x, e.y, e.z),
                        l += 1,
                        s.setXYZ(l, t.x, t.y, t.z),
                        l += 1
                    }
            else if (a && a.isBufferGeometry) {
                var v = a.attributes.position
                  , y = a.attributes.normal;
                for (l = 0,
                d = 0,
                f = v.count; d < f; d++)
                    e.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(n),
                    t.set(y.getX(d), y.getY(d), y.getZ(d)),
                    t.applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                    s.setXYZ(l, e.x, e.y, e.z),
                    l += 1,
                    s.setXYZ(l, t.x, t.y, t.z),
                    l += 1
            }
            s.needsUpdate = !0
        }
    }(),
    Vl.prototype = Object.create(Hr.prototype),
    Vl.prototype.constructor = Vl,
    Vl.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    Vl.prototype.update = function() {
        var e = new Wt;
        return function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3
              , r = t * Math.tan(this.light.angle);
            this.cone.scale.set(r, r, t),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(e),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(),
    Wl.prototype = Object.create(Ws.prototype),
    Wl.prototype.constructor = Wl,
    Wl.prototype.updateMatrixWorld = function() {
        var e = new Wt
          , t = new br
          , r = new br;
        return function(i) {
            var n = this.bones
              , s = this.geometry
              , a = s.getAttribute("position");
            r.getInverse(this.root.matrixWorld);
            for (var o = 0, c = 0; o < n.length; o++) {
                var l = n[o];
                l.parent && l.parent.isBone && (t.multiplyMatrices(r, l.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(c, e.x, e.y, e.z),
                t.multiplyMatrices(r, l.parent.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(c + 1, e.x, e.y, e.z),
                c += 2)
            }
            s.getAttribute("position").needsUpdate = !0,
            Hr.prototype.updateMatrixWorld.call(this, i)
        }
    }(),
    Yl.prototype = Object.create(Li.prototype),
    Yl.prototype.constructor = Yl,
    Yl.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Yl.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    Zl.prototype = Object.create(Vs.prototype),
    Zl.prototype.constructor = Zl,
    Zl.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color)
            this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color
              , t = Math.max(e.r, e.g, e.b);
            t > 1 && e.multiplyScalar(1 / t),
            this.children[0].material.color.copy(this.material.color)
        }
    }
    ,
    Zl.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Xl.prototype = Object.create(Hr.prototype),
    Xl.prototype.constructor = Xl,
    Xl.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Xl.prototype.update = function() {
        var e = new Wt
          , t = new Pr
          , r = new Pr;
        return function() {
            var i = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                var n = i.geometry.getAttribute("color");
                t.copy(this.light.color),
                r.copy(this.light.groundColor);
                for (var s = 0, a = n.count; s < a; s++) {
                    var o = s < a / 2 ? t : r;
                    n.setXYZ(s, o.r, o.g, o.b)
                }
                n.needsUpdate = !0
            }
            i.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(),
    ql.prototype = Object.create(Li.prototype),
    ql.prototype.constructor = ql,
    ql.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    ql.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position),
        this.scale.set(1, 1, 1).multiplyScalar(this.size),
        this.material.uniforms.intensity.value = this.lightProbe.intensity
    }
    ,
    Jl.prototype = Object.assign(Object.create(Ws.prototype), {
        constructor: Jl,
        copy: function(e) {
            return Ws.prototype.copy.call(this, e),
            this.geometry.copy(e.geometry),
            this.material.copy(e.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Kl.prototype = Object.create(Ws.prototype),
    Kl.prototype.constructor = Kl,
    Ql.prototype = Object.create(Vs.prototype),
    Ql.prototype.constructor = Ql,
    Ql.prototype.update = function() {
        var e, t, r = this.audio, i = this.range, n = this.divisionsInnerAngle, s = this.divisionsOuterAngle, a = Gt.degToRad(r.panner.coneInnerAngle), o = Gt.degToRad(r.panner.coneOuterAngle), c = a / 2, l = o / 2, p = 0, h = 0, u = this.geometry, d = u.attributes.position;
        function f(r, n, s, a) {
            var o = (n - r) / s;
            for (d.setXYZ(p, 0, 0, 0),
            h++,
            e = r; e < n; e += o)
                t = p + h,
                d.setXYZ(t, Math.sin(e) * i, 0, Math.cos(e) * i),
                d.setXYZ(t + 1, Math.sin(Math.min(e + o, n)) * i, 0, Math.cos(Math.min(e + o, n)) * i),
                d.setXYZ(t + 2, 0, 0, 0),
                h += 3;
            u.addGroup(p, h, a),
            p += h,
            h = 0
        }
        u.clearGroups(),
        f(-l, -c, s, 0),
        f(-c, c, n, 1),
        f(c, l, s, 0),
        d.needsUpdate = !0,
        a === o && (this.material[0].visible = !1)
    }
    ,
    Ql.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material[0].dispose(),
        this.material[1].dispose()
    }
    ,
    $l.prototype = Object.create(Ws.prototype),
    $l.prototype.constructor = $l,
    $l.prototype.update = function() {
        var e = new Wt
          , t = new Wt
          , r = new Yt;
        return function() {
            this.object.updateMatrixWorld(!0),
            r.getNormalMatrix(this.object.matrixWorld);
            for (var i = this.object.matrixWorld, n = this.geometry.attributes.position, s = this.object.geometry, a = s.vertices, o = s.faces, c = 0, l = 0, p = o.length; l < p; l++) {
                var h = o[l]
                  , u = h.normal;
                e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(i),
                t.copy(u).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                n.setXYZ(c, e.x, e.y, e.z),
                c += 1,
                n.setXYZ(c, t.x, t.y, t.z),
                c += 1
            }
            n.needsUpdate = !0
        }
    }(),
    ep.prototype = Object.create(Hr.prototype),
    ep.prototype.constructor = ep,
    ep.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    ep.prototype.update = function() {
        var e = new Wt
          , t = new Wt
          , r = new Wt;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld),
            t.setFromMatrixPosition(this.light.target.matrixWorld),
            r.subVectors(t, e),
            this.lightPlane.lookAt(t),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(t),
            this.targetLine.scale.z = r.length()
        }
    }(),
    tp.prototype = Object.create(Ws.prototype),
    tp.prototype.constructor = tp,
    tp.prototype.update = function() {
        var e, t, r = new Wt, i = new vs;
        function n(n, s, a, o) {
            r.set(s, a, o).unproject(i);
            var c = t[n];
            if (void 0 !== c)
                for (var l = e.getAttribute("position"), p = 0, h = c.length; p < h; p++)
                    l.setXYZ(c[p], r.x, r.y, r.z)
        }
        return function() {
            e = this.geometry,
            t = this.pointMap;
            i.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            n("c", 0, 0, -1),
            n("t", 0, 0, 1),
            n("n1", -1, -1, -1),
            n("n2", 1, -1, -1),
            n("n3", -1, 1, -1),
            n("n4", 1, 1, -1),
            n("f1", -1, -1, 1),
            n("f2", 1, -1, 1),
            n("f3", -1, 1, 1),
            n("f4", 1, 1, 1),
            n("u1", .7, 1.1, -1),
            n("u2", -.7, 1.1, -1),
            n("u3", 0, 2, -1),
            n("cf1", -1, 0, 1),
            n("cf2", 1, 0, 1),
            n("cf3", 0, -1, 1),
            n("cf4", 0, 1, 1),
            n("cn1", -1, 0, -1),
            n("cn2", 1, 0, -1),
            n("cn3", 0, -1, -1),
            n("cn4", 0, 1, -1),
            e.getAttribute("position").needsUpdate = !0
        }
    }(),
    rp.prototype = Object.create(Ws.prototype),
    rp.prototype.constructor = rp,
    rp.prototype.update = function() {
        var e = new mr;
        return function(t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
            void 0 !== this.object && e.setFromObject(this.object),
            !e.isEmpty()) {
                var r = e.min
                  , i = e.max
                  , n = this.geometry.attributes.position
                  , s = n.array;
                s[0] = i.x,
                s[1] = i.y,
                s[2] = i.z,
                s[3] = r.x,
                s[4] = i.y,
                s[5] = i.z,
                s[6] = r.x,
                s[7] = r.y,
                s[8] = i.z,
                s[9] = i.x,
                s[10] = r.y,
                s[11] = i.z,
                s[12] = i.x,
                s[13] = i.y,
                s[14] = r.z,
                s[15] = r.x,
                s[16] = i.y,
                s[17] = r.z,
                s[18] = r.x,
                s[19] = r.y,
                s[20] = r.z,
                s[21] = i.x,
                s[22] = r.y,
                s[23] = r.z,
                n.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
        }
    }(),
    rp.prototype.setFromObject = function(e) {
        return this.object = e,
        this.update(),
        this
    }
    ,
    rp.prototype.copy = function(e) {
        return Ws.prototype.copy.call(this, e),
        this.object = e.object,
        this
    }
    ,
    rp.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    ip.prototype = Object.create(Ws.prototype),
    ip.prototype.constructor = ip,
    ip.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        Hr.prototype.updateMatrixWorld.call(this, e))
    }
    ,
    np.prototype = Object.create(Vs.prototype),
    np.prototype.constructor = np,
    np.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? b : y,
        this.lookAt(this.plane.normal),
        Hr.prototype.updateMatrixWorld.call(this, e)
    }
    ,
    sp.prototype = Object.create(Hr.prototype),
    sp.prototype.constructor = sp,
    sp.prototype.setDirection = (Al = new Wt,
    function(e) {
        e.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Al.set(e.z, 0, -e.x).normalize(),
        El = Math.acos(e.y),
        this.quaternion.setFromAxisAngle(Al, El))
    }
    ),
    sp.prototype.setLength = function(e, t, r) {
        void 0 === t && (t = .2 * e),
        void 0 === r && (r = .2 * t),
        this.line.scale.set(1, Math.max(0, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(r, t, r),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    ,
    sp.prototype.setColor = function(e) {
        this.line.material.color.copy(e),
        this.cone.material.color.copy(e)
    }
    ,
    sp.prototype.copy = function(e) {
        return Hr.prototype.copy.call(this, e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    ,
    sp.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    ap.prototype = Object.create(Ws.prototype),
    ap.prototype.constructor = ap;
    var cp = 0
      , lp = 1;
    function pp(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        e
    }
    function hp(e) {
        return void 0 === e && (e = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        e.isMultiMaterial = !0,
        e.materials = e,
        e.clone = function() {
            return e.slice()
        }
        ,
        e
    }
    function up(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new Xs(e,t)
    }
    function dp(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Ns(e)
    }
    function fp(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new Xs(e,t)
    }
    function mp(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new Zs(e)
    }
    function gp(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new Zs(e)
    }
    function vp(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new Zs(e)
    }
    function yp(e, t, r) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new Wt(e,t,r)
    }
    function bp(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new Xr(e,t).setDynamic(!0)
    }
    function wp(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new qr(e,t)
    }
    function xp(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new Jr(e,t)
    }
    function Mp(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new Kr(e,t)
    }
    function _p(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new Qr(e,t)
    }
    function Sp(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new $r(e,t)
    }
    function Tp(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new ei(e,t)
    }
    function Ep(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new ti(e,t)
    }
    function Ap(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new ri(e,t)
    }
    function Pp(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new ii(e,t)
    }
    function Op(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        nc.call(this, e),
        this.type = "catmullrom",
        this.closed = !0
    }
    function Rp(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        nc.call(this, e),
        this.type = "catmullrom"
    }
    function Cp(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        nc.call(this, e),
        this.type = "catmullrom"
    }
    function Lp(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new ap(e)
    }
    function Ip(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new rp(e,t)
    }
    function kp(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new Ws(new no(e.geometry),new Hs({
            color: void 0 !== t ? t : 16777215
        }))
    }
    function Dp(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new Ws(new $s(e.geometry),new Hs({
            color: void 0 !== t ? t : 16777215
        }))
    }
    function zp(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new Ho(e)
    }
    function Bp(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new Yo(e)
    }
    Jo.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"),
        e.prototype = Object.create(Jo.prototype),
        e.prototype.constructor = e,
        e.prototype.getPoint = t,
        e
    }
    ,
    Object.assign(gc.prototype, {
        createPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new Zr, r = 0, i = e.length; r < i; r++) {
                var n = e[r];
                t.vertices.push(new Wt(n.x,n.y,n.z || 0))
            }
            return t
        }
    }),
    Object.assign(vc.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(e)
        }
    }),
    Op.prototype = Object.create(nc.prototype),
    Rp.prototype = Object.create(nc.prototype),
    Cp.prototype = Object.create(nc.prototype),
    Object.assign(Cp.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    Jl.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    Wl.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(Jc.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Cc.extractUrlBase(e)
        }
    }),
    Object.assign(zc.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
            this.setResourcePath(e)
        }
    }),
    Object.assign(Fl.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Object.assign(mr.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Ul.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(e)
    }
    ,
    Object.assign(Gt, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            Gt.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            Gt.ceilPowerOfTwo(e)
        }
    }),
    Object.assign(Yt.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(br.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new Wt),
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, r, i, n, s) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(e, t, i, r, n, s)
        }
    }),
    vr.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(e)
    }
    ,
    Vt.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        e.applyQuaternion(this)
    }
    ,
    Object.assign(Oi.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }),
    Object.assign(Ri.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(e)
        }
    }),
    Object.assign(Ri, {
        barycoordFromPoint: function(e, t, r, i, n) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            Ri.getBarycoord(e, t, r, i, n)
        },
        normal: function(e, t, r, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            Ri.getNormal(e, t, r, i)
        }
    }),
    Object.assign(yc.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Ha(this,e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new to(this,e)
        }
    }),
    Object.assign(Ht.prototype, {
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Wt.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(pr.prototype, {
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Zr.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign(Hr.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }),
    Object.defineProperties(Hr.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.defineProperties(js.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(Us.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Fs.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(Jo.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = e
        }
    }),
    ys.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(bc.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(Xr.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }),
    Object.assign(oi.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(e)
        },
        addDrawCall: function(e, t, r) {
            void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }),
    Object.defineProperties(oi.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.assign(Va.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(Il.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(di.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new Pr
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = e === x
            }
        }
    }),
    Object.defineProperties(vo.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(Pi.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = e
            }
        }
    }),
    Object.assign(Cs.prototype, {
        clearTarget: function(e, t, r, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(e),
            this.clear(t, r, i)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
    }),
    Object.defineProperties(Cs.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(us.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(dr.prototype, {
        activeCubeFace: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }),
    Object.defineProperties(hr.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = e
            }
        }
    }),
    Object.defineProperties(Os.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }),
    ll.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new Qc).load(e, function(e) {
            t.setBuffer(e)
        }),
        this
    }
    ,
    hl.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    al.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
    }
    ;
    var Np = {
        merge: function(e, t, r) {
            var i;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
            i = t.matrix,
            t = t.geometry),
            e.merge(t, i, r)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            e.center()
        }
    };
    function jp() {
        console.error("THREE.CanvasRenderer has been removed")
    }
    function Fp() {
        console.error("THREE.JSONLoader has been removed.")
    }
    or.crossOrigin = void 0,
    or.loadTexture = function(e, t, r, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var n = new qo;
        n.setCrossOrigin(this.crossOrigin);
        var s = n.load(e, r, void 0, i);
        return t && (s.mapping = t),
        s
    }
    ,
    or.loadTextureCube = function(e, t, r, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var n = new Xo;
        n.setCrossOrigin(this.crossOrigin);
        var s = n.load(e, r, void 0, i);
        return t && (s.mapping = t),
        s
    }
    ,
    or.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    or.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ;
    var Up = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };
    function Gp() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
}
, function(e, t, r) {
    "use strict";
    function i(e) {
        switch (Object.prototype.toString.call(e)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
            return !0;
        default:
            return e instanceof Error
        }
    }
    function n(e) {
        return "[object ErrorEvent]" === Object.prototype.toString.call(e)
    }
    function s(e) {
        return "[object DOMError]" === Object.prototype.toString.call(e)
    }
    function a(e) {
        return "[object DOMException]" === Object.prototype.toString.call(e)
    }
    function o(e) {
        return "[object String]" === Object.prototype.toString.call(e)
    }
    function c(e) {
        return null === e || "object" != typeof e && "function" != typeof e
    }
    function l(e) {
        return "[object Object]" === Object.prototype.toString.call(e)
    }
    function p(e) {
        return "[object RegExp]" === Object.prototype.toString.call(e)
    }
    function h(e) {
        return !(!e || !e.then || "function" != typeof e.then)
    }
    function u(e) {
        return l(e) && "nativeEvent"in e && "preventDefault"in e && "stopPropagation"in e
    }
    r.d(t, "c", function() {
        return i
    }),
    r.d(t, "d", function() {
        return n
    }),
    r.d(t, "a", function() {
        return s
    }),
    r.d(t, "b", function() {
        return a
    }),
    r.d(t, "h", function() {
        return o
    }),
    r.d(t, "f", function() {
        return c
    }),
    r.d(t, "e", function() {
        return l
    }),
    r.d(t, "g", function() {
        return p
    }),
    r.d(t, "j", function() {
        return h
    }),
    r.d(t, "i", function() {
        return u
    })
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        r.d(t, "a", function() {
            return s
        }),
        r.d(t, "d", function() {
            return a
        }),
        r.d(t, "c", function() {
            return c
        }),
        r.d(t, "b", function() {
            return h
        });
        var i = r(5)
          , n = r(36);
        function s(e, t, r) {
            if (t in e) {
                var i = e[t]
                  , n = r(i);
                if ("function" == typeof n)
                    try {
                        n.prototype = n.prototype || {},
                        Object.defineProperties(n, {
                            __sentry__: {
                                enumerable: !1,
                                value: !0
                            },
                            __sentry_original__: {
                                enumerable: !1,
                                value: i
                            },
                            __sentry_wrapped__: {
                                enumerable: !1,
                                value: n
                            }
                        })
                    } catch (e) {}
                e[t] = n
            }
        }
        function a(e) {
            return Object.keys(e).map(function(t) {
                return encodeURIComponent(t) + "=" + encodeURIComponent(e[t])
            }).join("&")
        }
        function o(e) {
            return function(e) {
                return ~-encodeURI(e).split(/%..|./).length
            }(JSON.stringify(e))
        }
        function c(e, t, r) {
            void 0 === t && (t = 3),
            void 0 === r && (r = 102400);
            var i = h(e, t);
            return o(i) > r ? c(e, t - 1, r) : i
        }
        function l(t, r) {
            return "domain" === r && "object" == typeof t && t._events ? "[Domain]" : "domainEmitter" === r ? "[DomainEmitter]" : void 0 !== e && t === e ? "[Global]" : "undefined" != typeof window && t === window ? "[Window]" : "undefined" != typeof document && t === document ? "[Document]" : "undefined" != typeof Event && t instanceof Event ? Object.getPrototypeOf(t) ? t.constructor.name : "Event" : Object(i.i)(t) ? "[SyntheticEvent]" : Number.isNaN(t) ? "[NaN]" : void 0 === t ? "[undefined]" : "function" == typeof t ? "[Function: " + (t.name || "<unknown-function-name>") + "]" : t
        }
        function p(e, t, r, s) {
            if (void 0 === r && (r = 1 / 0),
            void 0 === s && (s = new n.a),
            0 === r)
                return function(e) {
                    var t = Object.prototype.toString.call(e);
                    if ("string" == typeof e)
                        return e;
                    if ("[object Object]" === t)
                        return "[Object]";
                    if ("[object Array]" === t)
                        return "[Array]";
                    var r = l(e);
                    return Object(i.f)(r) ? r : t
                }(t);
            if (null != t && "function" == typeof t.toJSON)
                return t.toJSON();
            var a = l(t, e);
            if (Object(i.f)(a))
                return a;
            var o = Object(i.c)(t) ? function(e) {
                var t = {
                    message: e.message,
                    name: e.name,
                    stack: e.stack
                };
                for (var r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t
            }(t) : t
              , c = Array.isArray(t) ? [] : {};
            if (s.memoize(t))
                return "[Circular ~]";
            for (var h in o)
                Object.prototype.hasOwnProperty.call(o, h) && (c[h] = p(h, o[h], r - 1, s));
            return s.unmemoize(t),
            c
        }
        function h(e, t) {
            try {
                return JSON.parse(JSON.stringify(e, function(e, r) {
                    return p(e, r, t)
                }))
            } catch (e) {
                return "**non-serializable**"
            }
        }
    }
    ).call(this, r(22))
}
, function(e, t, r) {
    (function(t) {
        e.exports.isNode = void 0 !== t && void 0 !== t.release && -1 !== t.release.name.search(/node|io.js/),
        e.exports.isProd = e.exports.isNode ? !!t.env.IS_PROD : "127.0.0.1" !== location.hostname && "localhost" !== location.hostname && !location.hostname.startsWith("192.168."),
        e.exports.enableHttps = e.exports.isProd || !e.exports.isNode && "true" == localStorage.__FORCE_HTTPS__,
        e.exports.serverTickRate = 1e3 / 30,
        e.exports.serverSendRate = 100,
        e.exports.clientSendRate = 1e3 / 30,
        e.exports.dltMx = Math.round(1e3 / 30),
        e.exports.streamUpdate = 1e4,
        e.exports.maxPlayers = 8,
        e.exports.serverSpread = 3,
        e.exports.minServerSpace = 3,
        e.exports.gamesPerServer = 3,
        e.exports.serverBrowserRate = 1e4,
        e.exports.maxPlayersTotal = e.exports.maxPlayers * e.exports.gamesPerServer + 40,
        e.exports.kickTimer = 9e4,
        e.exports.isNode ? (e.exports.matchmakerURL = e.exports.isProd ? "krunker_prod" == t.env.VULTR_SCHEME ? "https://matchmaker.krunker.io" : "https://matchmaker_beta.krunker.io" : "http://127.0.0.1:5050",
        e.exports.apiURL = e.exports.isProd ? "krunker_prod" == t.env.VULTR_SCHEME || "krunker_social" == t.env.VULTR_SCHEME ? "https://api.krunker.io" : "https://api_beta.krunker.io" : "http://127.0.0.1:5060") : (e.exports.matchmakerURL = e.exports.isProd ? "krunker.io" == location.hostname ? "https://matchmaker.krunker.io" : "https://matchmaker_beta.krunker.io" : localStorage.__MM_URL__ || "http://127.0.0.1:5050",
        e.exports.apiURL = e.exports.isProd ? "krunker.io" == location.hostname ? "https://api.krunker.io" : "https://api_beta.krunker.io" : localStorage.__API_URL__ || "http://127.0.0.1:5060"),
        e.exports.needsRestart = !1,
        e.exports.useLooseClient = !1,
        e.exports.currentSeason = 2,
        e.exports.rewardTime = 216e5,
        e.exports.rewardMinLvl = 15,
        e.exports.regionIND = {
            sgp: 2,
            "jb-hnd": 2,
            "us-nj": 4,
            "us-fl": 4,
            "us-ca-sv": 4,
            "au-syd": 1,
            "de-fra": 3
        },
        e.exports.compRegions = [{
            name: "EU",
            icon: "eu",
            data: [{
                name: "KRUNKEUR",
                prize: 1400,
                roster: ["VoKUS", "ronics", "AlexDoubleU", "Nitrahh"]
            }, {
                name: "UUED GUMMID",
                prize: 600,
                roster: ["kiiturii", "WasabiS", "xXNONUTTERXx", "BLNCR"]
            }, {
                name: "Nine",
                prize: 0,
                roster: ["Chupacabra", "The_Zionist", "Tatsuu", "ZR1"]
            }, {
                name: "DOOM",
                prize: 0,
                roster: ["Viiper", "Jbusom", "Tahha", "kari:D"]
            }, {
                name: "OxicPoonTang",
                prize: 0,
                roster: ["cato818", "Amuu123", "Darebydare", "Fortysevens"]
            }]
        }, {
            name: "NA",
            icon: "na",
            data: [{
                name: "nV",
                prize: 1400,
                roster: ["RandomExport", "Rickabonkers", "Kouka", "TaylorFerguson"]
            }, {
                name: "BAKA",
                prize: 600,
                roster: ["4tapp", "Gxngu", "42", "Friendlies"]
            }, {
                name: "Krunky Boys",
                prize: 0,
                roster: ["bububoosh", "GGkns", "chazzychaz", "ev0xge0"]
            }, {
                name: "RIP Theta",
                prize: 0,
                roster: ["UB_Caboose", "Applechase", "Predixtions", "Visuall"]
            }, {
                name: "Nine NA",
                prize: 0,
                roster: ["Aoqii", "Keyown", "TristanTu", "Byto"]
            }]
        }, {
            name: "OCE",
            icon: "oce",
            data: [{
                name: "Lore",
                prize: 1400,
                roster: ["Mosswi", "Agent_Chicken", "Stazza", "ShiraishiEZ"]
            }, {
                name: "Omen",
                prize: 600,
                roster: ["Equinoxian", "iiBazza", "vEternity", "Equaus"]
            }, {
                name: "Tokgang",
                prize: 0,
                roster: ["caL_Tv", "gymgoer31", "maxmillion", "peepoglad"]
            }, {
                name: "Lore v2",
                prize: 0,
                roster: ["ZaneAU", "JamemesG", "riderrr", "*Void"]
            }, {
                name: "EXLE",
                prize: 0,
                roster: ["Tatti123", "Kurocchi", "F24CTAL", "-Gaze"]
            }]
        }],
        e.exports.rankVar = .03,
        e.exports.eloPer = 120,
        e.exports.eloK = 32,
        e.exports.queues = [{
            id: "r1v1",
            name: "windows.ranked.mode.r1v1",
            key: "elo"
        }, {
            id: "r2v2",
            name: "windows.ranked.mode.r2v2",
            defaultQueue: !0,
            key: "elo2"
        }, {
            id: "r4v4",
            name: "windows.ranked.mode.r4v4",
            key: "elo4"
        }],
        e.exports.minRankedLevel = 15,
        e.exports.rankedCooldown = 72e5,
        e.exports.rankedDeduction = 30,
        e.exports.endTimer = 25e3,
        e.exports.endAnim = 5e3,
        e.exports.voteKickReq = 4,
        e.exports.voteKickMaxLvl = 10,
        e.exports.voteKickTimer = 35e3,
        e.exports.thrdPZ = 14,
        e.exports.thrdPX = 5,
        e.exports.serverConfig = [{
            name: "Players",
            varN: "maxPlayers",
            def: 2,
            max: 10,
            maxF: 16,
            min: 1,
            step: 1
        }, {
            name: "Min Players",
            varN: "minPlayers",
            def: 0,
            max: 10,
            maxF: 16,
            min: 0,
            step: 1
        }, {
            name: "Lives",
            varN: "lives",
            def: 0,
            max: 10,
            min: 0,
            step: 1
        }, {
            name: "Minutes",
            varN: "gameTime",
            def: 4,
            max: 60,
            min: 0,
            step: 1
        }, {
            name: "Warmup",
            varN: "warmupTime",
            def: 0,
            max: 4,
            min: 0,
            step: .1
        }, {
            name: "Auto Respawn",
            varN: "forceSpawn",
            def: 0,
            max: 15,
            min: 0,
            step: 1
        }, {
            name: "Score Limit",
            varN: "scoreLimit",
            def: 0,
            max: 1e4,
            min: 0,
            step: 100
        }, {
            name: "Gravity",
            varN: "gravMlt",
            dontChange: !0,
            def: 1,
            max: 2,
            min: .1,
            step: .1
        }, {
            name: "Jump Force",
            varN: "jumpMlt",
            dontChange: !0,
            def: 1,
            max: 3,
            min: .1,
            step: .1
        }, {
            name: "Hitbox Scale",
            varN: "hitBoxPad",
            dontChange: !0,
            def: 1,
            max: 1,
            min: 0,
            step: .1
        }, {
            name: "Time Scale",
            varN: "deltaMlt",
            dontChange: !0,
            def: 1,
            max: 1.5,
            min: .1,
            step: .1
        }, {
            name: "Strafe Speed",
            varN: "strafeSpd",
            dontChange: !0,
            def: 1.2,
            max: 2,
            min: 1,
            step: .1
        }, {
            name: "Health Multiplier",
            varN: "healthMlt",
            dontChange: !0,
            def: 1,
            max: 3,
            min: .1,
            step: .1
        }, {
            name: "Weapon Impulse",
            varN: "impulseMlt",
            dontChange: !0,
            def: 1,
            max: 3,
            min: 0,
            step: .1
        }, {
            name: "Team 1 Name",
            varN: "nameTeam1",
            def: "Team 1",
            hideE: !0,
            input: !0
        }, {
            name: "Team 2 Name",
            varN: "nameTeam2",
            def: "Team 2",
            hideE: !0,
            input: !0
        }, {
            name: "Select Team",
            varN: "selTeam",
            def: !1,
            bool: !0
        }, {
            name: "Spectating",
            varN: "allowSpect",
            def: !0,
            bool: !0
        }, {
            name: "Kill Rewards",
            varN: "killRewards",
            dontChange: !0,
            def: !0,
            bool: !0
        }, {
            name: "Headshots Only",
            varN: "headshotOnly",
            dontChange: !0,
            def: !1,
            bool: !0
        }, {
            name: "No Secondaries",
            varN: "noSecondary",
            dontChange: !0,
            def: !1,
            bool: !0
        }, {
            name: "Disable Streaks",
            varN: "noStreaks",
            dontChange: !0,
            def: !1,
            bool: !0
        }, {
            name: "Sliding",
            varN: "canSlide",
            def: !0,
            bool: !0
        }, {
            name: "Auto Jump",
            varN: "autoJump",
            def: !1,
            bool: !0
        }, {
            name: "3rd Person",
            varN: "thirdPerson",
            def: !1,
            bool: !0
        }, {
            name: "Hide Nametags",
            varN: "nameTags",
            def: !1,
            bool: !0
        }, {
            name: "Health Regen",
            varN: "hpRegen",
            def: !0,
            bool: !0
        }],
        e.exports.prefabIDS = ["CUBE", "CRATE", "BARREL", "LADDER", "PLANE", "SPAWN_POINT", "CAMERA_POSITION", "VEHICLE", "STACK", "RAMP", "SCORE_ZONE", "BILLBOARD", "DEATH_ZONE", "PARTICLES", "OBJECTIVE", "TREE", "CONE", "CONTAINER", "GRASS", "CONTAINERR", "ACIDBARREL", "DOOR", "WINDOW", "FLAG", "GATE", "CHECK_POINT", "WEAPON_PICKUP", "TELEPORTER", "TEDDY", "TRIGGER", "SIGN", "DEPOSIT_BOX", "LIGHT_CONE", "SPECTATE_CAM"],
        e.exports.textureIDS = ["WALL", "DIRT", "FLOOR", "GRID", "GREY", "DEFAULT", "ROOF", "FLAG", "GRASS", "CHECK", "LINES", "BRICK", "LINK"],
        e.exports.objectLimit = 3500,
        e.exports.objectLimitF = 6e3,
        e.exports.spawnLimit = 20,
        e.exports.billboardCnt = 5,
        e.exports.signLimit = 20,
        e.exports.signTextLimit = 1500,
        e.exports.signFontMax = 120,
        e.exports.signFontMin = 10,
        e.exports.gameConfig = [{
            name: "X Offset",
            varN: "camOffX",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Y Offset",
            varN: "camOffY",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Z Offset",
            varN: "camOffZ",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Enable Rotation",
            varN: "camRot",
            cat: 0,
            def: !0,
            bool: !0
        }, {
            name: "Speed X",
            varN: "speedX",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: .1
        }, {
            name: "Speed Y",
            varN: "speedY",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: .1
        }, {
            name: "Speed Z",
            varN: "speedZ",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: .1
        }],
        e.exports.followURLS = ["https://www.instagram.com/sidney.devries/", "https://www.instagram.com/sidney.devries/", "https://www.instagram.com/sidney.devries/", "https://www.instagram.com/sidney.devries/", "https://www.instagram.com/sidney.devries/", "https://www.instagram.com/sidney.devries/", "https://www.instagram.com/vincent.de.vries/"],
        e.exports.gravity = 15e-5,
        e.exports.deathY = -100,
        e.exports.skyScale = 18e3,
        e.exports.shadowDst = 1200,
        e.exports.shadowRes = 1024,
        e.exports.shadowOff = .004,
        e.exports.lightDistance = 500,
        e.exports.cornerPad = 1,
        e.exports.cornerScl = 2.5,
        e.exports.cornerH = 7,
        e.exports.wallH = 5,
        e.exports.wallW = .8,
        e.exports.propsH = ["crate", "barrel", "cone", "stack", "acidbarrel", "teddy"],
        e.exports.propsCPY = {
            teddy: -3
        },
        e.exports.propsCP = {
            barrel: -1,
            teddy: -3.6,
            cone: -2
        },
        e.exports.crateScale = 6,
        e.exports.stackScale = 6,
        e.exports.teddyScale = 6,
        e.exports.barrelScale = 4,
        e.exports.acidbarrelScale = e.exports.barrelScale,
        e.exports.treeScale = 10,
        e.exports.doorScale = 5,
        e.exports.windowScale = 6,
        e.exports.coneScale = 4,
        e.exports.containerScale = 7,
        e.exports.containerrScale = e.exports.containerScale,
        e.exports.grassScale = 32,
        e.exports.vehicleScale = 20,
        e.exports.barrelMlt = 1,
        e.exports.ladderWidth = 3.2,
        e.exports.ladderScale = .5,
        e.exports.terrainGrid = 8,
        e.exports.maxTerrainS = 4e3,
        e.exports.otherSoundMlt = .55,
        e.exports.maxParticles = 100,
        e.exports.explosionRange = 200,
        e.exports.particleDist = 40,
        e.exports.chatMaxLength = 70,
        e.exports.chatInterval = 800,
        e.exports.voiceChatInterval = 2e3,
        e.exports.voiceChatMaxLength = .65,
        e.exports.voiceRate = 500,
        e.exports.voiceDelay = 200,
        e.exports.movDirs = [];
        for (var r = 0; 8 > r; ++r)
            e.exports.movDirs.push(-Math.PI + (r + 1) * Math.PI / 4);
        e.exports.interpolation = 1.1,
        e.exports.stateHistory = 1e3,
        e.exports.syncFreq = 1e3,
        e.exports.pingCount = 10,
        e.exports.mouseSens = .0024,
        e.exports.camChaseTrn = .0022,
        e.exports.camChaseSpd = .0012,
        e.exports.camChaseSen = .2,
        e.exports.camChaseDst = 24,
        e.exports.specMinD = 10,
        e.exports.specMaxD = 160,
        e.exports.menuCamDist = 200,
        e.exports.menuCamAngle = -.5,
        e.exports.menuCamSpeed = .1,
        e.exports.idleAnimS = .0015,
        e.exports.animMult = 1.2,
        e.exports.leanPull = .99,
        e.exports.leanSens = .05,
        e.exports.leanMax = .16,
        e.exports.leanPullZ = .99,
        e.exports.leanMltZ = .03,
        e.exports.bobMltY = .024,
        e.exports.bobMltZ = .02,
        e.exports.bobPullY = .985,
        e.exports.bobPullZ = .99,
        e.exports.landPull = .994,
        e.exports.landPullV = .985,
        e.exports.landOff = .15,
        e.exports.aimAnimMlt = .18,
        e.exports.aimSlow = .55,
        e.exports.aimJumpSlow = .85,
        e.exports.stepAnim = .075,
        e.exports.stepMlt = .25,
        e.exports.stepPull = .995,
        e.exports.hpSegments = 7,
        e.exports.maxHealth = 100,
        e.exports.passiveInc = 500,
        e.exports.cameraHeight = 1.5,
        e.exports.playerSpeed = 42e-5,
        e.exports.slippingSpeed = 3e-4,
        e.exports.ladderSpeed = .035,
        e.exports.ladderDecel = .97,
        e.exports.slideDecel = .999,
        e.exports.slideTime = 350,
        e.exports.terrainSlideDecel = .9996,
        e.exports.groundDecel = .99,
        e.exports.terrainDecel = .99,
        e.exports.terrainSlipDecel = .99,
        e.exports.airSpeed = 47e-6,
        e.exports.airDecel = .9996,
        e.exports.jumpVel = .072,
        e.exports.jumpPush = .1,
        e.exports.decelMin = 1e-4,
        e.exports.climbHeight = 3,
        e.exports.wpnSpin = .018,
        e.exports.terrainSlideThreshold = 1.2,
        e.exports.terrainGravityMlt = 1.85,
        e.exports.playerSlideVelMlt = 1.2,
        e.exports.playerTerrainSlideVelMlt = .4,
        e.exports.playerSlippingJumpCooldown = 500,
        e.exports.materialDens = {
            flesh: .2,
            default: .5
        },
        e.exports.nameOffset = .6,
        e.exports.nameOffsetHat = .8,
        e.exports.maxNameLength = 14,
        e.exports.maxPassLength = 16,
        e.exports.fvcbEmTb = 11,
        e.exports.chestWidth = 2.6,
        e.exports.chestScale = 1.3,
        e.exports.armScale = 1.3,
        e.exports.legScale = 1.3,
        e.exports.uArmLength = 2.7,
        e.exports.armInset = -.1,
        e.exports.lArmLength = 2.7,
        e.exports.headScale = 2,
        e.exports.armOff = -.8,
        e.exports.legHeight = 4.2,
        e.exports.FtNDoOPu = (2 * e.exports.armScale + e.exports.chestWidth + e.exports.armInset) / 2,
        e.exports.hitBoxPad = 1,
        e.exports.tracerMinDst = 20,
        e.exports.tracerMaxDst = 500,
        e.exports.tracerChance = 1,
        e.exports.crouchLean = -.1 * Math.PI,
        e.exports.crouchDst = 3,
        e.exports.crouchSlow = .3,
        e.exports.crouchSpeed = .007,
        e.exports.crouchJump = .25,
        e.exports.crouchSpread = .55,
        e.exports.crouchAnim = 8e-4,
        e.exports.crouchAnimMlt = .5,
        e.exports.spreadMove = 25,
        e.exports.spreadFall = 30,
        e.exports.spreadRecover = .985,
        e.exports.spreadAdj = 63e-5,
        e.exports.spreadMlt = 240,
        e.exports.recoilMlt = .3,
        e.exports.flagMsg = "You have the Flag",
        e.exports.flagMsgE = "Enemy has your Flag",
        e.exports.flagMsgRC = "Enemy has your Flag",
        e.exports.flagZoneS = 24,
        e.exports.flagZoneH = 36,
        e.exports.flagScale = 12,
        e.exports.flagOff = 6,
        e.exports.flagHOff = 15,
        e.exports.interactTimer = 100,
        e.exports.pickupZoneX = 12,
        e.exports.pickupZoneZ = 4,
        e.exports.pickupZoneH = 2,
        e.exports.pickupScale = 6,
        e.exports.pickupOff = 1,
        e.exports.maxLevel = 102,
        e.exports.maxELOLevel = 8,
        e.exports.assistTime = 5e3,
        e.exports.assistScore = 25,
        e.exports.assistMin = 20,
        e.exports.medalAnim = 1e3,
        e.exports.medalDelay = 900,
        e.exports.scoreStreak = 2e3,
        e.exports.feedTimer = 2e3,
        e.exports.spinTimer = 1800,
        e.exports.endStats = ["sid", "name", "score", "kills", "deaths", "reward"],
        e.exports.endForm = {
            reward: function(e) {
                return e ? "<span style='color:#F8C55C'>+" + e + "</span> KR" : "NONE"
            },
            MMR: function(e, t, r) {
                var i = r.account && r.account[t.queueConfig.accountKey] || 0;
                return "<span style='color:#F8C55C'><span style='color:rgba(255, 255, 255, 0.7);'>" + (0 > (i = 0 <= r.ELO ? i - r.ELO : i + Math.abs(r.ELO)) ? 0 : i).round(1) + "</span> " + (0 <= r.ELO ? "+" : "-") + Math.abs(r.ELO.round(1)) + "</span>"
            },
            time: function(e, t, r) {
                return r.timer || "DNF"
            },
            infected: function(e, t, r) {
                return r.convs
            },
            found: function(e, t, r) {
                return r.convs
            },
            weapon: function(e, t, r) {
                return r.weaponTier
            }
        },
        e.exports.hitLife = 2e3,
        e.exports.regenDelay = 5e3,
        e.exports.regenVal = .1,
        e.exports.sprayTimer = 1e3,
        e.exports.sprayRange = 25,
        e.exports.sprayScale = 15,
        e.exports.deathDelay = 2800,
        e.exports.deathFollowD = 100,
        e.exports.suicides = ["uninstall life", "toaster bath", "alt f4", "not alive", "neck rope", "scooter ankle", "death.exe"],
        e.exports.taunts = [{
            id: "taunt_0",
            tm: 500
        }, {
            id: "taunt_1",
            tm: 1e3
        }, {
            id: "taunt_2",
            tm: 2300
        }, {
            id: "taunt_3",
            tm: 3200
        }],
        e.exports.fov = 70,
        e.exports.viewDist = 2e3,
        e.exports.nameVisRate = 200,
        e.exports.worldUV = 60,
        e.exports.ambientVal = .5,
        e.exports.ambD = 2,
        e.exports.ambMlt = 15,
        e.exports.ambOff = .09,
        e.exports.ambScale = 10,
        e.exports.ambDiv = 20,
        e.exports.ambSFactor = 1,
        e.exports.ambBleed = 0,
        e.exports.boosterSpd = .002,
        e.exports.borderH = 1e3,
        e.exports.soundScapes = {
            Default: 1,
            City: 2,
            Desert: 3,
            Market: 4,
            Scary: 5
        },
        e.exports.mapTabs = [{
            n: "Popular",
            cache: !0,
            c: 27,
            t: "recent"
        }, {
            n: "New",
            cache: !0,
            c: 27,
            t: "initialdate"
        }, {
            n: "My Maps",
            c: 27,
            sendID: !0,
            t: "votes"
        }, {
            n: "Search",
            search: !0,
            t: "votes"
        }],
        e.exports.modTabs = [{
            n: "Hot",
            cache: !0,
            c: 27,
            t: "recent"
        }, {
            n: "New",
            cache: !0,
            c: 27,
            t: "initialdate"
        }, {
            n: "My Mods",
            c: 27,
            sendID: !0,
            t: "votes"
        }, {
            n: "Search",
            search: !0,
            t: "votes"
        }],
        e.exports.saleMax = 1e7,
        e.exports.saleGrace = 3e5,
        e.exports.marketMinLVl = 20,
        e.exports.giftMax = 1e7,
        e.exports.giftMin = 10,
        e.exports.giftMinLVl = 30,
        e.exports.verClans = ["DEV", "FaZe", "Lore", "nV", "Oxic", "Verb", "Omen", "", "VOID", "JBP", "PHIL", "TIMP", "g59", "24/7", "GLXY", "MMOK", "ODTY"],
        e.exports.newDataInterval = 12e4,
        e.exports.socials = ["leaders", "profile", "maps", "tourney", "market", "itemsales", "clan"],
        e.exports.marketQueries = {
            market: {
                btn: "Info",
                checkItem: function(e) {
                    return !!e.funds
                }
            },
            inventory: {
                btn: "List to Sell",
                checkItem: function(e) {
                    return !e.funds && e.cnt
                }
            },
            sales: {
                btn: "Unlist",
                checkItem: function(e) {
                    return !!e.funds
                }
            }
        },
        e.exports.leaderQueries = ["player_score", "player_elo", "player_elo2", "player_elo4", "player_kills", "player_wins", "player_timeplayed", "player_funds", "player_clan"],
        e.exports.leaderCal = {
            player_score: function(t) {
                var r = Math.max(1, Math.floor(e.exports.rankVar * Math.sqrt(t)));
                return "<span class='floatR'><img src='./img/levels/" + Math.max(Math.min(e.exports.maxLevel - 1, r.roundToNearest(2) - 1), 0) + ".png' class='rnkIcon'>" + r + "</span>"
            },
            player_elo: function(t) {
                return "<span class='floatR'><img src='./img/ranks/icon_" + Math.max(Math.min(e.exports.maxELOLevel, Math.floor((t || 0) / e.exports.eloPer)), 0) + ".png' class='rnkIconR'>" + (t || 0) + "</span>"
            },
            player_elo2: function(t) {
                return "<span class='floatR'><img src='./img/ranks/icon_" + Math.max(Math.min(e.exports.maxELOLevel, Math.floor((t || 0) / e.exports.eloPer)), 0) + ".png' class='rnkIconR'>" + (t || 0) + "</span>"
            },
            player_elo4: function(t) {
                return "<span class='floatR'><img src='./img/ranks/icon_" + Math.max(Math.min(e.exports.maxELOLevel, Math.floor((t || 0) / e.exports.eloPer)), 0) + ".png' class='rnkIconR'>" + (t || 0) + "</span>"
            },
            player_kills: function(e) {
                return e + "<span class='lName'> kills</span>"
            },
            player_wins: function(e) {
                return e + "<span class='lName'> wins</span>"
            },
            player_funds: function(e) {
                return "<span style='color:rgba(0,0,0,0.4)'>" + e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + "</span> KR"
            },
            player_timeplayed: function(e) {
                var t = e / 1e3 / 60
                  , r = parseInt(t % 60);
                t /= 60;
                var i = parseInt(t % 24);
                t /= 24;
                var n = parseInt(t);
                return (n ? n + "d " : "") + (i ? i + "h " : "") + (r || 0) + "m "
            }
        },
        e.exports.socialRegions = ["All Regions", "Oceania", "Asia", "Europe", "Americas"],
        e.exports.regionNames = {
            local: "Local",
            "us-nj": "New York",
            "us-il": "Chicago",
            "us-tx": "Dallas",
            "us-wa": "Seattle",
            "us-ca-la": "Los Angeles",
            "us-ga": "Atlanta",
            "nl-ams": "Amsterdam",
            "gb-lon": "London",
            "de-fra": "Frankfurt",
            "us-ca-sv": "Silicon Valley",
            "au-syd": "Sydney",
            "fr-par": "Paris",
            "jb-hnd": "Tokyo",
            "us-fl": "Miami",
            sgp: "Singapore"
        },
        e.exports.langNames = {
            en: "English",
            es: "Spanish",
            de: "German",
            kr: "Korean"
        },
        e.exports.skinColors = [8412234, 10975328, 13864303, 13408638, 15581094],
        e.exports.customRatios = ["Native", "800x600", "1024x768", "1280x960", "1280x1024", "1440x1080", "1656x1080"],
        e.exports.reportOptions = ["Hacking", "Exploiting", "Market Manipulation", "Harassment", "Other"]
    }
    ).call(this, r(14))
}
, function(e, t, r) {
    (function(t) {
        const i = r(7)
          , n = r(35);
        e.exports.keyboardMap = ["", "", "", "CANCEL", "", "", "HELP", "", "BACK_SPACE", "TAB", "", "", "CLEAR", "ENTER", "ENTER_SPECIAL", "", "SHIFT", "CONTROL", "ALT", "PAUSE", "CAPS_LOCK", "KANA", "EISU", "JUNJA", "FINAL", "HANJA", "", "ESCAPE", "CONVERT", "NONCONVERT", "ACCEPT", "MODECHANGE", "SPACE", "PAGE_UP", "PAGE_DOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "SELECT", "PRINT", "EXECUTE", "PRINTSCREEN", "INSERT", "DELETE", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "COLON", "SEMICOLON", "LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "AT", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "OS_KEY", "", "CONTEXT_MENU", "", "SLEEP", "NUMPAD0", "NUMPAD1", "NUMPAD2", "NUMPAD3", "NUMPAD4", "NUMPAD5", "NUMPAD6", "NUMPAD7", "NUMPAD8", "NUMPAD9", "MULTIPLY", "ADD", "SEPARATOR", "SUBTRACT", "DECIMAL", "DIVIDE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "NUM_LOCK", "SCROLL_LOCK", "WIN_OEM_FJ_JISHO", "WIN_OEM_FJ_MASSHOU", "WIN_OEM_FJ_TOUROKU", "WIN_OEM_FJ_LOYA", "WIN_OEM_FJ_ROYA", "", "", "", "", "", "", "", "", "", "CIRCUMFLEX", "EXCLAMATION", "DOUBLE_QUOTE", "HASH", "DOLLAR", "PERCENT", "AMPERSAND", "UNDERSCORE", "OPEN_PAREN", "CLOSE_PAREN", "ASTERISK", "PLUS", "PIPE", "HYPHEN_MINUS", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "TILDE", "", "", "", "", "VOLUME_MUTE", "VOLUME_DOWN", "VOLUME_UP", "", "", "SEMICOLON", "EQUALS", "COMMA", "MINUS", "PERIOD", "SLASH", "BACK_QUOTE", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OPEN_BRACKET", "BACK_SLASH", "CLOSE_BRACKET", "QUOTE", "", "META", "ALTGR", "", "WIN_ICO_HELP", "WIN_ICO_00", "", "WIN_ICO_CLEAR", "", "", "WIN_OEM_RESET", "WIN_OEM_JUMP", "WIN_OEM_PA1", "WIN_OEM_PA2", "WIN_OEM_PA3", "WIN_OEM_WSCTRL", "WIN_OEM_CUSEL", "WIN_OEM_ATTN", "WIN_OEM_FINISH", "WIN_OEM_COPY", "WIN_OEM_AUTO", "WIN_OEM_ENLW", "WIN_OEM_BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN_OEM_CLEAR", ""],
        e.exports.getB64Size = function() {}
        ,
        Number.prototype.round = function(e) {
            return +this.toFixed(e)
        }
        ,
        String.prototype.escape = function() {
            return (this + "").replace(/[\\"']/g, "\\$&").replace(/\u0000/g, "\\0")
        }
        ,
        Number.prototype.roundToNearest = function(e) {
            return 0 < this ? Math.ceil(this / e) * e : 0 > this ? Math.floor(this / e) * e : this
        }
        ,
        e.exports.capFirst = function(e) {
            return e.charAt(0).toUpperCase() + e.slice(1)
        }
        ,
        e.exports.isURL = function(e) {
            try {
                return /^(https?:\/\/)?((([a-z\d]([a-z\d-]*[a-z\d])*)\.)+[a-z]{2,}|((\d{1,3}\.){3}\d{1,3}))(\:\d+)?(\/[-a-z\d%@_.~+&:]*)*(\?[;&a-z\d%@_.,~+&:=-]*)?(\#[-a-z\d_]*)?$/i.test(e)
            } catch (e) {}
            return !1
        }
        ,
        e.exports.arrayAverage = function(e) {
            for (var t = 0, r = 0; r < e.length; r++)
                t += e[r];
            return t / e.length
        }
        ,
        e.exports.countInArray = function(e, t) {
            for (var r = 0, i = 0; i < e.length; i++)
                e[i] === t && r++;
            return r
        }
        ,
        e.exports.formatNum = function(e, t=1) {
            var r = Math.floor(Math.log(Math.abs(e)) / Math.log(1e3))
              , i = "kmb"[r - 1];
            return i ? (e / Math.pow(1e3, r)).toFixed(t) + i : "" + e
        }
        ,
        e.exports.randInt = function(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }
        ,
        e.exports.randFloat = function(e, t) {
            return Math.random() * (t - e) + e
        }
        ,
        e.exports.getPercentDiff = function(e, t) {
            return Math.round((t - e) / e * 100, 1)
        }
        ,
        e.exports.getRandom = function(t) {
            return t[e.exports.randInt(0, t.length - 1)]
        }
        ,
        e.exports.getDistance = function(e, t, r, i) {
            return Math.sqrt((r -= e) * r + (i -= t) * i)
        }
        ,
        e.exports.getD3D = function(e, t, r, i, n, s) {
            var a = e - i
              , o = t - n
              , c = r - s;
            return Math.sqrt(a * a + o * o + c * c)
        }
        ,
        e.exports.getAnglesSSS = function(e, t, r) {
            var i = Math.acos((t * t + r * r - e * e) / (2 * t * r))
              , n = Math.acos((r * r + e * e - t * t) / (2 * r * e))
              , s = Math.PI - i - n;
            return [-i - Math.PI / 2, n, s]
        }
        ,
        e.exports.getXDire = function(t, r, i, n, s, a) {
            var o = Math.abs(r - s)
              , c = e.exports.getD3D(t, r, i, n, s, a);
            return Math.asin(o / c) * (r > s ? -1 : 1)
        }
        ,
        e.exports.getAngleDst = function(e, t) {
            return Math.atan2(Math.sin(t - e), Math.cos(e - t))
        }
        ,
        e.exports.getAngleDist2 = function(e, t) {
            var r = Math.abs(t - e) % (2 * Math.PI);
            return r > Math.PI ? 2 * Math.PI - r : r
        }
        ,
        e.exports.toRad = function(e) {
            return e * (Math.PI / 180)
        }
        ,
        e.exports.getDir = function(e, t, r, i) {
            return Math.atan2(t - i, e - r)
        }
        ,
        e.exports.lerp = function(e, t, r) {
            return e + (t - e) * r
        }
        ,
        e.exports.orderByScore = function(e, t) {
            return t.score - e.score
        }
        ,
        e.exports.orderByKills = function(e, t) {
            return t.kills - e.kills
        }
        ,
        e.exports.orderByDst = function(e, t) {
            return e.dst - t.dst
        }
        ,
        e.exports.orderByNum = function(e, t) {
            return e - t
        }
        ,
        e.exports.capFirst = function(e) {
            return e.charAt(0).toUpperCase() + e.slice(1)
        }
        ,
        e.exports.truncateText = function(e, t) {
            return e.length > t ? e.substring(0, t) + "..." : e
        }
        ,
        e.exports.cleanseString = function(e) {
            return e ? e.replace(/['"]+/g, "") : e
        }
        ,
        e.exports.randomString = function(e) {
            for (var t = "", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = 0; i < e; i++)
                t += r.charAt(Math.floor(Math.random() * r.length));
            return t
        }
        ,
        e.exports.formatNumCash = function(e) {
            return parseFloat(Math.round(100 * e) / 100).toFixed(2)
        }
        ,
        e.exports.getKeyName = function(t) {
            return 0 > t ? "UNBOUND" : 2e4 == t ? "SCROLL" : 1e4 < t ? "M" + (t - 1e4) : e.exports.keyboardMap[t]
        }
        ;
        var s = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        e.exports.getDate = function(e) {
            if (!e)
                return "None";
            e = e.split(/[-A-Z :\.]/i);
            var t = new Date(e[0],--e[1],e[2],e[3],e[4],e[5])
              , r = new Date(t.getTime());
            return r.getDate() + " " + s[r.getMonth()] + " " + r.getFullYear()
        }
        ,
        e.exports.getTime = function(e, t) {
            if ("inf" == e)
                return "Infinite";
            var r = parseInt(e % 1e3 / 100)
              , i = parseInt(e / 1e3 % 60)
              , n = parseInt(e / 6e4 % 60);
            return (n = 10 > n ? "0" + n : n) + ":" + (i = 10 > i ? "0" + i : i) + (t ? "." + r : "")
        }
        ,
        e.exports.commaFormatNum = function(e) {
            return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
        }
        ,
        e.exports.getReadableTime = function(e, t) {
            var r = Math.floor(e / 1e3)
              , i = Math.floor(r / 60);
            r %= 60;
            var n = Math.floor(i / 60);
            i %= 60;
            var s = Math.floor(n / 24);
            return (s ? s + "d " : "") + ((n %= 24) ? n + "h " : "") + (i || 0) + "m " + (t ? r + "s" : "")
        }
        ,
        e.exports.getReadableTime2 = function(e) {
            if (0 > e)
                return "just now";
            var t = Math.floor(e / 1e3)
              , r = Math.floor(t / 60)
              , i = Math.floor(r / 60);
            r %= 60;
            var n = Math.floor(i / 24);
            return i %= 24,
            n ? n + "d ago" : i ? i + "h ago" : r ? r + "m ago" : "just now"
        }
        ,
        e.exports.getTimeH = function(e) {
            parseInt(e % 1e3 / 100);
            var t = Math.floor(e / 1e3 % 60)
              , r = Math.floor(e / 6e4 % 60)
              , i = Math.floor(e / 36e5 % 24);
            return (i = 10 > i ? "0" + i : i) + ":" + (r = 10 > r ? "0" + r : r) + ":" + (t = 10 > t ? "0" + t : t)
        }
        ,
        e.exports.scrambleS = function(e) {
            return e && e.replace ? e.replace(/.(.)?/g, "$1") + ("d" + e).replace(/.(.)?/g, "$1") : e
        }
        ,
        e.exports.sanitizeStr = function(e) {
            return e && e.replace ? e.replace(/<|>|&/g, "").replace(/[^\x00-\x7F]/g, "") : e
        }
        ,
        e.exports.fixTo = function(e, t) {
            return parseFloat(e.toFixed(t))
        }
        ,
        e.exports.limit = function(e, t) {
            return e < -t ? -t : e > t ? t : e
        }
        ,
        e.exports.limitMM = function(e, t, r) {
            return e < t ? t : e > r ? r : e
        }
        ,
        e.exports.cropVal = function(e, t) {
            return e <= t && e >= -t ? 0 : e
        }
        ,
        e.exports.isNumber = function(e) {
            return null != e && "number" == typeof e && !isNaN(e) && isFinite(e)
        }
        ,
        e.exports.arrayInts = function(t) {
            for (var r = 0; r < t.length; ++r)
                if (!e.exports.isNumber(t[r]))
                    return !1;
            return !0
        }
        ,
        e.exports.isArray = function(e) {
            return !!e && e.constructor === Array
        }
        ,
        e.exports.isString = function(e) {
            return e && "string" == typeof e
        }
        ,
        e.exports.emptyString = function(e) {
            return !e || 0 === e.length || /^\s*$/.test(e) || !e.trim()
        }
        ,
        e.exports.compareString = function(e, t) {
            return 0 <= e.toLowerCase().indexOf(t.toLowerCase()) || 0 <= t.toLowerCase().indexOf(e.toLowerCase())
        }
        ;
        e.exports.lineInRect = function(e, t, r, i, n, s, a, o, c, l, p, h) {
            var u = (a - e) * i
              , d = (l - e) * i
              , f = (c - r) * s
              , m = (h - r) * s
              , g = (o - t) * n
              , v = (p - t) * n
              , y = Math.max(Math.max(Math.min(u, d), Math.min(f, m)), Math.min(g, v))
              , b = Math.min(Math.min(Math.max(u, d), Math.max(f, m)), Math.max(g, v));
            return !(0 > b) && !(y > b) && y
        }
        ,
        e.exports.pointInBox3D = function(e, t, r, i, n) {
            return n = n || 0,
            e >= i.x - i.width - n && e <= i.x + i.width + n && t >= i.y - i.height - n && t <= i.y + i.height + n && r >= i.z - i.length - n && r <= i.z + i.length + n
        }
        ,
        e.exports.similar = function(e, t, r) {
            return r = r || 0,
            Math.abs(e - t) <= r
        }
        ,
        e.exports.pointInBox = function(e, t, r, i, n, s, a) {
            return a ? e >= r && e <= n && t >= i && t <= s : e > r && e < n && t > i && t < s
        }
        ,
        e.exports.sharePos = function(e, t, r) {
            return r = r || 0,
            Math.abs(e.x - t.x) <= r && Math.abs(e.y - t.y) <= r && Math.abs(e.z - t.z) <= r && Math.abs(e.d - t.d) <= r
        }
        ,
        e.exports.cdv = {
            x: "width",
            y: "height",
            z: "length"
        },
        e.exports.boxIntersection = function(t, r, i, n, s) {
            var a = e.exports.cdv[i]
              , o = e.exports.cdv[n]
              , c = t[i] - t[a] - .1
              , l = r[i] - r[a] - .1
              , p = t[i] + t[a] + .1
              , h = r[i] + r[a] + .1
              , u = t[n] - t[o] - .1
              , d = r[n] - r[o] - .1
              , f = t[n] + t[o] + .1
              , m = r[n] + r[o] + .1
              , g = Math.max(c, l)
              , v = Math.min(p, h);
            if (v >= g) {
                var y = Math.max(u, d)
                  , b = Math.min(f, m);
                if (b >= y) {
                    for (var w = [{
                        [i]: g,
                        [n]: y,
                        d: s[0]
                    }, {
                        [i]: v,
                        [n]: b,
                        d: s[1]
                    }, {
                        [i]: g,
                        [n]: b,
                        d: s[2]
                    }, {
                        [i]: v,
                        [n]: y,
                        d: s[3]
                    }], x = w.length - 1; 0 <= x; --x)
                        (w[x][i] == p && w[x][i] == h || w[x][i] == c && w[x][i] == l || w[x][n] == f && w[x][n] == m || w[x][n] == u && w[x][n] == d || e.exports.pointInBox(w[x][i], w[x][n], c, u, p, f) || e.exports.pointInBox(w[x][i], w[x][n], l, d, h, m)) && (w[x].dontUse = !0);
                    return w
                }
            }
            return null
        }
        ,
        e.exports.boxCornerIntersection = function(t, r, i, n) {
            for (var s = e.exports.cdv[i], a = e.exports.cdv[n], o = t[i] - t[s], c = r[i] - r[s], l = t[i] + t[s], p = r[i] + r[s], h = t[n] - t[a], u = r[n] - r[a], d = t[n] + t[a], f = r[n] + r[a], m = [{
                [i]: o,
                [n]: h,
                d: Math.PI / 2
            }, {
                [i]: o,
                [n]: d,
                d: Math.PI
            }, {
                [i]: l,
                [n]: h,
                d: 0
            }, {
                [i]: l,
                [n]: d,
                d: -Math.PI / 2
            }], g = m.length - 1; 0 <= g; --g)
                m[g].i = g,
                e.exports.pointInBox(m[g][i], m[g][n], c, u, p, f, !0) || m.splice(g, 1);
            return m.length ? m : null
        }
        ,
        e.exports.getIntersection = function(t, r, i) {
            var n = e.exports.cdv[i]
              , s = t[i] - t[n]
              , a = r[i] - r[n]
              , o = t[i] + t[n]
              , c = r[i] + r[n]
              , l = Math.max(s, a)
              , p = Math.min(o, c);
            if (p >= l) {
                var h = (p - l) / 2;
                return {
                    [i]: l + h,
                    [n]: h
                }
            }
            return null
        }
        ,
        e.exports.limitRectVal = function(t, r, i) {
            var n = e.exports.cdv[i];
            if (t[i] - t[n] < r[i] - r[n]) {
                var s = (r[i] - r[n] - (t[i] - t[n])) / 2;
                t[n] -= s,
                t[i] += s
            }
            if (t[i] + t[n] > r[i] + r[n]) {
                s = (t[i] + t[n] - (r[i] + r[n])) / 2;
                t[n] -= s,
                t[i] -= s
            }
        }
        ,
        e.exports.getMaxRect = function(t, r, i) {
            for (var n, s, a, o, c = e.exports.cdv[r], l = e.exports.cdv[i], p = 0; p < t.length; ++p)
                n = null == n ? t[p][r] - t[p][c] : Math.min(t[p][r] - t[p][c], n),
                a = null == a ? t[p][r] + t[p][c] : Math.max(t[p][r] + t[p][c], a),
                s = null == s ? t[p][i] - t[p][l] : Math.min(t[p][i] - t[p][l], s),
                o = null == o ? t[p][i] + t[p][l] : Math.max(t[p][i] + t[p][l], o);
            return {
                [r]: (n + a) / 2,
                [i]: (s + o) / 2,
                [c]: Math.abs(a - n) / 2,
                [l]: Math.abs(o - s) / 2
            }
        }
        ,
        e.exports.limitRect = function(t, r, i, n, s, a, o, c) {
            var l = e.exports.getMaxRect(a, o, c)
              , p = e.exports.cdv[o]
              , h = e.exports.cdv[c]
              , u = {};
            if (u[o] = t,
            u[c] = r,
            u[p] = i,
            u[h] = n,
            e.exports.limitRectVal(u, l, o),
            e.exports.limitRectVal(u, l, c),
            0 == s || s == Math.PI) {
                var d = u[p];
                u[p] = u[h],
                u[h] = d
            }
            return u
        }
        ,
        e.exports.progressOnLine = function(e, t, r, i, n, s) {
            var a = r - e
              , o = i - t
              , c = Math.sqrt(a * a + o * o);
            return ((a /= c) * (n - e) + (o /= c) * (s - t)) / Math.sqrt(Math.pow(r - e, 2) + Math.pow(i - t, 2))
        }
        ,
        e.exports.generateSID = function(e) {
            for (var t = 0, r = !0; r; ) {
                r = !1,
                t++;
                for (var i = 0; i < e.length; ++i)
                    if (e[i].sid == t) {
                        r = !0;
                        break
                    }
            }
            return t
        }
        ,
        e.exports.levelIconId = function(e) {
            return Math.max(Math.min(i.maxLevel - 1, e.roundToNearest(2) - 1), 0)
        }
        ,
        e.exports.eloIconId = function(e) {
            return Math.max(Math.min(i.maxELOLevel, Math.floor((e || 0) / i.eloPer)), 0)
        }
        ,
        e.exports.copyToClipboard = function(e) {
            const t = document.createElement("textarea");
            t.value = e,
            t.setAttribute("readonly", ""),
            t.style.position = "absolute",
            t.style.left = "-9999px",
            document.body.appendChild(t);
            const r = !!(0 < document.getSelection().rangeCount) && document.getSelection().getRangeAt(0);
            t.select(),
            document.execCommand("copy"),
            document.body.removeChild(t),
            r && (document.getSelection().removeAllRanges(),
            document.getSelection().addRange(r))
        }
        ;
        var a = function(e, t) {
            return e.concat(t)
        };
        Array.prototype.flatMap = function(e) {
            return function(e, t) {
                return t.map(e).reduce(a, [])
            }(e, this)
        }
        ;
        var o = r(39);
        e.exports.encodeNetworkMessage = function(t, r) {
            let i = o.encode(t)
              , n = new Uint8Array(i.length + 2);
            return n.set(e.exports.encodeShort(r), n.length - 2),
            n.set(i, 0),
            n
        }
        ,
        e.exports.decodeNetworkMessage = function(t) {
            t = new Uint8Array(t);
            let r = e.exports.decodeShort(t[t.length - 2], t[t.length - 1])
              , i = t.slice(0, t.length - 2);
            return [o.decode(i), r]
        }
        ,
        e.exports.rotateNumber = function(e, t) {
            return 255 & e + t
        }
        ,
        e.exports.encodeShort = function(e) {
            return [15 & e >> 4, 15 & e]
        }
        ,
        e.exports.decodeShort = function(e, t) {
            return (e << 4) + t
        }
        ,
        e.exports.restartIfNeeded = function(e) {
            if (i.needsRestart) {
                for (var r in e.sockets) {
                    var n = e.sockets[r];
                    n.send("error", "GAME UPDATING"),
                    n.close()
                }
                setTimeout(function() {
                    t.exit()
                }, 1e3)
            }
        }
        ,
        e.exports.thumbnailSize = function(e) {
            return parseInt(.75 * e.replace(/=/g, "").length) / 1e3
        }
        ,
        e.exports.hexToRGB = (e=>e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (e,t,r,i)=>"#" + t + t + r + r + i + i).substring(1).match(/.{2}/g).map(e=>parseInt(e, 16))),
        e.exports.versionifyUrl = function(e) {
            return e + "?build=" + n
        }
        ,
        e.exports.assetsUrl = function(e) {
            return e.startsWith("/") && (e = e.slice(1)),
            this.versionifyUrl("https://hoodgail.github.io/krunker_assets/" + e)
        }
        ,
        e.exports.getPreview = function(t, r) {
            return e.exports.assetsUrl("/textures/previews/" + (t.type && 3 > t.type ? "cosmetics/" + t.type + "_" + t.id + (t.tex ? "_" + t.tex : "") : r.types[t.type || 0] + (t.type && 3 == t.type ? t.id + (null == t.tex ? "" : "_" + t.tex) : (t.weapon || 0) + "_" + (null == t.mid ? null == t.pat ? t.tex ? t.tex : t.id : "c" + t.pat : "m" + t.mid + (null == t.midT ? "" : "_" + t.midT.split("_").slice(-1)[0])))) + ".png")
        }
        ,
        e.exports.toSocial = function(t) {
            return `./social.html?p=profile&q=${e.exports.cleanseString(t)}`
        }
        ,
        e.exports.isDropbox = function(e) {
            return /^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?(dropbox|dropboxusercontent|dl\.dropboxusercontent)\.com\//g.test(e)
        }
        ,
        e.exports.ctxText = function(e, t, r, i, n) {
            e.save(),
            e.translate(~~i, ~~n),
            e.fillStyle = r,
            e.strokeStyle = "rgba(0, 0, 0, 0.5)",
            e.lineWidth = 1,
            e.strokeText(t, 0, 0),
            e.fillText(t, 0, 0),
            e.restore()
        }
        ,
        e.exports.getLines = function(e, t, r) {
            for (var i = t.split(" "), n = [], s = i[0], a = 1; a < i.length; a++) {
                var o = i[a];
                e.measureText(s + " " + o).width < r ? s += " " + o : (n.push(s),
                s = o)
            }
            return n.push(s),
            n
        }
        ,
        e.exports.createCanvasText = function(t, r, n, s, a, o, c, l) {
            var p = 0
              , h = 0;
            r > t ? (p = 1,
            h = t / r) : r < t ? (p = r / t,
            h = 1) : (p = 1,
            h = 1);
            var u = document.createElement("canvas")
              , d = u.getContext("2d");
            u.width = 1024 * h,
            u.height = 1024 * p,
            c || (d.fillStyle = o,
            d.fillRect(0, 0, u.width, u.height));
            var f = s;
            d.font = f + "px GameFont",
            n = n.substring(0, i.signTextLimit - 1),
            d.textAlign = 2 == l ? "right" : 1 == l ? "center" : "left";
            var m = 2 * f
              , g = d.measureText("M").width / 2;
            g = 2 == l ? u.width - g : 1 == l ? u.width / 2 : g;
            for (var v = 1.2 * d.measureText("M").width, y = n.split("\\n"), b = null, w = 0; w < y.length; ++w) {
                b = e.exports.getLines(d, y[w], u.width - f);
                for (var x = 0; x < b.length && (e.exports.ctxText(d, b[x], a, g, m),
                !((m += v) > u.height)); ++x)
                    ;
            }
            return u
        }
    }
    ).call(this, r(14))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        r.d(t, "a", function() {
            return c
        }),
        r.d(t, "b", function() {
            return h
        }),
        r.d(t, "c", function() {
            return d
        });
        var i = r(0)
          , n = r(2)
          , s = r(25)
          , a = r(10)
          , o = 3
          , c = function() {
            function e(e, t, r) {
                void 0 === t && (t = new a.a),
                void 0 === r && (r = o),
                this._version = r,
                this._stack = [],
                this._stack.push({
                    client: e,
                    scope: t
                })
            }
            return e.prototype._invokeClient = function(e) {
                for (var t, r = [], n = 1; n < arguments.length; n++)
                    r[n - 1] = arguments[n];
                var s = this.getStackTop();
                s && s.client && s.client[e] && (t = s.client)[e].apply(t, i.d(r, [s.scope]))
            }
            ,
            e.prototype.isOlderThan = function(e) {
                return this._version < e
            }
            ,
            e.prototype.bindClient = function(e) {
                this.getStackTop().client = e
            }
            ,
            e.prototype.pushScope = function() {
                var e = this.getStack()
                  , t = 0 < e.length ? e[e.length - 1].scope : void 0
                  , r = a.a.clone(t);
                return this.getStack().push({
                    client: this.getClient(),
                    scope: r
                }),
                r
            }
            ,
            e.prototype.popScope = function() {
                return void 0 !== this.getStack().pop()
            }
            ,
            e.prototype.withScope = function(e) {
                var t = this.pushScope();
                try {
                    e(t)
                } finally {
                    this.popScope()
                }
            }
            ,
            e.prototype.getClient = function() {
                return this.getStackTop().client
            }
            ,
            e.prototype.getScope = function() {
                return this.getStackTop().scope
            }
            ,
            e.prototype.getStack = function() {
                return this._stack
            }
            ,
            e.prototype.getStackTop = function() {
                return this._stack[this._stack.length - 1]
            }
            ,
            e.prototype.captureException = function(e, t) {
                var r = this._lastEventId = Object(n.g)();
                return this._invokeClient("captureException", e, i.a({}, t, {
                    event_id: r
                })),
                r
            }
            ,
            e.prototype.captureMessage = function(e, t, r) {
                var s = this._lastEventId = Object(n.g)();
                return this._invokeClient("captureMessage", e, t, i.a({}, r, {
                    event_id: s
                })),
                s
            }
            ,
            e.prototype.captureEvent = function(e, t) {
                var r = this._lastEventId = Object(n.g)();
                return this._invokeClient("captureEvent", e, i.a({}, t, {
                    event_id: r
                })),
                r
            }
            ,
            e.prototype.lastEventId = function() {
                return this._lastEventId
            }
            ,
            e.prototype.addBreadcrumb = function(e, t) {
                var r = this.getStackTop();
                if (r.scope && r.client) {
                    var s = r.client.getOptions && r.client.getOptions() || {}
                      , a = s.beforeBreadcrumb
                      , o = void 0 === a ? null : a
                      , c = s.maxBreadcrumbs
                      , l = void 0 === c ? 30 : c;
                    if (!(0 >= l)) {
                        var p = (new Date).getTime() / 1e3
                          , h = i.a({
                            timestamp: p
                        }, e)
                          , u = o ? Object(n.b)(function() {
                            return o(h, t)
                        }) : h;
                        null === u || r.scope.addBreadcrumb(u, Math.min(l, 100))
                    }
                }
            }
            ,
            e.prototype.setUser = function(e) {
                var t = this.getStackTop();
                t.scope && t.scope.setUser(e)
            }
            ,
            e.prototype.setTags = function(e) {
                var t = this.getStackTop();
                t.scope && t.scope.setTags(e)
            }
            ,
            e.prototype.setExtras = function(e) {
                var t = this.getStackTop();
                t.scope && t.scope.setExtras(e)
            }
            ,
            e.prototype.setTag = function(e, t) {
                var r = this.getStackTop();
                r.scope && r.scope.setTag(e, t)
            }
            ,
            e.prototype.setExtra = function(e, t) {
                var r = this.getStackTop();
                r.scope && r.scope.setExtra(e, t)
            }
            ,
            e.prototype.setContext = function(e, t) {
                var r = this.getStackTop();
                r.scope && r.scope.setContext(e, t)
            }
            ,
            e.prototype.configureScope = function(e) {
                var t = this.getStackTop();
                t.scope && t.client && e(t.scope)
            }
            ,
            e.prototype.run = function(e) {
                var t = p(this);
                try {
                    e(this)
                } finally {
                    p(t)
                }
            }
            ,
            e.prototype.getIntegration = function(e) {
                var t = this.getClient();
                if (!t)
                    return null;
                try {
                    return t.getIntegration(e)
                } catch (t) {
                    return s.a.warn("Cannot retrieve integration " + e.id + " from the current Hub"),
                    null
                }
            }
            ,
            e.prototype.traceHeaders = function() {
                var e = this.getStackTop();
                if (e.scope && e.client) {
                    var t = e.scope.getSpan();
                    if (t)
                        return {
                            "sentry-trace": t.toTraceparent()
                        }
                }
                return {}
            }
            ,
            e
        }();
        function l() {
            var e = Object(n.e)();
            return e.__SENTRY__ = e.__SENTRY__ || {
                hub: void 0
            },
            e
        }
        function p(e) {
            var t = l()
              , r = d(t);
            return f(t, e),
            r
        }
        function h() {
            var t = l();
            (!u(t) || d(t).isOlderThan(o)) && f(t, new c);
            try {
                var r = Object(n.c)(e, "domain").active;
                if (!r)
                    return d(t);
                if (!u(r) || d(r).isOlderThan(o)) {
                    var i = d(t).getStackTop();
                    f(r, new c(i.client,a.a.clone(i.scope)))
                }
                return d(r)
            } catch (e) {
                return d(t)
            }
        }
        function u(e) {
            return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
        }
        function d(e) {
            return e && e.__SENTRY__ && e.__SENTRY__.hub ? e.__SENTRY__.hub : (e.__SENTRY__ = e.__SENTRY__ || {},
            e.__SENTRY__.hub = new c,
            e.__SENTRY__.hub)
        }
        function f(e, t) {
            return !!e && (e.__SENTRY__ = e.__SENTRY__ || {},
            e.__SENTRY__.hub = t,
            !0)
        }
    }
    ).call(this, r(63)(e))
}
, function(e, t, r) {
    "use strict";
    r.d(t, "a", function() {
        return l
    }),
    r.d(t, "b", function() {
        return h
    });
    var i = r(0)
      , n = r(72)
      , s = r(5)
      , a = r(6)
      , o = r(2)
      , c = r(13)
      , l = function() {
        function e() {
            this._notifyingListeners = !1,
            this._scopeListeners = [],
            this._eventProcessors = [],
            this._breadcrumbs = [],
            this._user = {},
            this._tags = {},
            this._extra = {},
            this._context = {}
        }
        return e.prototype.addScopeListener = function(e) {
            this._scopeListeners.push(e)
        }
        ,
        e.prototype.addEventProcessor = function(e) {
            return this._eventProcessors.push(e),
            this
        }
        ,
        e.prototype._notifyScopeListeners = function() {
            var e = this;
            this._notifyingListeners || (this._notifyingListeners = !0,
            setTimeout(function() {
                e._scopeListeners.forEach(function(t) {
                    t(e)
                }),
                e._notifyingListeners = !1
            }))
        }
        ,
        e.prototype._notifyEventProcessors = function(e, t, r, a) {
            var o = this;
            return void 0 === a && (a = 0),
            new n.a(function(n, c) {
                var l = e[a];
                if (null === t || "function" != typeof l)
                    n(t);
                else {
                    var p = l(i.a({}, t), r);
                    Object(s.j)(p) ? p.then(function(t) {
                        return o._notifyEventProcessors(e, t, r, a + 1).then(n)
                    }).catch(c) : o._notifyEventProcessors(e, p, r, a + 1).then(n).catch(c)
                }
            }
            )
        }
        ,
        e.prototype.setUser = function(e) {
            return this._user = Object(a.b)(e),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setTags = function(e) {
            return this._tags = i.a({}, this._tags, Object(a.b)(e)),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setTag = function(e, t) {
            var r;
            return this._tags = i.a({}, this._tags, ((r = {})[e] = Object(a.b)(t),
            r)),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setExtras = function(e) {
            return this._extra = i.a({}, this._extra, Object(a.b)(e)),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setExtra = function(e, t) {
            var r;
            return this._extra = i.a({}, this._extra, ((r = {})[e] = Object(a.b)(t),
            r)),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setFingerprint = function(e) {
            return this._fingerprint = Object(a.b)(e),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setLevel = function(e) {
            return this._level = Object(a.b)(e),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setTransaction = function(e) {
            return this._transaction = e,
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setContext = function(e, t) {
            return this._context[e] = t ? Object(a.b)(t) : void 0,
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.setSpan = function(e) {
            return this._span = e,
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.startSpan = function(e) {
            var t = new c.a;
            return t.setParent(e),
            this.setSpan(t),
            t
        }
        ,
        e.prototype.getSpan = function() {
            return this._span
        }
        ,
        e.clone = function(t) {
            var r = new e;
            return Object.assign(r, t, {
                _scopeListeners: []
            }),
            t && (r._breadcrumbs = i.d(t._breadcrumbs),
            r._tags = i.a({}, t._tags),
            r._extra = i.a({}, t._extra),
            r._context = i.a({}, t._context),
            r._user = t._user,
            r._level = t._level,
            r._span = t._span,
            r._transaction = t._transaction,
            r._fingerprint = t._fingerprint,
            r._eventProcessors = i.d(t._eventProcessors)),
            r
        }
        ,
        e.prototype.clear = function() {
            return this._breadcrumbs = [],
            this._tags = {},
            this._extra = {},
            this._user = {},
            this._context = {},
            this._level = void 0,
            this._transaction = void 0,
            this._fingerprint = void 0,
            this._span = void 0,
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.addBreadcrumb = function(e, t) {
            var r = (new Date).getTime() / 1e3
              , n = i.a({
                timestamp: r
            }, e);
            return this._breadcrumbs = void 0 !== t && 0 <= t ? i.d(this._breadcrumbs, [Object(a.b)(n)]).slice(-t) : i.d(this._breadcrumbs, [Object(a.b)(n)]),
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype.clearBreadcrumbs = function() {
            return this._breadcrumbs = [],
            this._notifyScopeListeners(),
            this
        }
        ,
        e.prototype._applyFingerprint = function(e) {
            e.fingerprint = e.fingerprint ? Array.isArray(e.fingerprint) ? e.fingerprint : [e.fingerprint] : [],
            this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)),
            e.fingerprint && !e.fingerprint.length && delete e.fingerprint
        }
        ,
        e.prototype.applyToEvent = function(e, t) {
            return this._extra && Object.keys(this._extra).length && (e.extra = i.a({}, this._extra, e.extra)),
            this._tags && Object.keys(this._tags).length && (e.tags = i.a({}, this._tags, e.tags)),
            this._user && Object.keys(this._user).length && (e.user = i.a({}, this._user, e.user)),
            this._context && Object.keys(this._context).length && (e.contexts = i.a({}, this._context, e.contexts)),
            this._level && (e.level = this._level),
            this._transaction && (e.transaction = this._transaction),
            this._span && (e.contexts = e.contexts || {},
            e.contexts.trace = this._span),
            this._applyFingerprint(e),
            e.breadcrumbs = i.d(e.breadcrumbs || [], this._breadcrumbs),
            e.breadcrumbs = 0 < e.breadcrumbs.length ? e.breadcrumbs : void 0,
            this._notifyEventProcessors(i.d(p(), this._eventProcessors), e, t)
        }
        ,
        e
    }();
    function p() {
        var e = Object(o.e)();
        return e.__SENTRY__ = e.__SENTRY__ || {},
        e.__SENTRY__.globalEventProcessors = e.__SENTRY__.globalEventProcessors || [],
        e.__SENTRY__.globalEventProcessors
    }
    function h(e) {
        p().push(e)
    }
}
, function(e, t) {
    var r = {}.toString;
    e.exports = Array.isArray || function(e) {
        return "[object Array]" == r.call(e)
    }
}
, function(e, t, r) {
    var i = r(11);
    t.createCodec = o,
    t.install = function(e) {
        for (var t in e)
            s.prototype[t] = a(s.prototype[t], e[t])
    }
    ,
    t.filter = function(e) {
        return i(e) ? function(e) {
            function t(e, t) {
                return t(e)
            }
            return e = e.slice(),
            function(r) {
                return e.reduce(t, r)
            }
        }(e) : e
    }
    ;
    var n = r(3);
    function s(e) {
        return this instanceof s ? (this.options = e,
        void this.init()) : new s(e)
    }
    function a(e, t) {
        return e && t ? function() {
            return e.apply(this, arguments),
            t.apply(this, arguments)
        }
        : e || t
    }
    function o(e) {
        return new s(e)
    }
    s.prototype.init = function() {
        var e = this.options;
        return e && e.uint8array && (this.bufferish = n.Uint8Array),
        this
    }
    ,
    t.preset = o({
        preset: !0
    })
}
, function(e, t, r) {
    "use strict";
    r.d(t, "a", function() {
        return s
    });
    var i = r(2)
      , n = /^[ \t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \t]*$/
      , s = function() {
        function e(e, t, r, n) {
            void 0 === e && (e = Object(i.g)()),
            void 0 === t && (t = Object(i.g)().substring(16)),
            this._traceId = e,
            this._spanId = t,
            this._sampled = r,
            this._parent = n
        }
        return e.prototype.setParent = function(e) {
            return this._parent = e,
            this
        }
        ,
        e.prototype.setSampled = function(e) {
            return this._sampled = e,
            this
        }
        ,
        e.fromTraceparent = function(t) {
            var r = t.match(n);
            if (r) {
                var i;
                "1" === r[3] ? i = !0 : "0" === r[3] && (i = !1);
                var s = new e(r[1],r[2],i);
                return new e(r[1],void 0,i,s)
            }
        }
        ,
        e.prototype.toTraceparent = function() {
            var e = "";
            return !0 === this._sampled ? e = "-1" : !1 === this._sampled && (e = "-0"),
            this._traceId + "-" + this._spanId + e
        }
        ,
        e.prototype.toJSON = function() {
            return {
                parent: this._parent && this._parent.toJSON() || void 0,
                sampled: this._sampled,
                span_id: this._spanId,
                trace_id: this._traceId
            }
        }
        ,
        e
    }()
}
, function(e, t) {
    var r, i, n = e.exports = {};
    function s() {
        throw new Error("setTimeout has not been defined")
    }
    function a() {
        throw new Error("clearTimeout has not been defined")
    }
    function o(e) {
        if (r === setTimeout)
            return setTimeout(e, 0);
        if ((r === s || !r) && setTimeout)
            return r = setTimeout,
            setTimeout(e, 0);
        try {
            return r(e, 0)
        } catch (t) {
            try {
                return r.call(null, e, 0)
            } catch (t) {
                return r.call(this, e, 0)
            }
        }
    }
    !function() {
        try {
            r = "function" == typeof setTimeout ? setTimeout : s
        } catch (e) {
            r = s
        }
        try {
            i = "function" == typeof clearTimeout ? clearTimeout : a
        } catch (e) {
            i = a
        }
    }();
    var c, l = [], p = !1, h = -1;
    function u() {
        p && c && (p = !1,
        c.length ? l = c.concat(l) : h = -1,
        l.length && d())
    }
    function d() {
        if (!p) {
            var e = o(u);
            p = !0;
            for (var t = l.length; t; ) {
                for (c = l,
                l = []; ++h < t; )
                    c && c[h].run();
                h = -1,
                t = l.length
            }
            c = null,
            p = !1,
            function(e) {
                if (i === clearTimeout)
                    return clearTimeout(e);
                if ((i === a || !i) && clearTimeout)
                    return i = clearTimeout,
                    clearTimeout(e);
                try {
                    i(e)
                } catch (t) {
                    try {
                        return i.call(null, e)
                    } catch (t) {
                        return i.call(this, e)
                    }
                }
            }(e)
        }
    }
    function f(e, t) {
        this.fun = e,
        this.array = t
    }
    function m() {}
    n.nextTick = function(e) {
        var t = Array(arguments.length - 1);
        if (1 < arguments.length)
            for (var r = 1; r < arguments.length; r++)
                t[r - 1] = arguments[r];
        l.push(new f(e,t)),
        1 !== l.length || p || o(d)
    }
    ,
    f.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    n.title = "browser",
    n.browser = !0,
    n.env = {},
    n.argv = [],
    n.version = "",
    n.versions = {},
    n.on = m,
    n.addListener = m,
    n.once = m,
    n.off = m,
    n.removeListener = m,
    n.removeAllListeners = m,
    n.emit = m,
    n.prependListener = m,
    n.prependOnceListener = m,
    n.listeners = function() {
        return []
    }
    ,
    n.binding = function() {
        throw new Error("process.binding is not supported")
    }
    ,
    n.cwd = function() {
        return "/"
    }
    ,
    n.chdir = function() {
        throw new Error("process.chdir is not supported")
    }
    ,
    n.umask = function() {
        return 0
    }
}
, function(e, t, r) {
    var i = r(16).ExtBuffer
      , n = r(46)
      , s = r(47)
      , a = r(12);
    function o() {
        var e = this.options;
        return this.encode = function(e) {
            var t = s.getWriteType(e);
            return function(e, r) {
                var i = t[typeof r];
                if (!i)
                    throw new Error('Unsupported type "' + typeof r + '": ' + r);
                i(e, r)
            }
        }(e),
        e && e.preset && n.setExtPackers(this),
        this
    }
    a.install({
        addExtPacker: function(e, t, r) {
            function n(t) {
                return r && (t = r(t)),
                new i(t,e)
            }
            r = a.filter(r);
            var s = t.name;
            if (s && "Object" !== s) {
                var o = this.extPackers || (this.extPackers = {});
                o[s] = n
            } else {
                var c = this.extEncoderList || (this.extEncoderList = []);
                c.unshift([t, n])
            }
        },
        getExtPacker: function(e) {
            var t = this.extPackers || (this.extPackers = {})
              , r = e.constructor
              , i = r && r.name && t[r.name];
            if (i)
                return i;
            for (var n, s = this.extEncoderList || (this.extEncoderList = []), a = s.length, o = 0; o < a; o++)
                if (n = s[o],
                r === n[0])
                    return n[1]
        },
        init: o
    }),
    t.preset = o.call(a.preset)
}
, function(e, t, r) {
    t.ExtBuffer = function e(t, r) {
        return this instanceof e ? (this.buffer = i.from(t),
        void (this.type = r)) : new e(t,r)
    }
    ;
    var i = r(3)
}
, function(e, t) {
    t.read = function(e, t, r, i, n) {
        var s, a, o = 8 * n - i - 1, c = (1 << o) - 1, l = c >> 1, p = -7, h = r ? n - 1 : 0, u = r ? -1 : 1, d = e[t + h];
        for (h += u,
        s = d & (1 << -p) - 1,
        d >>= -p,
        p += o; 0 < p; s = 256 * s + e[t + h],
        h += u,
        p -= 8)
            ;
        for (a = s & (1 << -p) - 1,
        s >>= -p,
        p += i; 0 < p; a = 256 * a + e[t + h],
        h += u,
        p -= 8)
            ;
        if (0 === s)
            s = 1 - l;
        else {
            if (s === c)
                return a ? NaN : 1 / 0 * (d ? -1 : 1);
            a += Math.pow(2, i),
            s -= l
        }
        return (d ? -1 : 1) * a * Math.pow(2, s - i)
    }
    ,
    t.write = function(e, t, r, i, n, s) {
        var a, o, c, l = 8 * s - n - 1, p = (1 << l) - 1, h = p >> 1, u = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : s - 1, f = i ? 1 : -1, m = 0 > t || 0 === t && 0 > 1 / t ? 1 : 0;
        for (t = Math.abs(t),
        isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0,
        a = p) : (a = Math.floor(Math.log(t) / Math.LN2),
        1 > t * (c = Math.pow(2, -a)) && (a--,
        c *= 2),
        2 <= (t += 1 <= a + h ? u / c : u * Math.pow(2, 1 - h)) * c && (a++,
        c /= 2),
        a + h >= p ? (o = 0,
        a = p) : 1 <= a + h ? (o = (t * c - 1) * Math.pow(2, n),
        a += h) : (o = t * Math.pow(2, h - 1) * Math.pow(2, n),
        a = 0)); 8 <= n; e[r + d] = 255 & o,
        d += f,
        o /= 256,
        n -= 8)
            ;
        for (a = a << n | o,
        l += n; 0 < l; e[r + d] = 255 & a,
        d += f,
        a /= 256,
        l -= 8)
            ;
        e[r + d - f] |= 128 * m
    }
}
, function(e, t, r) {
    var i, n = r(45);
    t.copy = l,
    t.slice = p,
    t.toString = function() {
        return (!o && s.isBuffer(this) ? this.toString : n.toString).apply(this, arguments)
    }
    ,
    t.write = (i = "write",
    function() {
        var e = this[i] || n[i];
        return e.apply(this, arguments)
    }
    );
    var s = r(3)
      , a = s.global
      , o = s.hasBuffer && "TYPED_ARRAY_SUPPORT"in a
      , c = o && !a.TYPED_ARRAY_SUPPORT;
    function l(e, t, r, i) {
        var a = s.isBuffer(this)
          , o = s.isBuffer(e);
        if (a && o)
            return this.copy(e, t, r, i);
        if (!c && !a && !o && s.isView(this) && s.isView(e)) {
            var l = r || null != i ? p.call(this, r, i) : this;
            return e.set(l, t),
            l.length
        }
        return n.copy.call(this, e, t, r, i)
    }
    function p(e, t) {
        var r = this.slice || !c && this.subarray;
        if (r)
            return r.call(this, e, t);
        var i = s.alloc.call(this, t - e);
        return l.call(this, i, 0, e, t),
        i
    }
}
, function(e, t, r) {
    (function(e) {
        !function(t) {
            function r(e, r, y) {
                function b(e, t, r, i) {
                    return this instanceof b ? function(e, t, r, i, n) {
                        if (m && g && (t instanceof g && (t = new m(t)),
                        i instanceof g && (i = new m(i))),
                        !(t || r || i || d))
                            return void (e.buffer = c(v, 0));
                        if (!a(t, r)) {
                            var s = d || Array;
                            n = r,
                            i = t,
                            r = 0,
                            t = new s(8)
                        }
                        e.buffer = t,
                        e.offset = r |= 0,
                        void 0 === i || ("string" == typeof i ? function(e, t, r, i) {
                            var n = 0
                              , s = r.length
                              , a = 0
                              , o = 0;
                            "-" === r[0] && n++;
                            for (var c, l = n; n < s && 0 <= (c = parseInt(r[n++], i)); )
                                o = o * i + c,
                                a = a * i + Math.floor(o / 4294967296),
                                o %= 4294967296;
                            l && (a = ~a,
                            o ? o = 4294967296 - o : a++),
                            x(e, t + _, a),
                            x(e, t + S, o)
                        }(t, r, i, n || 10) : a(i, n) ? o(t, r, i, n) : "number" == typeof n ? (x(t, r + _, i),
                        x(t, r + S, n)) : 0 < i ? O(t, r, i) : 0 > i ? R(t, r, i) : o(t, r, v, 0))
                    }(this, e, t, r, i) : new b(e,t,r,i)
                }
                function w() {
                    var e = this.buffer
                      , t = this.offset
                      , r = M(e, t + _)
                      , i = M(e, t + S);
                    return y || (r |= 0),
                    r ? 4294967296 * r + i : i
                }
                function x(e, t, r) {
                    e[t + P] = 255 & r,
                    r >>= 8,
                    e[t + A] = 255 & r,
                    r >>= 8,
                    e[t + E] = 255 & r,
                    r >>= 8,
                    e[t + T] = 255 & r
                }
                function M(e, t) {
                    return 16777216 * e[t + T] + (e[t + E] << 16) + (e[t + A] << 8) + e[t + P]
                }
                var _ = r ? 0 : 4
                  , S = r ? 4 : 0
                  , T = r ? 0 : 3
                  , E = r ? 1 : 2
                  , A = r ? 2 : 1
                  , P = r ? 3 : 0
                  , O = r ? l : h
                  , R = r ? p : u
                  , C = b.prototype
                  , L = "is" + e
                  , I = "_" + L;
                return C.buffer = void 0,
                C.offset = 0,
                C[I] = !0,
                C.toNumber = w,
                C.toString = function(e) {
                    var t = this.buffer
                      , r = this.offset
                      , i = M(t, r + _)
                      , n = M(t, r + S)
                      , s = ""
                      , a = !y && 2147483648 & i;
                    for (a && (i = ~i,
                    n = 4294967296 - n),
                    e = e || 10; ; ) {
                        var o = i % e * 4294967296 + n;
                        if (i = Math.floor(i / e),
                        n = Math.floor(o / e),
                        s = (o % e).toString(e) + s,
                        !i && !n)
                            break
                    }
                    return a && (s = "-" + s),
                    s
                }
                ,
                C.toJSON = w,
                C.toArray = i,
                f && (C.toBuffer = n),
                m && (C.toArrayBuffer = s),
                b[L] = function(e) {
                    return !(!e || !e[I])
                }
                ,
                t[e] = b,
                b
            }
            function i(e) {
                var t = this.buffer
                  , r = this.offset;
                return d = null,
                !1 !== e && 0 === r && 8 === t.length && y(t) ? t : c(t, r)
            }
            function n(t) {
                var r = this.buffer
                  , i = this.offset;
                if (d = f,
                !1 !== t && 0 === i && 8 === r.length && e.isBuffer(r))
                    return r;
                var n = new f(8);
                return o(n, 0, r, i),
                n
            }
            function s(e) {
                var t = this.buffer
                  , r = this.offset
                  , i = t.buffer;
                if (d = m,
                !1 !== e && 0 === r && i instanceof g && 8 === i.byteLength)
                    return i;
                var n = new m(8);
                return o(n, 0, t, r),
                n.buffer
            }
            function a(e, t) {
                var r = e && e.length;
                return t |= 0,
                r && t + 8 <= r && "string" != typeof e[t]
            }
            function o(e, t, r, i) {
                t |= 0,
                i |= 0;
                for (var n = 0; 8 > n; n++)
                    e[t++] = 255 & r[i++]
            }
            function c(e, t) {
                return Array.prototype.slice.call(e, t, t + 8)
            }
            function l(e, t, r) {
                for (var i = t + 8; i > t; )
                    e[--i] = 255 & r,
                    r /= 256
            }
            function p(e, t, r) {
                var i = t + 8;
                for (r++; i > t; )
                    e[--i] = 255 ^ 255 & -r,
                    r /= 256
            }
            function h(e, t, r) {
                for (var i = t + 8; t < i; )
                    e[t++] = 255 & r,
                    r /= 256
            }
            function u(e, t, r) {
                var i = t + 8;
                for (r++; t < i; )
                    e[t++] = 255 ^ 255 & -r,
                    r /= 256
            }
            var d, f = void 0 !== e && e, m = "undefined" != typeof Uint8Array && Uint8Array, g = "undefined" != typeof ArrayBuffer && ArrayBuffer, v = [0, 0, 0, 0, 0, 0, 0, 0], y = Array.isArray || function(e) {
                return !!e && "[object Array]" == Object.prototype.toString.call(e)
            }
            ;
            r("Uint64BE", !0, !0),
            r("Int64BE", !0, !1),
            r("Uint64LE", !1, !0),
            r("Int64LE", !1, !1)
        }("string" != typeof t.nodeName ? t : this || {})
    }
    ).call(this, r(28).Buffer)
}
, function(e, t, r) {
    var i = r(16).ExtBuffer
      , n = r(49)
      , s = r(33).readUint8
      , a = r(50)
      , o = r(12);
    function c() {
        var e = this.options;
        return this.decode = function(e) {
            var t = a.getReadToken(e);
            return function(e) {
                var r = s(e)
                  , i = t[r];
                if (!i)
                    throw new Error("Invalid type: " + (r ? "0x" + r.toString(16) : r));
                return i(e)
            }
        }(e),
        e && e.preset && n.setExtUnpackers(this),
        this
    }
    o.install({
        addExtUnpacker: function(e, t) {
            (this.extUnpackers || (this.extUnpackers = []))[e] = o.filter(t)
        },
        getExtUnpacker: function(e) {
            return (this.extUnpackers || (this.extUnpackers = []))[e] || function(t) {
                return new i(t,e)
            }
        },
        init: c
    }),
    t.preset = c.call(o.preset)
}
, function(e, t) {
    e.exports.verified = {
        clan: "#FBC02D",
        player: "#40C4FF"
    },
    e.exports.damage = "#DE292F",
    e.exports.critical = "#FFD542",
    e.exports.crosshair = {
        background: "#ffffff",
        shadow: "#000000"
    },
    e.exports.hudHealth = {
        low: "#eb5656",
        high: "#9eeb56"
    },
    e.exports.popupScore = "#ffea78",
    e.exports.ping = {
        low: "#9eeb56",
        medium: "#ffd542",
        high: "#ff4b42"
    },
    e.exports.teams = ["#9eeb56", "#eb5656"],
    e.exports.creationDate = {
        new: "#0a61f7",
        recent: "#E040FB",
        old: "#ed4242"
    },
    e.exports.matchVote = {
        selected: "rgba(251, 192, 45, 1)",
        notSelected: "rgba(255, 255, 255, 0.7)"
    },
    e.exports.killFeed = {
        enemy: "#eb5656",
        ally: "#9eeb56",
        you: "#fff"
    },
    e.exports.interactPopup = {
        key: "#FBC02D",
        enough: "#9eeb56",
        notEnough: "#eb5656"
    },
    e.exports.modeSpecific = {
        infected: {
            skin: 5857617
        },
        stalker: {
            skin: 0,
            body: [0, 0, 0, 0, 0, 0]
        }
    },
    e.exports.zones = {
        BR: ["#c542d9", "#c542d9", "#c542d9"],
        sky: ["#74a4b9", "#dce8ed", "#dce8ed"]
    }
}
, function(e, t) {
    var r = function() {
        return this
    }();
    try {
        r = r || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (r = window)
    }
    e.exports = r
}
, function(e, t) {
    e.exports = [{
        name: "Sniper Rifle",
        src: "weapon_1",
        icon: "icon_1",
        sound: "weapon_1",
        animWhileAim: !0,
        trail: !0,
        flap: {
            src: "flap_0",
            rot: 2.1,
            scl: 1,
            zOff: .43,
            xOff: .17,
            yOff: .53
        },
        noAo: !0,
        nAuto: !0,
        type: 0,
        scope: !0,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: .95,
        ammo: 3,
        reload: 1500,
        dmg: 100,
        pierce: .2,
        range: 1e3,
        dropStart: 230,
        dmgDrop: 30,
        scale: .00115608717587935,
        leftHoldY: -.7,
        rightHoldY: -.75,
        leftHoldZ: 2.4,
        rightHoldZ: .4,
        xOff: .8,
        yOff: -.68,
        zOff: -1.8,
        xOrg: 0,
        yOrg: -.55,
        zOrg: -.8,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        inspectR: .2,
        inspectM: .1,
        muzOff: 8,
        muzMlt: 1.6,
        rate: 900,
        spread: 260,
        zoom: 2.7,
        leanMlt: 1.5,
        recoil: .009,
        recoilR: .02,
        recover: .993,
        recoverY: .997,
        recoverF: .975,
        recoilYM: .35,
        recoilZ: 1.4,
        recoilAnim: {
            time: 280,
            aimTime: 500,
            recoilTweenY: .3
        },
        jumpYM: .15,
        rumble: .9,
        rumbleDur: 500,
        icnPad: 9
    }, {
        name: "Assault Rifle",
        src: "weapon_2",
        icon: "icon_2",
        sound: "weapon_2",
        noAo: !0,
        swapWiggle: .3,
        attach: 0,
        attachYOff: -.1,
        attachZOff: -.8,
        zRot: 1,
        type: 0,
        swapTime: 300,
        aimSpeed: 130,
        spdMlt: .95,
        ammo: 30,
        rate: 110,
        reload: 1200,
        dmg: 23,
        pierce: 1,
        range: 700,
        dmgDrop: 5,
        scale: .00095745145728643,
        leftHoldY: -.45,
        rightHoldY: -.6,
        leftHoldZ: .65,
        rightHoldZ: -1.3,
        xOff: 1,
        yOff: -.7,
        yRot: .0018,
        zOff: -3.6,
        xOrg: 0,
        yOrg: -.625,
        zOrg: -2.3,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        inspectR: .1,
        inspectM: 1.5,
        caseZOff: -1.7,
        caseYOff: -.2,
        muzOff: 5.1,
        muzOffY: -.05,
        muzMlt: 1.4,
        spread: 100,
        minSpread: 5,
        zoom: 1.6,
        leanMlt: 1.5,
        recoil: .003,
        recoilR: .02,
        recover: .978,
        recoverY: .995,
        recoverF: .975,
        jYMlt: .9,
        recoilYM: .32,
        recoilZ: 5,
        recoilZM: -.05,
        aimRecMlt: .8,
        recoilAnim: {
            time: 300,
            recoilTweenY: .05
        },
        jumpYM: .6,
        rumble: .5,
        icnPad: 5
    }, {
        name: "Pistol",
        src: "weapon_3",
        icon: "icon_3",
        sound: "weapon_3",
        secondary: !0,
        noAo: !0,
        transp: !0,
        nAuto: !0,
        kill: ["", 75],
        swapWiggle: .3,
        type: 1,
        shine: 10,
        swapTime: 350,
        aimSpeed: 120,
        spdMlt: 1.05,
        ammo: 10,
        reload: 700,
        dmg: 20,
        range: 700,
        dmgDrop: 10,
        scale: .0003158947055276376,
        leftHoldY: -1.1,
        rightHoldY: -.62,
        leftHoldZ: -.55,
        rightHoldZ: -.5,
        xOff: .7,
        yOff: -.6,
        zOff: -3.7,
        xOrg: 0,
        yRot: -.005,
        yOrg: -.23,
        zOrg: -3.9,
        jYMlt: .1,
        cLean: .3,
        cRot: .3,
        caseZOff: .2,
        caseYOff: 0,
        inspectR: .3,
        inspectM: .8,
        muzOff: 1.5,
        muzOffY: 0,
        muzMlt: .95,
        rate: 150,
        spread: 90,
        zoom: 1.4,
        leanMlt: 1,
        recoil: .006,
        recoilR: .01,
        recover: .98,
        recoverY: .99,
        recoverF: .98,
        recoilYM: .2,
        aimRecMlt: .4,
        recoilZ: 3.6,
        recoilZM: -.4,
        recoilAnim: {
            time: 200,
            recoilTweenY: .2
        },
        rumble: .4,
        icnPad: -15
    }, {
        name: "Submachine Gun",
        src: "weapon_4",
        icon: "icon_4",
        sound: "weapon_4",
        swapWiggle: .5,
        attach: 0,
        attachYOff: -.09,
        attachZOff: -1.1,
        zRot: .75,
        noAo: !0,
        type: 0,
        shine: 50,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 28,
        reload: 1e3,
        dmg: 18,
        pierce: 1,
        range: 700,
        dmgDrop: 12,
        scale: .000574897587939697,
        leftHoldY: -.4,
        leftHoldX: -.1,
        rightHoldY: -.5,
        leftHoldZ: 1.1,
        rightHoldZ: -.95,
        xOff: .85,
        yOff: -.86,
        zOff: -3,
        xOrg: 0,
        yOrg: -.59,
        zOrg: -2.5,
        cRot: .18,
        cLean: .16,
        inspectR: .2,
        inspectM: 1.2,
        caseYOff: -.15,
        caseZOff: -.4,
        muzOff: 2.15,
        muzOffY: .1,
        rate: 90,
        spread: 70,
        minSpread: 5,
        zoom: 1.65,
        jYMlt: .8,
        leanMlt: 1,
        recoil: .0034,
        recoilY: .77,
        recoilR: .02,
        recover: .975,
        recoverY: .996,
        recoverF: .975,
        recoilZ: 3.2,
        recoilZM: -.1,
        aimRecMlt: .7,
        recoilAnim: {
            time: 200,
            recoilTweenYM: .05,
            recoilTweenY: .06
        },
        expScale: .8,
        rumble: .4,
        icnPad: 0
    }, {
        name: "Revolver",
        src: "weapon_5",
        icon: "icon_5",
        sound: "weapon_5",
        nAuto: !0,
        noAo: !0,
        nCase: !0,
        transp: !0,
        kill: ["", 50],
        type: 0,
        swapTime: 200,
        aimSpeed: 110,
        spdMlt: 1.04,
        ammo: 6,
        reload: 900,
        dmg: 66,
        pierce: .85,
        dmgDrop: 10,
        scale: .000515531266331653,
        hDstOff: 2,
        leftHoldY: -1.6,
        rightHoldY: -.8,
        leftHoldZ: -.6,
        rightHoldZ: -.72,
        rotOff: -.05,
        xOff: .7,
        yOff: -.5,
        zOff: -3.5,
        xOrg: 0,
        yOrg: -.31,
        zOrg: -3.5,
        jYMlt: .96,
        cLean: .2,
        cRot: .1,
        cDrop: .3,
        inspectR: .1,
        inspectM: .3,
        muzOff: 2.75,
        muzOffY: .2,
        muzMlt: .95,
        range: 700,
        rate: 390,
        spread: 100,
        zoom: 1.45,
        leanMlt: 1.6,
        recoil: .013,
        recoilR: .045,
        recover: .982,
        recoverY: .992,
        recoverF: .98,
        recoilYM: .6,
        aimRecMlt: .55,
        recoilZM: .01,
        recoilZ: 3.4,
        recoilAnim: {
            time: 300,
            recoilTweenY: .35
        },
        expScale: .9,
        rumble: .7,
        icnPad: -10
    }, {
        name: "Shotgun",
        src: "weapon_6",
        icon: "icon_6",
        sound: "weapon_6",
        noAo: !0,
        nAuto: !0,
        nCase: !0,
        transp: !0,
        nRing: !0,
        swapWiggle: .4,
        shine: 35,
        type: 0,
        physRang: 35,
        physPow: .085,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 2,
        reload: 1100,
        dmg: 50,
        dmgDrop: 50,
        scale: .00082934281407035,
        rightHoldX: .1,
        leftHoldY: -.5,
        rightHoldY: -.7,
        leftHoldZ: .4,
        rightHoldZ: -1.5,
        xOff: .95,
        yOff: -.65,
        zOff: -3.8,
        xOrg: 0,
        yOrg: -.3,
        zOrg: -2.8,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        jYMlt: .2,
        inspectR: .1,
        inspectM: 1.9,
        muzOff: 6,
        muzMlt: 1.8,
        range: 240,
        rate: 400,
        innac: 110,
        spread: 120,
        shots: 5,
        minSpread: 20,
        zoom: 1.25,
        leanMlt: 1.6,
        recoil: .016,
        recoilR: .015,
        recover: .99,
        recoverF: .97,
        recoilZ: 2,
        recoilZM: .2,
        aimRecMlt: .5,
        recoilYM: .6,
        recoilAnim: {
            time: 340,
            recoilTweenY: .2
        },
        jumpYM: .5,
        rumble: .8,
        icnPad: 10
    }, {
        name: "Machine Gun",
        src: "weapon_7",
        icon: "icon_7",
        sound: "weapon_7",
        type: 0,
        attach: 0,
        swapWiggle: .3,
        attachYOff: -.085,
        attachZOff: -.7,
        zRot: .75,
        noAo: !0,
        swapTime: 700,
        aimSpeed: 200,
        spdMlt: .79,
        ammo: 60,
        reload: 3500,
        dmg: 20,
        pierce: 1,
        range: 700,
        dmgDrop: 10,
        jYMlt: .8,
        scale: .0008856008924623108,
        leftHoldY: -.85,
        leftHoldX: .4,
        rightHoldY: -.75,
        leftHoldZ: 1.1,
        rightHoldZ: -.2,
        yRot: -.01,
        xOff: .95,
        yOff: -.75,
        zOff: -2.8,
        xOrg: 0,
        yOrg: -.6,
        zOrg: -1.8,
        cLean: .1,
        cRot: .1,
        cDrop: .1,
        inspectR: .2,
        inspectM: .6,
        caseInd: 2,
        caseZOff: -.5,
        caseYOff: -.1,
        muzOff: 5.5,
        muzOffY: -.14,
        muzMlt: 1.7,
        rate: 130,
        spread: 300,
        minSpread: 10,
        zoom: 1.3,
        leanMlt: 1.6,
        recoil: .0032,
        recoilR: .014,
        recover: .98,
        recoverY: .9975,
        recoverF: .975,
        recoilZ: 3.8,
        recoilYM: .25,
        recoilZ: 3,
        recoilZM: -.1,
        aimRecMlt: .5,
        recoilAnim: {
            time: 200,
            recoilTweenY: .03
        },
        jumpYM: .5,
        expScale: .85,
        rumble: .65,
        icnPad: 10
    }, {
        name: "Semi Auto",
        src: "weapon_8",
        icon: "icon_8",
        sound: "weapon_8",
        attach: 0,
        attachYOff: -.08,
        attachZOff: -1.55,
        nAuto: !0,
        zRot: .7,
        type: 0,
        noAo: !0,
        swapWiggle: .4,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 8,
        reload: 1500,
        dmg: 34,
        pierce: .2,
        range: 1e3,
        dmgDrop: 0,
        scale: .00093686221105528,
        leftHoldY: -.5,
        rightHoldY: -.45,
        leftHoldZ: .4,
        rightHoldZ: -1.85,
        jYMlt: .9,
        xOff: .8,
        yOff: -.55,
        zOff: -3.5,
        xOrg: 0,
        yOrg: -.395,
        yRot: -.005,
        zOrg: -3.4,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        inspectR: .2,
        inspectM: 1.4,
        muzOff: 4,
        muzOffY: -.05,
        muzMlt: 1.1,
        rate: 120,
        spread: 250,
        caseZOff: -1.3,
        zoom: 2.1,
        recoil: .01,
        recoilR: .012,
        recover: .98,
        recoilY: .36,
        recoverY: .994,
        recoverF: .975,
        recoilYM: .6,
        recoilZ: 2,
        recoilZM: .2,
        aimRecMlt: .8,
        recoilAnim: {
            time: 250,
            recoilTweenY: .11
        },
        jumpYM: .5,
        rumble: .75,
        icnPad: 10
    }, {
        name: "Rocket Launcher",
        src: "weapon_9",
        icon: "icon_9",
        sound: "weapon_9",
        nInsp: !0,
        nSkill: !0,
        nAuto: !0,
        nCase: !0,
        nRing: !0,
        noAo: !0,
        projectile: 0,
        type: 0,
        swapTime: 400,
        swapWiggle: .4,
        aimSpeed: 200,
        spdMlt: .9,
        physRang: 40,
        physPow: .095,
        ammo: 2,
        shots: 0,
        reload: 1800,
        scale: .00076263407035176,
        leftHoldX: -.1,
        leftHoldY: -.36,
        rightHoldY: -.3,
        leftHoldZ: 1.2,
        rightHoldX: -.15,
        rightHoldZ: -.2,
        jYMlt: .4,
        xOff: .95,
        yOff: -.56,
        zOff: -2.6,
        xOrg: 0,
        yOrg: -.945,
        zOrg: -3,
        zRot: .9,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        muzOff: 5,
        muzOffY: 0,
        muzMlt: 1.5,
        rate: 350,
        spread: 120,
        minSpread: 15,
        zoom: 1.5,
        leanMlt: 1.4,
        landBob: .8,
        recoil: .008,
        recoilR: .012,
        recover: .99,
        recoverY: .998,
        recoverF: .975,
        recoilZ: 4,
        recoilZM: -.5,
        aimRecMlt: .9,
        recoilAnim: {
            time: 400,
            recoilTweenY: .25
        },
        jumpYM: .3,
        expScale: .7,
        rumble: 1,
        rumbleDur: 750,
        icnPad: 10
    }, {
        name: "Akimbo Uzi",
        src: "weapon_10",
        icon: "icon_10",
        sound: "weapon_10",
        nInsp: !0,
        noAim: !0,
        akimbo: !0,
        type: 0,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 18,
        reload: 1200,
        dmg: 18,
        pierce: 1,
        range: 700,
        dmgDrop: 12,
        scale: .9,
        rightHoldY: -.55,
        leftHoldZ: .3,
        leftHoldX: -.25,
        leftHoldY: -.55,
        rightHoldZ: .3,
        rightHoldX: -.25,
        holdW: 1.3,
        xOff: 1.5,
        yOff: -.95,
        zOff: -3.3,
        xOrg: 0,
        yOrg: -.62,
        zOrg: -2.5,
        zLnM: .4,
        cLean: .1,
        cRot: .1,
        cDrop: .2,
        caseYOff: -.15,
        caseZOff: -.4,
        muzOff: 3.6,
        rate: 60,
        spread: 40,
        spreadInc: 1.5,
        minSpread: 10,
        zoom: 1.5,
        leanMlt: .6,
        recoil: .0034,
        recoilR: .015,
        recover: .978,
        recoverY: .996,
        recoverF: .975,
        recoilZ: 5,
        recoilYM: .6,
        recoilAnim: {
            recoilTweenY: .01
        },
        expScale: .7,
        rumble: .4,
        icnPad: -4
    }, {
        name: "Desert Eagle",
        src: "weapon_11",
        icon: "icon_11",
        sound: "weapon_11",
        secondary: !0,
        minRec: 15,
        nAuto: !0,
        noAo: !0,
        transp: !0,
        kill: ["", 50],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 6,
        reload: 1e3,
        dmg: 50,
        pierce: .85,
        dmgDrop: 10,
        scale: .94,
        leftHoldY: -.9,
        rightHoldY: -.7,
        leftHoldZ: -.5,
        rightHoldZ: -.5,
        holdW: .95,
        xOff: 1,
        yOff: -.7,
        zOff: -4.1,
        xOrg: 0,
        yOrg: -.195,
        zOrg: -3.8,
        cLean: .3,
        cRot: .3,
        inspectR: .35,
        inspectM: .9,
        muzOff: 2,
        muzMlt: 1.1,
        range: 700,
        rate: 400,
        spread: 150,
        jYMlt: .5,
        zoom: 1.4,
        leanMlt: 1.6,
        recoil: .01,
        recoilR: .01,
        recover: .985,
        recoverY: .996,
        recoverF: .98,
        recoilYM: .4,
        aimRecMlt: .5,
        recoilZ: 2.5,
        recoilZM: .2,
        recoilAnim: {
            time: 290,
            recoilTweenY: .35
        },
        rumble: .8,
        icnPad: -10
    }, {
        name: "Alien Blaster",
        src: "weapon_13",
        icon: "icon_13",
        sound: "weapon_13",
        secondary: !0,
        nRing: !0,
        nAuto: !0,
        transp: !0,
        nCase: !0,
        minRec: 50,
        kill: ["", 50],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 4,
        reload: 1500,
        dmg: 50,
        pierce: .85,
        dmgDrop: 10,
        scale: 1.1,
        leftHoldY: -1,
        rightHoldY: -.65,
        leftHoldZ: -.2,
        rightHoldZ: -.2,
        xOff: 1.3,
        yOff: -.83,
        zOff: -4.1,
        xOrg: 0,
        yRot: -.01,
        yOrg: -.53,
        zOrg: -3.8,
        cLean: .2,
        cRot: .2,
        cDrop: 0,
        inspectR: .1,
        inspectM: .8,
        holdW: .7,
        muzOff: 2.2,
        muzOffY: .1,
        muzID: 3,
        muzMlt: 1.1,
        jYMlt: .8,
        range: 700,
        rate: 170,
        spread: 150,
        zoom: 1.4,
        leanMlt: 1.6,
        recoil: .006,
        recoilR: .01,
        recover: .98,
        recoverY: .99,
        recoverF: .98,
        recoilYM: .2,
        recoilZ: 2,
        aimRecMlt: .6,
        recoilAnim: {
            time: 200,
            recoilTweenY: .3
        },
        rumble: .4,
        icnPad: -8
    }, {
        name: "Combat Knife",
        icon: "icon_0",
        melee: !0,
        nInsp: !0,
        noSkins: !0,
        holdW: .9,
        swapWiggle: .3,
        sounds: ["swish_0", "swish_1"],
        noAim: !0,
        anim: function(e, t, r) {
            if (1 == r) {
                e.handAnimInd = -1 * (e.handAnimInd || 1);
                var i = !1;
                e.meleeAnim.anim && (e.meleeAnim.anim.stop(),
                i = 2 <= e.meleeAnim.armM),
                e.resetMeleeAnim();
                var n = -1.2
                  , s = .7
                  , a = -.4;
                i ? (n += .1,
                e.meleeAnim.weaR = n,
                a += .8,
                e.meleeAnim.armR = a,
                s += .2,
                e.meleeAnim.weaM = s,
                e.meleeAnim.flipW = Math.PI) : n -= .4,
                e.meleeAnim.anim = new t.Tween(e.meleeAnim).to({
                    armR: a,
                    lArm: 1,
                    armT: i ? -.2 : -.8,
                    armY: -3,
                    armM: i ? -10 : 13,
                    armE: -2,
                    weaR: n,
                    weaM: s
                }, 220 * (i ? 1.3 : 1)).easing(t.Easing.Cubic.Out).onComplete(function() {
                    e.meleeAnim.anim = new t.Tween(e.meleeAnim).to({
                        armR: 0,
                        armT: 0,
                        armY: 0,
                        lArm: 0,
                        armM: 0,
                        armE: 0,
                        weaR: 0,
                        weaM: 0,
                        flipW: 0
                    }, 350).easing(t.Easing.Cubic.Out).start()
                }).start()
            } else {
                e.handAnimInd = -1 * (e.handAnimInd || 1);
                var o = (1 == e.handAnimInd ? "l" : "r") + "HndTween";
                e[o] && e[o].stop(),
                e[o + "A"] = e[o + "A"] || 0,
                e[o] = new t.Tween(e).to({
                    [o + "A"]: 2.4
                }, 30).easing(t.Easing.Linear.None).onComplete(function() {
                    e[o] = new t.Tween(e).to({
                        [o + "A"]: 0
                    }, 200).easing(t.Easing.Linear.None).delay(100).start()
                }).start()
            }
        },
        type: 1,
        swapTime: 280,
        aimSpeed: 120,
        rate: 250,
        dmg: 50,
        dmgDrop: 0,
        range: 15,
        spdMlt: 1.1,
        spread: 100,
        leftHoldY: -.82,
        leftHoldX: 1.5,
        rightHoldX: -1.5,
        rightHoldY: -.82,
        leftHoldZ: -.5,
        rightHoldZ: -.5,
        xOff: 0,
        yOff: -.6,
        zOff: -3.6,
        xOrg: .5,
        yOrg: 0,
        zOrg: -3.6,
        zRM: .35,
        zoom: 1,
        leanMlt: .8,
        recoil: .006,
        recoilR: .01,
        recover: .98,
        recoverF: .98,
        rumble: .4,
        rumbleDur: 150,
        icnPad: -10
    }, {
        name: "Crossbow",
        src: "weapon_17",
        icon: "icon_17",
        sound: "weapon_17",
        noSkins: !0,
        nInsp: !0,
        nRing: !0,
        nAuto: !0,
        noAo: !0,
        nCase: !0,
        nMuz: !0,
        attach: 0,
        attachYOff: -.1,
        attachZOff: .65,
        kill: ["", 100],
        type: 0,
        projectile: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 1,
        reload: 1e3,
        dmg: 100,
        pierce: 0,
        dmgDrop: 0,
        scale: .0007303348040201011,
        leftHoldY: -.33,
        rightHoldY: -.28,
        leftHoldZ: 2.2,
        leftHoldX: 0,
        rightHoldZ: .9,
        xOff: 1.3,
        yOff: -.95,
        zOff: -1.9,
        xOrg: 0,
        yOrg: -.72,
        zOrg: -1,
        cLean: .1,
        cRot: .1,
        zRot: .9,
        cDrop: .2,
        holdW: .5,
        muzOff: 2.2,
        muzOffY: .1,
        muzID: 3,
        muzMlt: 1.1,
        jYMlt: .95,
        range: 700,
        rate: 150,
        spread: 300,
        zoom: 1.4,
        leanMlt: .3,
        recoil: .007,
        recoilR: .01,
        recover: .985,
        recoverY: .996,
        recoverF: .98,
        recoilZ: 4,
        recoilAnim: {
            time: 300,
            recoilTweenY: .1
        },
        rumble: .5,
        icnPad: 9
    }, {
        name: "Famas",
        src: "weapon_15",
        icon: "icon_15",
        sound: "weapon_15",
        noAo: !0,
        nAuto: !0,
        burst: {
            c: 3,
            r: 90
        },
        swapWiggle: .6,
        attach: 0,
        attachYOff: -.1,
        attachZOff: -.5,
        zRot: 1,
        type: 0,
        swapTime: 300,
        aimSpeed: 130,
        spdMlt: .95,
        ammo: 30,
        rate: 280,
        reload: 1200,
        dmg: 28,
        pierce: 1,
        range: 900,
        dmgDrop: 5,
        scale: .0008858419597989991,
        leftHoldY: -.45,
        rightHoldY: -.5,
        leftHoldZ: .72,
        rightHoldZ: -1,
        xOff: 1,
        yOff: -.86,
        yRot: .0018,
        zOff: -3,
        xOrg: 0,
        yOrg: -1.14,
        zOrg: -2,
        cLean: .2,
        cRot: .2,
        cDrop: .1,
        inspectR: .1,
        inspectM: 1.5,
        caseZOff: -1.7,
        caseYOff: -.2,
        muzOff: 4.9,
        muzOffY: -.05,
        muzMlt: 1.4,
        spread: 90,
        minSpread: 5,
        zoom: 1.5,
        leanMlt: 1.5,
        recoil: .0032,
        recoilR: .02,
        recover: .978,
        recoverY: .995,
        recoverF: .975,
        jYMlt: .9,
        recoilYM: .32,
        recoilZ: 5,
        recoilZM: .05,
        aimRecMlt: .8,
        recoilAnim: {
            time: 300,
            recoilTweenY: .05
        },
        jumpYM: .6,
        rumble: .5,
        expScale: .9,
        icnPad: 9
    }],
    e.exports.findWeaponBySrc = function(t) {
        for (var r = 0; r < e.exports.length; ++r)
            if (e.exports[r].src == "weapon_" + t)
                return e.exports[r];
        return null
    }
    ,
    e.exports.findIndexBySrc = function(t) {
        for (var r = 0; r < e.exports.length; ++r)
            if (e.exports[r].src == t)
                return r;
        return null
    }
}
, function(e, t, r) {
    var i = r(4);
    const n = r(7);
    r(8);
    var s = {};
    e.exports.getColor = function(e, t) {
        var r = e + "-" + (t || "")
          , n = s[r];
        return n || (n = new i.Color(e),
        t && n.multiplyScalar(t),
        s[r] = n),
        n
    }
    ,
    e.exports.colorize = function(t, r, i) {
        r = i || e.exports.getColor(r);
        for (var n = 0; n < t.faces.length; ++n)
            t.faces[n].vertexColors[0] = r,
            t.faces[n].vertexColors[1] = r,
            t.faces[n].vertexColors[2] = r
    }
    ;
    var a, o = function(e, t, r, n) {
        for (var s, a = new i.Vector2(t,r).multiplyScalar(n || 1), o = 0; o < e.faceVertexUvs.length; o++) {
            s = e.faceVertexUvs[o];
            for (var c = 0; c < s.length; c++)
                for (var l, p = 0; 3 > p; p++)
                    (l = s[c][p].multiply(a)).x = .5 + l.x - a.x / 2
        }
    }, c = function(e, t, r, i, n, s) {
        return e >= r - n && e <= r + n && t >= i - s && t <= i + s
    }, l = [], p = ["a", "b", "c", "d"];
    e.exports.generatePlane = function(t, r, s, h, u, d) {
        t *= s.ratio || 1;
        var f = (s.scale ? t + "_" + r + "_" : "") + (s.scale || "") + (s.tilesX || "") + (s.tilesZ || "") + (s.noise ? h + "_" + u + "_" + d : "") + (null == s.colr ? "" : s.colr) + (s.dark || "");
        if (!(a = l[f])) {
            if (a = new i.PlaneGeometry(1,1,s.tilesX || 1,s.tilesZ || 1),
            s.noise) {
                for (var m = {}, g = s.margin || 0, v = 0; v < a.vertices.length; ++v) {
                    var y = a.vertices[v].x
                      , b = a.vertices[v].y;
                    if (!s.pinEdges || -.5 != y && .5 != y && -.5 != b && .5 != b)
                        if (s.objects) {
                            for (var w = 0; w < s.objects.length; ++w)
                                if (s.objects[w].y - s.objects[w].height <= u + .1 && s.objects[w].y + s.objects[w].height > u + s.noise && c(d + -b * t * 2, h + y * r * 2, s.objects[w].z, s.objects[w].x, s.objects[w].length + g, s.objects[w].width + g)) {
                                    a.vertices[v].z = Math.random() * s.noise + 1,
                                    m[v] = e.exports.getColor(s.colr, .6);
                                    break
                                }
                        } else
                            a.vertices[v].z = Math.random() * s.noise;
                    m[v] || (m[v] = e.exports.getColor(s.colr))
                }
                for (v = 0; v < a.faces.length; v++) {
                    for (var x = a.faces[v], M = 0, _ = 0; 3 > _; _++)
                        x.vertexColors[_] = m[x[p[_]]],
                        0 >= a.vertices[x[p[_]]].z && M++;
                    3 <= M && delete a.faces[v]
                }
                a.faces = a.faces.filter(function(e) {
                    return e
                }),
                a.elementsNeedUpdate = !0
            } else
                e.exports.colorize(a, null, e.exports.getColor(s.colr || 16777215, s.dark || 1));
            s.scale && o(a, r / n.worldUV, t / n.worldUV, s.scale),
            a.computeVertexNormals(),
            l[f] = a
        }
        return a
    }
    ;
    var h = [];
    e.exports.generateCube = function(t, r, s, c, l) {
        t = t || [1, 1, 1, 1, 1, 1],
        l.flipp = (r > s || c > s) && "floor_0" == l.src,
        l.flippW = r > c && "floor_0" == l.src;
        for (var p = (l.scale ? r + "_" + s + "_" + c + "_" : "") + (null == l.colr ? "" : l.colr) + (l.scale || "") + (l.flippW ? "flw" : "fnw") + (l.flipp ? "fl" : "fn") + (l.amb || "") + (l.fAmb || "") + (l.useScale || ""), u = 0; u < t.length; ++u)
            p += "_" + t[u];
        if (!(a = h[p])) {
            l.colr = null == l.colr ? 16777215 : l.colr;
            var d = e.exports.getColor(l.colr)
              , f = l.amb ? e.exports.getColor(l.colr, l.amb) : d;
            if (l.fAmb) {
                var m = d;
                d = f,
                f = m
            }
            a = new i.Geometry;
            var g, v = [];
            t[0] && ((g = new i.PlaneGeometry(1,1)).rotateY(Math.PI / 2),
            l.flipp && g.rotateX(Math.PI / 2),
            g.translate(.5, .5, 0),
            g.faces[0].vertexColors = [d, f, d],
            g.faces[1].vertexColors = [f, f, d],
            l.scale && o(g, (l.flipp ? s : c) / n.worldUV, (l.flipp ? c : s) / n.worldUV, l.scale),
            v.push(g)),
            t[1] && ((g = new i.PlaneGeometry(1,1)).rotateY(-Math.PI / 2),
            l.flipp && g.rotateX(Math.PI / 2),
            g.translate(-.5, .5, 0),
            g.faces[0].vertexColors = [d, f, d],
            g.faces[1].vertexColors = [f, f, d],
            l.scale && o(g, (l.flipp ? s : c) / n.worldUV, (l.flipp ? c : s) / n.worldUV, l.scale),
            v.push(g)),
            t[2] && ((g = new i.PlaneGeometry(1,1)).rotateX(-Math.PI / 2),
            l.flippW && g.rotateY(Math.PI / 2),
            g.translate(0, 1, 0),
            g.faces[0].vertexColors = [d, d, d],
            g.faces[1].vertexColors = [d, d, d],
            l.scale && o(g, (l.flippW ? c : r) / n.worldUV, (l.flippW ? r : c) / n.worldUV, l.scale),
            v.push(g)),
            t[3] && ((g = new i.PlaneGeometry(1,1)).rotateX(Math.PI / 2),
            l.flippW && g.rotateY(Math.PI / 2),
            g.translate(0, 0, 0),
            g.faces[0].vertexColors = [f, f, f],
            g.faces[1].vertexColors = [f, f, f],
            l.scale && o(g, (l.flippW ? c : r) / n.worldUV, (l.flippW ? r : c) / n.worldUV, l.scale),
            v.push(g)),
            t[4] && (g = new i.PlaneGeometry(1,1),
            l.flipp && g.rotateZ(Math.PI / 2),
            g.translate(0, .5, .5),
            g.faces[0].vertexColors = [d, f, d],
            g.faces[1].vertexColors = [f, f, d],
            l.scale && o(g, (l.flipp ? s : r) / n.worldUV, (l.flipp ? r : s) / n.worldUV, l.scale),
            v.push(g)),
            t[5] && ((g = new i.PlaneGeometry(1,1)).rotateY(Math.PI),
            l.flipp && g.rotateZ(Math.PI / 2),
            g.translate(0, .5, -.5),
            g.faces[0].vertexColors = [d, f, d],
            g.faces[1].vertexColors = [f, f, d],
            l.scale && o(g, (l.flipp ? s : r) / n.worldUV, (l.flipp ? r : s) / n.worldUV, l.scale),
            v.push(g));
            for (u = 0; u < v.length; u++)
                a.merge(v[u], new i.Matrix4);
            l && l.useScale && (a.scale(r, s, c),
            a.translate(0, -s / 2, 0)),
            h[p] = a
        }
        return a
    }
    ;
    var u = [];
    e.exports.generateCone = function(t, r, n, s) {
        var o = (s.scale ? t + "_" + r + "_" + n + "_" : "") + (s.scale || "") + (s.useScale || "") + (null == s.colr ? "" : s.colr) + (s.dark || "");
        return (a = u[o]) || (a = new i.ConeGeometry(Math.min(t, n) / 2,r,12,12,!0),
        s && !s.useScale && a.translate(0, r / 2, 0),
        e.exports.colorize(a, null, e.exports.getColor(s.colr || 16777215, s.dark || 1)),
        u[o] = a),
        a
    }
}
, function(e, t, r) {
    "use strict";
    r.d(t, "a", function() {
        return o
    });
    var i = r(2)
      , n = Object(i.e)()
      , s = "Sentry Logger "
      , a = function() {
        function e() {
            this._enabled = !1
        }
        return e.prototype.disable = function() {
            this._enabled = !1
        }
        ,
        e.prototype.enable = function() {
            this._enabled = !0
        }
        ,
        e.prototype.log = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            this._enabled && Object(i.b)(function() {
                n.console.log(s + "[Log]: " + e.join(" "))
            })
        }
        ,
        e.prototype.warn = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            this._enabled && Object(i.b)(function() {
                n.console.warn(s + "[Warn]: " + e.join(" "))
            })
        }
        ,
        e.prototype.error = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            this._enabled && Object(i.b)(function() {
                n.console.error(s + "[Error]: " + e.join(" "))
            })
        }
        ,
        e
    }();
    n.__SENTRY__ = n.__SENTRY__ || {};
    var o = n.__SENTRY__.logger || (n.__SENTRY__.logger = new a)
}
, function(e, t, r) {
    t.encode = function(e, t) {
        var r = new i(t);
        return r.write(e),
        r.read()
    }
    ;
    var i = r(27).EncodeBuffer
}
, function(e, t, r) {
    t.EncodeBuffer = n;
    var i = r(15).preset;
    function n(e) {
        if (!(this instanceof n))
            return new n(e);
        if (e && (this.options = e,
        e.codec)) {
            var t = this.codec = e.codec;
            t.bufferish && (this.bufferish = t.bufferish)
        }
    }
    r(30).FlexEncoder.mixin(n.prototype),
    n.prototype.codec = i,
    n.prototype.write = function(e) {
        this.codec.encode(this, e)
    }
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
        var i = r(41)
          , n = r(17)
          , s = r(11);
        function a() {
            return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }
        function o(e, t) {
            if (a() < t)
                throw new RangeError("Invalid typed array length");
            return c.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = c.prototype : (null === e && (e = new c(t)),
            e.length = t),
            e
        }
        function c(e, t, r) {
            if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c))
                return new c(e,t,r);
            if ("number" == typeof e) {
                if ("string" == typeof t)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return h(this, e)
            }
            return l(this, e, t, r)
        }
        function l(e, t, r, i) {
            if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, r, i) {
                if (t.byteLength,
                0 > r || t.byteLength < r)
                    throw new RangeError("'offset' is out of bounds");
                if (t.byteLength < r + (i || 0))
                    throw new RangeError("'length' is out of bounds");
                return t = void 0 === r && void 0 === i ? new Uint8Array(t) : void 0 === i ? new Uint8Array(t,r) : new Uint8Array(t,r,i),
                c.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = c.prototype : e = u(e, t),
                e
            }(e, t, r, i) : "string" == typeof t ? function(e, t, r) {
                if (("string" != typeof r || "" === r) && (r = "utf8"),
                !c.isEncoding(r))
                    throw new TypeError('"encoding" must be a valid string encoding');
                var i = 0 | f(t, r)
                  , n = (e = o(e, i)).write(t, r);
                return n !== i && (e = e.slice(0, n)),
                e
            }(e, t, r) : function(e, t) {
                if (c.isBuffer(t)) {
                    var r = 0 | d(t.length);
                    return 0 === (e = o(e, r)).length ? e : (t.copy(e, 0, 0, r),
                    e)
                }
                if (t) {
                    if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length"in t)
                        return "number" != typeof t.length || function(e) {
                            return e != e
                        }(t.length) ? o(e, 0) : u(e, t);
                    if ("Buffer" === t.type && s(t.data))
                        return u(e, t.data)
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(e, t)
        }
        function p(e) {
            if ("number" != typeof e)
                throw new TypeError('"size" argument must be a number');
            if (0 > e)
                throw new RangeError('"size" argument must not be negative')
        }
        function h(e, t) {
            if (p(t),
            e = o(e, 0 > t ? 0 : 0 | d(t)),
            !c.TYPED_ARRAY_SUPPORT)
                for (var r = 0; r < t; ++r)
                    e[r] = 0;
            return e
        }
        function u(e, t) {
            var r = 0 > t.length ? 0 : 0 | d(t.length);
            e = o(e, r);
            for (var i = 0; i < r; i += 1)
                e[i] = 255 & t[i];
            return e
        }
        function d(e) {
            if (e >= a())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
            return 0 | e
        }
        function f(e, t) {
            if (c.isBuffer(e))
                return e.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                return e.byteLength;
            "string" != typeof e && (e = "" + e);
            var r = e.length;
            if (0 === r)
                return 0;
            for (var i = !1; ; )
                switch (t) {
                case "ascii":
                case "latin1":
                case "binary":
                    return r;
                case "utf8":
                case "utf-8":
                case void 0:
                    return F(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * r;
                case "hex":
                    return r >>> 1;
                case "base64":
                    return U(e).length;
                default:
                    if (i)
                        return F(e).length;
                    t = ("" + t).toLowerCase(),
                    i = !0
                }
        }
        function m(e, t, r) {
            var i = e[t];
            e[t] = e[r],
            e[r] = i
        }
        function g(e, t, r, i, n) {
            if (0 === e.length)
                return -1;
            if ("string" == typeof r ? (i = r,
            r = 0) : 2147483647 < r ? r = 2147483647 : -2147483648 > r && (r = -2147483648),
            r = +r,
            isNaN(r) && (r = n ? 0 : e.length - 1),
            0 > r && (r = e.length + r),
            r >= e.length) {
                if (n)
                    return -1;
                r = e.length - 1
            } else if (0 > r) {
                if (!n)
                    return -1;
                r = 0
            }
            if ("string" == typeof t && (t = c.from(t, i)),
            c.isBuffer(t))
                return 0 === t.length ? -1 : v(e, t, r, i, n);
            if ("number" == typeof t)
                return t &= 255,
                c.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : v(e, [t], r, i, n);
            throw new TypeError("val must be string, number or Buffer")
        }
        function v(e, t, r, i, n) {
            function s(e, t) {
                return 1 === o ? e[t] : e.readUInt16BE(t * o)
            }
            var a, o = 1, c = e.length, l = t.length;
            if (void 0 !== i && ("ucs2" === (i = (i + "").toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                if (2 > e.length || 2 > t.length)
                    return -1;
                o = 2,
                c /= 2,
                l /= 2,
                r /= 2
            }
            if (n) {
                var p = -1;
                for (a = r; a < c; a++)
                    if (s(e, a) !== s(t, -1 === p ? 0 : a - p))
                        -1 !== p && (a -= a - p),
                        p = -1;
                    else if (-1 === p && (p = a),
                    a - p + 1 === l)
                        return p * o
            } else
                for (r + l > c && (r = c - l),
                a = r; 0 <= a; a--) {
                    for (var h = !0, u = 0; u < l; u++)
                        if (s(e, a + u) !== s(t, u)) {
                            h = !1;
                            break
                        }
                    if (h)
                        return a
                }
            return -1
        }
        function y(e, t, r, i) {
            r = +r || 0;
            var n = e.length - r;
            i ? (i = +i) > n && (i = n) : i = n;
            var s = t.length;
            if (0 != s % 2)
                throw new TypeError("Invalid hex string");
            i > s / 2 && (i = s / 2);
            for (var a, o = 0; o < i; ++o) {
                if (a = parseInt(t.substr(2 * o, 2), 16),
                isNaN(a))
                    return o;
                e[r + o] = a
            }
            return o
        }
        function b(e, t, r, i) {
            return G(F(t, e.length - r), e, r, i)
        }
        function w(e, t, r, i) {
            return G(function(e) {
                for (var t = [], r = 0; r < e.length; ++r)
                    t.push(255 & e.charCodeAt(r));
                return t
            }(t), e, r, i)
        }
        function x(e, t, r, i) {
            return w(e, t, r, i)
        }
        function M(e, t, r, i) {
            return G(U(t), e, r, i)
        }
        function _(e, t, r, i) {
            return G(function(e, t) {
                for (var r, i, n, s = [], a = 0; a < e.length && !(0 > (t -= 2)); ++a)
                    r = e.charCodeAt(a),
                    i = r >> 8,
                    n = r % 256,
                    s.push(n),
                    s.push(i);
                return s
            }(t, e.length - r), e, r, i)
        }
        function S(e, t, r) {
            return 0 === t && r === e.length ? i.fromByteArray(e) : i.fromByteArray(e.slice(t, r))
        }
        function T(e, t, r) {
            r = Math.min(e.length, r);
            for (var i = [], n = t; n < r; ) {
                var s, a, o, c, l = e[n], p = null, h = 239 < l ? 4 : 223 < l ? 3 : 191 < l ? 2 : 1;
                if (n + h <= r)
                    1 === h ? 128 > l && (p = l) : 2 === h ? 128 == (192 & (s = e[n + 1])) && (127 < (c = (31 & l) << 6 | 63 & s) && (p = c)) : 3 === h ? (s = e[n + 1],
                    a = e[n + 2],
                    128 == (192 & s) && 128 == (192 & a) && (2047 < (c = (15 & l) << 12 | (63 & s) << 6 | 63 & a) && (55296 > c || 57343 < c) && (p = c))) : 4 === h && (s = e[n + 1],
                    a = e[n + 2],
                    o = e[n + 3],
                    128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (65535 < (c = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) && 1114112 > c && (p = c)));
                null === p ? (p = 65533,
                h = 1) : 65535 < p && (p -= 65536,
                i.push(55296 | 1023 & p >>> 10),
                p = 56320 | 1023 & p),
                i.push(p),
                n += h
            }
            return function(e) {
                var t = e.length;
                if (t <= E)
                    return String.fromCharCode.apply(String, e);
                for (var r = "", i = 0; i < t; )
                    r += String.fromCharCode.apply(String, e.slice(i, i += E));
                return r
            }(i)
        }
        t.Buffer = c,
        t.SlowBuffer = function(e) {
            return +e != e && (e = 0),
            c.alloc(+e)
        }
        ,
        t.INSPECT_MAX_BYTES = 50,
        c.TYPED_ARRAY_SUPPORT = void 0 === e.TYPED_ARRAY_SUPPORT ? function() {
            try {
                var e = new Uint8Array(1);
                return e.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                },
                42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
            } catch (e) {
                return !1
            }
        }() : e.TYPED_ARRAY_SUPPORT,
        t.kMaxLength = a(),
        c.poolSize = 8192,
        c._augment = function(e) {
            return e.__proto__ = c.prototype,
            e
        }
        ,
        c.from = function(e, t, r) {
            return l(null, e, t, r)
        }
        ,
        c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype,
        c.__proto__ = Uint8Array,
        "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
            value: null,
            configurable: !0
        })),
        c.alloc = function(e, t, r) {
            return function(e, t, r, i) {
                return p(t),
                0 >= t ? o(e, t) : void 0 === r ? o(e, t) : "string" == typeof i ? o(e, t).fill(r, i) : o(e, t).fill(r)
            }(null, e, t, r)
        }
        ,
        c.allocUnsafe = function(e) {
            return h(null, e)
        }
        ,
        c.allocUnsafeSlow = function(e) {
            return h(null, e)
        }
        ,
        c.isBuffer = function(e) {
            return !(null == e || !e._isBuffer)
        }
        ,
        c.compare = function(e, t) {
            if (!c.isBuffer(e) || !c.isBuffer(t))
                throw new TypeError("Arguments must be Buffers");
            if (e === t)
                return 0;
            for (var r = e.length, i = t.length, n = 0, s = Math.min(r, i); n < s; ++n)
                if (e[n] !== t[n]) {
                    r = e[n],
                    i = t[n];
                    break
                }
            return r < i ? -1 : i < r ? 1 : 0
        }
        ,
        c.isEncoding = function(e) {
            switch ((e + "").toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        c.concat = function(e, t) {
            if (!s(e))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e.length)
                return c.alloc(0);
            var r;
            if (void 0 === t)
                for (t = 0,
                r = 0; r < e.length; ++r)
                    t += e[r].length;
            var i = c.allocUnsafe(t)
              , n = 0;
            for (r = 0; r < e.length; ++r) {
                var a = e[r];
                if (!c.isBuffer(a))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                a.copy(i, n),
                n += a.length
            }
            return i
        }
        ,
        c.byteLength = f,
        c.prototype._isBuffer = !0,
        c.prototype.swap16 = function() {
            var e = this.length;
            if (0 != e % 2)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2)
                m(this, t, t + 1);
            return this
        }
        ,
        c.prototype.swap32 = function() {
            var e = this.length;
            if (0 != e % 4)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4)
                m(this, t, t + 3),
                m(this, t + 1, t + 2);
            return this
        }
        ,
        c.prototype.swap64 = function() {
            var e = this.length;
            if (0 != e % 8)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8)
                m(this, t, t + 7),
                m(this, t + 1, t + 6),
                m(this, t + 2, t + 5),
                m(this, t + 3, t + 4);
            return this
        }
        ,
        c.prototype.toString = function() {
            var e = 0 | this.length;
            return 0 == e ? "" : 0 === arguments.length ? T(this, 0, e) : function(e, t, r) {
                var i = !1;
                if ((void 0 === t || 0 > t) && (t = 0),
                t > this.length)
                    return "";
                if ((void 0 === r || r > this.length) && (r = this.length),
                0 >= r)
                    return "";
                if ((r >>>= 0) <= (t >>>= 0))
                    return "";
                for (e || (e = "utf8"); ; )
                    switch (e) {
                    case "hex":
                        return O(this, t, r);
                    case "utf8":
                    case "utf-8":
                        return T(this, t, r);
                    case "ascii":
                        return A(this, t, r);
                    case "latin1":
                    case "binary":
                        return P(this, t, r);
                    case "base64":
                        return S(this, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return R(this, t, r);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(),
                        i = !0
                    }
            }
            .apply(this, arguments)
        }
        ,
        c.prototype.equals = function(e) {
            if (!c.isBuffer(e))
                throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === c.compare(this, e)
        }
        ,
        c.prototype.inspect = function() {
            var e = ""
              , r = t.INSPECT_MAX_BYTES;
            return 0 < this.length && (e = this.toString("hex", 0, r).match(/.{2}/g).join(" "),
            this.length > r && (e += " ... ")),
            "<Buffer " + e + ">"
        }
        ,
        c.prototype.compare = function(e, t, r, i, n) {
            if (!c.isBuffer(e))
                throw new TypeError("Argument must be a Buffer");
            if (void 0 === t && (t = 0),
            void 0 === r && (r = e ? e.length : 0),
            void 0 === i && (i = 0),
            void 0 === n && (n = this.length),
            0 > t || r > e.length || 0 > i || n > this.length)
                throw new RangeError("out of range index");
            if (i >= n && t >= r)
                return 0;
            if (i >= n)
                return -1;
            if (t >= r)
                return 1;
            if (this === e)
                return 0;
            for (var s = (n >>>= 0) - (i >>>= 0), a = (r >>>= 0) - (t >>>= 0), o = Math.min(s, a), l = this.slice(i, n), p = e.slice(t, r), h = 0; h < o; ++h)
                if (l[h] !== p[h]) {
                    s = l[h],
                    a = p[h];
                    break
                }
            return s < a ? -1 : a < s ? 1 : 0
        }
        ,
        c.prototype.includes = function(e, t, r) {
            return -1 !== this.indexOf(e, t, r)
        }
        ,
        c.prototype.indexOf = function(e, t, r) {
            return g(this, e, t, r, !0)
        }
        ,
        c.prototype.lastIndexOf = function(e, t, r) {
            return g(this, e, t, r, !1)
        }
        ,
        c.prototype.write = function(e, t, r, i) {
            if (void 0 === t)
                i = "utf8",
                r = this.length,
                t = 0;
            else if (void 0 === r && "string" == typeof t)
                i = t,
                r = this.length,
                t = 0;
            else {
                if (!isFinite(t))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0,
                isFinite(r) ? (r |= 0,
                void 0 === i && (i = "utf8")) : (i = r,
                r = void 0)
            }
            var n = this.length - t;
            if ((void 0 === r || r > n) && (r = n),
            0 < e.length && (0 > r || 0 > t) || t > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            for (var s = !1; ; )
                switch (i) {
                case "hex":
                    return y(this, e, t, r);
                case "utf8":
                case "utf-8":
                    return b(this, e, t, r);
                case "ascii":
                    return w(this, e, t, r);
                case "latin1":
                case "binary":
                    return x(this, e, t, r);
                case "base64":
                    return M(this, e, t, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return _(this, e, t, r);
                default:
                    if (s)
                        throw new TypeError("Unknown encoding: " + i);
                    i = ("" + i).toLowerCase(),
                    s = !0
                }
        }
        ,
        c.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        var E = 4096;
        function A(e, t, r) {
            var i = "";
            r = Math.min(e.length, r);
            for (var n = t; n < r; ++n)
                i += String.fromCharCode(127 & e[n]);
            return i
        }
        function P(e, t, r) {
            var i = "";
            r = Math.min(e.length, r);
            for (var n = t; n < r; ++n)
                i += String.fromCharCode(e[n]);
            return i
        }
        function O(e, t, r) {
            var i = e.length;
            (!t || 0 > t) && (t = 0),
            (!r || 0 > r || r > i) && (r = i);
            for (var n = "", s = t; s < r; ++s)
                n += j(e[s]);
            return n
        }
        function R(e, t, r) {
            for (var i = e.slice(t, r), n = "", s = 0; s < i.length; s += 2)
                n += String.fromCharCode(i[s] + 256 * i[s + 1]);
            return n
        }
        function C(e, t, r) {
            if (0 != e % 1 || 0 > e)
                throw new RangeError("offset is not uint");
            if (e + t > r)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function L(e, t, r, i, n, s) {
            if (!c.isBuffer(e))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > n || t < s)
                throw new RangeError('"value" argument is out of bounds');
            if (r + i > e.length)
                throw new RangeError("Index out of range")
        }
        function I(e, t, r, i) {
            0 > t && (t = 65535 + t + 1);
            for (var n = 0, s = Math.min(e.length - r, 2); n < s; ++n)
                e[r + n] = (t & 255 << 8 * (i ? n : 1 - n)) >>> 8 * (i ? n : 1 - n)
        }
        function k(e, t, r, i) {
            0 > t && (t = 4294967295 + t + 1);
            for (var n = 0, s = Math.min(e.length - r, 4); n < s; ++n)
                e[r + n] = 255 & t >>> 8 * (i ? n : 3 - n)
        }
        function D(e, t, r, i) {
            if (r + i > e.length)
                throw new RangeError("Index out of range");
            if (0 > r)
                throw new RangeError("Index out of range")
        }
        function z(e, t, r, i, s) {
            return s || D(e, 0, r, 4),
            n.write(e, t, r, i, 23, 4),
            r + 4
        }
        function B(e, t, r, i, s) {
            return s || D(e, 0, r, 8),
            n.write(e, t, r, i, 52, 8),
            r + 8
        }
        c.prototype.slice = function(e, t) {
            var r, i = this.length;
            if (0 > (e = ~~e) ? 0 > (e += i) && (e = 0) : e > i && (e = i),
            0 > (t = void 0 === t ? i : ~~t) ? 0 > (t += i) && (t = 0) : t > i && (t = i),
            t < e && (t = e),
            c.TYPED_ARRAY_SUPPORT)
                (r = this.subarray(e, t)).__proto__ = c.prototype;
            else {
                var n = t - e;
                r = new c(n,void 0);
                for (var s = 0; s < n; ++s)
                    r[s] = this[s + e]
            }
            return r
        }
        ,
        c.prototype.readUIntLE = function(e, t, r) {
            e |= 0,
            t |= 0,
            r || C(e, t, this.length);
            for (var i = this[e], n = 1, s = 0; ++s < t && (n *= 256); )
                i += this[e + s] * n;
            return i
        }
        ,
        c.prototype.readUIntBE = function(e, t, r) {
            e |= 0,
            t |= 0,
            r || C(e, t, this.length);
            for (var i = this[e + --t], n = 1; 0 < t && (n *= 256); )
                i += this[e + --t] * n;
            return i
        }
        ,
        c.prototype.readUInt8 = function(e, t) {
            return t || C(e, 1, this.length),
            this[e]
        }
        ,
        c.prototype.readUInt16LE = function(e, t) {
            return t || C(e, 2, this.length),
            this[e] | this[e + 1] << 8
        }
        ,
        c.prototype.readUInt16BE = function(e, t) {
            return t || C(e, 2, this.length),
            this[e] << 8 | this[e + 1]
        }
        ,
        c.prototype.readUInt32LE = function(e, t) {
            return t || C(e, 4, this.length),
            (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
        }
        ,
        c.prototype.readUInt32BE = function(e, t) {
            return t || C(e, 4, this.length),
            16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        }
        ,
        c.prototype.readIntLE = function(e, t, r) {
            e |= 0,
            t |= 0,
            r || C(e, t, this.length);
            for (var i = this[e], n = 1, s = 0; ++s < t && (n *= 256); )
                i += this[e + s] * n;
            return i >= (n *= 128) && (i -= Math.pow(2, 8 * t)),
            i
        }
        ,
        c.prototype.readIntBE = function(e, t, r) {
            e |= 0,
            t |= 0,
            r || C(e, t, this.length);
            for (var i = t, n = 1, s = this[e + --i]; 0 < i && (n *= 256); )
                s += this[e + --i] * n;
            return s >= (n *= 128) && (s -= Math.pow(2, 8 * t)),
            s
        }
        ,
        c.prototype.readInt8 = function(e, t) {
            return t || C(e, 1, this.length),
            128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
        }
        ,
        c.prototype.readInt16LE = function(e, t) {
            t || C(e, 2, this.length);
            var r = this[e] | this[e + 1] << 8;
            return 32768 & r ? 4294901760 | r : r
        }
        ,
        c.prototype.readInt16BE = function(e, t) {
            t || C(e, 2, this.length);
            var r = this[e + 1] | this[e] << 8;
            return 32768 & r ? 4294901760 | r : r
        }
        ,
        c.prototype.readInt32LE = function(e, t) {
            return t || C(e, 4, this.length),
            this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        }
        ,
        c.prototype.readInt32BE = function(e, t) {
            return t || C(e, 4, this.length),
            this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        }
        ,
        c.prototype.readFloatLE = function(e, t) {
            return t || C(e, 4, this.length),
            n.read(this, e, !0, 23, 4)
        }
        ,
        c.prototype.readFloatBE = function(e, t) {
            return t || C(e, 4, this.length),
            n.read(this, e, !1, 23, 4)
        }
        ,
        c.prototype.readDoubleLE = function(e, t) {
            return t || C(e, 8, this.length),
            n.read(this, e, !0, 52, 8)
        }
        ,
        c.prototype.readDoubleBE = function(e, t) {
            return t || C(e, 8, this.length),
            n.read(this, e, !1, 52, 8)
        }
        ,
        c.prototype.writeUIntLE = function(e, t, r, i) {
            (e = +e,
            t |= 0,
            r |= 0,
            i) || L(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var n = 1
              , s = 0;
            for (this[t] = 255 & e; ++s < r && (n *= 256); )
                this[t + s] = 255 & e / n;
            return t + r
        }
        ,
        c.prototype.writeUIntBE = function(e, t, r, i) {
            (e = +e,
            t |= 0,
            r |= 0,
            i) || L(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var n = r - 1
              , s = 1;
            for (this[t + n] = 255 & e; 0 <= --n && (s *= 256); )
                this[t + n] = 255 & e / s;
            return t + r
        }
        ,
        c.prototype.writeUInt8 = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 1, 255, 0),
            c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
            this[t] = 255 & e,
            t + 1
        }
        ,
        c.prototype.writeUInt16LE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8) : I(this, e, t, !0),
            t + 2
        }
        ,
        c.prototype.writeUInt16BE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
            this[t + 1] = 255 & e) : I(this, e, t, !1),
            t + 2
        }
        ,
        c.prototype.writeUInt32LE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24,
            this[t + 2] = e >>> 16,
            this[t + 1] = e >>> 8,
            this[t] = 255 & e) : k(this, e, t, !0),
            t + 4
        }
        ,
        c.prototype.writeUInt32BE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
            this[t + 1] = e >>> 16,
            this[t + 2] = e >>> 8,
            this[t + 3] = 255 & e) : k(this, e, t, !1),
            t + 4
        }
        ,
        c.prototype.writeIntLE = function(e, t, r, i) {
            if (e = +e,
            t |= 0,
            !i) {
                var n = Math.pow(2, 8 * r - 1);
                L(this, e, t, r, n - 1, -n)
            }
            var s = 0
              , a = 1
              , o = 0;
            for (this[t] = 255 & e; ++s < r && (a *= 256); )
                0 > e && 0 === o && 0 !== this[t + s - 1] && (o = 1),
                this[t + s] = 255 & (e / a >> 0) - o;
            return t + r
        }
        ,
        c.prototype.writeIntBE = function(e, t, r, i) {
            if (e = +e,
            t |= 0,
            !i) {
                var n = Math.pow(2, 8 * r - 1);
                L(this, e, t, r, n - 1, -n)
            }
            var s = r - 1
              , a = 1
              , o = 0;
            for (this[t + s] = 255 & e; 0 <= --s && (a *= 256); )
                0 > e && 0 === o && 0 !== this[t + s + 1] && (o = 1),
                this[t + s] = 255 & (e / a >> 0) - o;
            return t + r
        }
        ,
        c.prototype.writeInt8 = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 1, 127, -128),
            c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
            0 > e && (e = 255 + e + 1),
            this[t] = 255 & e,
            t + 1
        }
        ,
        c.prototype.writeInt16LE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8) : I(this, e, t, !0),
            t + 2
        }
        ,
        c.prototype.writeInt16BE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
            this[t + 1] = 255 & e) : I(this, e, t, !1),
            t + 2
        }
        ,
        c.prototype.writeInt32LE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 4, 2147483647, -2147483648),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
            this[t + 1] = e >>> 8,
            this[t + 2] = e >>> 16,
            this[t + 3] = e >>> 24) : k(this, e, t, !0),
            t + 4
        }
        ,
        c.prototype.writeInt32BE = function(e, t, r) {
            return e = +e,
            t |= 0,
            r || L(this, e, t, 4, 2147483647, -2147483648),
            0 > e && (e = 4294967295 + e + 1),
            c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
            this[t + 1] = e >>> 16,
            this[t + 2] = e >>> 8,
            this[t + 3] = 255 & e) : k(this, e, t, !1),
            t + 4
        }
        ,
        c.prototype.writeFloatLE = function(e, t, r) {
            return z(this, e, t, !0, r)
        }
        ,
        c.prototype.writeFloatBE = function(e, t, r) {
            return z(this, e, t, !1, r)
        }
        ,
        c.prototype.writeDoubleLE = function(e, t, r) {
            return B(this, e, t, !0, r)
        }
        ,
        c.prototype.writeDoubleBE = function(e, t, r) {
            return B(this, e, t, !1, r)
        }
        ,
        c.prototype.copy = function(e, t, r, i) {
            if (r || (r = 0),
            i || 0 === i || (i = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            0 < i && i < r && (i = r),
            i === r)
                return 0;
            if (0 === e.length || 0 === this.length)
                return 0;
            if (0 > t)
                throw new RangeError("targetStart out of bounds");
            if (0 > r || r >= this.length)
                throw new RangeError("sourceStart out of bounds");
            if (0 > i)
                throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length),
            e.length - t < i - r && (i = e.length - t + r);
            var n, s = i - r;
            if (this === e && r < t && t < i)
                for (n = s - 1; 0 <= n; --n)
                    e[n + t] = this[n + r];
            else if (1e3 > s || !c.TYPED_ARRAY_SUPPORT)
                for (n = 0; n < s; ++n)
                    e[n + t] = this[n + r];
            else
                Uint8Array.prototype.set.call(e, this.subarray(r, r + s), t);
            return s
        }
        ,
        c.prototype.fill = function(e, t, r, i) {
            if ("string" == typeof e) {
                if ("string" == typeof t ? (i = t,
                t = 0,
                r = this.length) : "string" == typeof r && (i = r,
                r = this.length),
                1 === e.length) {
                    var n = e.charCodeAt(0);
                    256 > n && (e = n)
                }
                if (void 0 !== i && "string" != typeof i)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof i && !c.isEncoding(i))
                    throw new TypeError("Unknown encoding: " + i)
            } else
                "number" == typeof e && (e &= 255);
            if (0 > t || this.length < t || this.length < r)
                throw new RangeError("Out of range index");
            if (r <= t)
                return this;
            var s;
            if (t >>>= 0,
            r = void 0 === r ? this.length : r >>> 0,
            e || (e = 0),
            "number" == typeof e)
                for (s = t; s < r; ++s)
                    this[s] = e;
            else {
                var a = c.isBuffer(e) ? e : F(new c(e,i).toString())
                  , o = a.length;
                for (s = 0; s < r - t; ++s)
                    this[s + t] = a[s % o]
            }
            return this
        }
        ;
        var N = /[^+\/0-9A-Za-z-_]/g;
        function j(e) {
            return 16 > e ? "0" + e.toString(16) : e.toString(16)
        }
        function F(e, t) {
            t = t || 1 / 0;
            for (var r, i = e.length, n = null, s = [], a = 0; a < i; ++a) {
                if (55295 < (r = e.charCodeAt(a)) && 57344 > r) {
                    if (!n) {
                        if (56319 < r) {
                            -1 < (t -= 3) && s.push(239, 191, 189);
                            continue
                        }
                        if (a + 1 === i) {
                            -1 < (t -= 3) && s.push(239, 191, 189);
                            continue
                        }
                        n = r;
                        continue
                    }
                    if (56320 > r) {
                        -1 < (t -= 3) && s.push(239, 191, 189),
                        n = r;
                        continue
                    }
                    r = 65536 + (n - 55296 << 10 | r - 56320)
                } else
                    n && -1 < (t -= 3) && s.push(239, 191, 189);
                if (n = null,
                128 > r) {
                    if (0 > (t -= 1))
                        break;
                    s.push(r)
                } else if (2048 > r) {
                    if (0 > (t -= 2))
                        break;
                    s.push(192 | r >> 6, 128 | 63 & r)
                } else if (65536 > r) {
                    if (0 > (t -= 3))
                        break;
                    s.push(224 | r >> 12, 128 | 63 & r >> 6, 128 | 63 & r)
                } else {
                    if (!(1114112 > r))
                        throw new Error("Invalid code point");
                    if (0 > (t -= 4))
                        break;
                    s.push(240 | r >> 18, 128 | 63 & r >> 12, 128 | 63 & r >> 6, 128 | 63 & r)
                }
            }
            return s
        }
        function U(e) {
            return i.toByteArray(function(e) {
                if (2 > (e = function(e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                }(e).replace(N, "")).length)
                    return "";
                for (; 0 != e.length % 4; )
                    e += "=";
                return e
            }(e))
        }
        function G(e, t, r, i) {
            for (var n = 0; n < i && !(n + r >= t.length || n >= e.length); ++n)
                t[n + r] = e[n];
            return n
        }
    }
    ).call(this, r(22))
}
, function(e, t) {
    for (var r = t.uint8 = Array(256), i = 0; 255 >= i; i++)
        r[i] = n(i);
    function n(e) {
        return function(t) {
            var r = t.reserve(1);
            t.buffer[r] = e
        }
    }
}
, function(e, t, r) {
    t.FlexDecoder = o,
    t.FlexEncoder = c;
    var i = r(3)
      , n = 2048
      , s = 65536
      , a = "BUFFER_SHORTAGE";
    function o() {
        if (!(this instanceof o))
            return new o
    }
    function c() {
        if (!(this instanceof c))
            return new c
    }
    function l() {
        throw new Error("method not implemented: write()")
    }
    function p() {
        throw new Error("method not implemented: fetch()")
    }
    function h() {
        return this.buffers && this.buffers.length ? (this.flush(),
        this.pull()) : this.fetch()
    }
    function u(e) {
        (this.buffers || (this.buffers = [])).push(e)
    }
    function d() {
        return (this.buffers || (this.buffers = [])).shift()
    }
    function f(e) {
        return function(t) {
            for (var r in e)
                t[r] = e[r];
            return t
        }
    }
    o.mixin = f({
        bufferish: i,
        write: function(e) {
            var t = this.offset ? i.prototype.slice.call(this.buffer, this.offset) : this.buffer;
            this.buffer = t ? e ? this.bufferish.concat([t, e]) : t : e,
            this.offset = 0
        },
        fetch: p,
        flush: function() {
            for (; this.offset < this.buffer.length; ) {
                var e, t = this.offset;
                try {
                    e = this.fetch()
                } catch (e) {
                    if (e && e.message != a)
                        throw e;
                    this.offset = t;
                    break
                }
                this.push(e)
            }
        },
        push: u,
        pull: d,
        read: h,
        reserve: function(e) {
            var t = this.offset
              , r = t + e;
            if (r > this.buffer.length)
                throw new Error(a);
            return this.offset = r,
            t
        },
        offset: 0
    }),
    o.mixin(o.prototype),
    c.mixin = f({
        bufferish: i,
        write: l,
        fetch: function() {
            var e = this.start;
            if (e < this.offset) {
                var t = this.start = this.offset;
                return i.prototype.slice.call(this.buffer, e, t)
            }
        },
        flush: function() {
            for (; this.start < this.offset; ) {
                var e = this.fetch();
                e && this.push(e)
            }
        },
        push: u,
        pull: function() {
            var e = this.buffers || (this.buffers = [])
              , t = 1 < e.length ? this.bufferish.concat(e) : e[0];
            return e.length = 0,
            t
        },
        read: h,
        reserve: function(e) {
            var t = 0 | e;
            if (this.buffer) {
                var r = this.buffer.length
                  , i = 0 | this.offset
                  , n = i + t;
                if (n < r)
                    return this.offset = n,
                    i;
                this.flush(),
                e = Math.max(e, Math.min(2 * r, this.maxBufferSize))
            }
            return e = Math.max(e, this.minBufferSize),
            this.buffer = this.bufferish.alloc(e),
            this.start = 0,
            this.offset = t,
            0
        },
        send: function(e) {
            var t = e.length;
            if (t > this.minBufferSize)
                this.flush(),
                this.push(e);
            else {
                var r = this.reserve(t);
                i.prototype.copy.call(e, this.buffer, r)
            }
        },
        maxBufferSize: s,
        minBufferSize: n,
        offset: 0,
        start: 0
    }),
    c.mixin(c.prototype)
}
, function(e, t, r) {
    t.decode = function(e, t) {
        var r = new i(t);
        return r.write(e),
        r.read()
    }
    ;
    var i = r(32).DecodeBuffer
}
, function(e, t, r) {
    t.DecodeBuffer = n;
    var i = r(20).preset;
    function n(e) {
        if (!(this instanceof n))
            return new n(e);
        if (e && (this.options = e,
        e.codec)) {
            var t = this.codec = e.codec;
            t.bufferish && (this.bufferish = t.bufferish)
        }
    }
    r(30).FlexDecoder.mixin(n.prototype),
    n.prototype.codec = i,
    n.prototype.fetch = function() {
        return this.codec.decode(this)
    }
}
, function(e, t, r) {
    var i = r(17)
      , n = r(19)
      , s = n.Uint64BE
      , a = n.Int64BE;
    t.getReadFormat = function(e) {
        var t = o.hasArrayBuffer && e && e.binarraybuffer
          , r = e && e.int64;
        return {
            map: l && e && e.usemap ? u : h,
            array: d,
            str: f,
            bin: t ? g : m,
            ext: v,
            uint8: y,
            uint16: w,
            uint32: M,
            uint64: S(8, r ? A : T),
            int8: b,
            int16: x,
            int32: _,
            int64: S(8, r ? P : E),
            float32: S(4, O),
            float64: S(8, R)
        }
    }
    ,
    t.readUint8 = y;
    var o = r(3)
      , c = r(18)
      , l = "undefined" != typeof Map
      , p = !0;
    function h(e, t) {
        var r, i = {}, n = Array(t), s = Array(t), a = e.codec.decode;
        for (r = 0; r < t; r++)
            n[r] = a(e),
            s[r] = a(e);
        for (r = 0; r < t; r++)
            i[n[r]] = s[r];
        return i
    }
    function u(e, t) {
        var r, i = new Map, n = Array(t), s = Array(t), a = e.codec.decode;
        for (r = 0; r < t; r++)
            n[r] = a(e),
            s[r] = a(e);
        for (r = 0; r < t; r++)
            i.set(n[r], s[r]);
        return i
    }
    function d(e, t) {
        for (var r = Array(t), i = e.codec.decode, n = 0; n < t; n++)
            r[n] = i(e);
        return r
    }
    function f(e, t) {
        var r = e.reserve(t);
        return c.toString.call(e.buffer, "utf-8", r, r + t)
    }
    function m(e, t) {
        var r = e.reserve(t)
          , i = c.slice.call(e.buffer, r, r + t);
        return o.from(i)
    }
    function g(e, t) {
        var r = e.reserve(t)
          , i = c.slice.call(e.buffer, r, r + t);
        return o.Uint8Array.from(i).buffer
    }
    function v(e, t) {
        var r = e.reserve(t + 1)
          , i = e.buffer[r++]
          , n = r + t
          , s = e.codec.getExtUnpacker(i);
        if (!s)
            throw new Error("Invalid ext type: " + (i ? "0x" + i.toString(16) : i));
        return s(c.slice.call(e.buffer, r, n))
    }
    function y(e) {
        var t = e.reserve(1);
        return e.buffer[t]
    }
    function b(e) {
        var t = e.reserve(1)
          , r = e.buffer[t];
        return 128 & r ? r - 256 : r
    }
    function w(e) {
        var t = e.reserve(2)
          , r = e.buffer;
        return r[t++] << 8 | r[t]
    }
    function x(e) {
        var t = e.reserve(2)
          , r = e.buffer
          , i = r[t++] << 8 | r[t];
        return 32768 & i ? i - 65536 : i
    }
    function M(e) {
        var t = e.reserve(4)
          , r = e.buffer;
        return 16777216 * r[t++] + (r[t++] << 16) + (r[t++] << 8) + r[t]
    }
    function _(e) {
        var t = e.reserve(4)
          , r = e.buffer;
        return r[t++] << 24 | r[t++] << 16 | r[t++] << 8 | r[t]
    }
    function S(e, t) {
        return function(r) {
            var i = r.reserve(e);
            return t.call(r.buffer, i, p)
        }
    }
    function T(e) {
        return new s(this,e).toNumber()
    }
    function E(e) {
        return new a(this,e).toNumber()
    }
    function A(e) {
        return new s(this,e)
    }
    function P(e) {
        return new a(this,e)
    }
    function O(e) {
        return i.read(this, e, !1, 23, 4)
    }
    function R(e) {
        return i.read(this, e, !1, 52, 8)
    }
}
, function(e, t, r) {
    !function(t) {
        function r(e) {
            for (var t in s)
                e[t] = s[t];
            return e
        }
        function i(e, t) {
            var r, s = this;
            if (arguments.length) {
                if (t) {
                    if (r = n(s, e, !0)) {
                        if (!(r = r.filter(function(e) {
                            return e !== t && e.originalListener !== t
                        })).length)
                            return i.call(s, e);
                        s.listeners[e] = r
                    }
                } else if ((r = s.listeners) && (delete r[e],
                !Object.keys(r).length))
                    return i.call(s)
            } else
                delete s.listeners;
            return s
        }
        function n(e, t, r) {
            if (!r || e.listeners) {
                var i = e.listeners || (e.listeners = {});
                return i[t] || (i[t] = [])
            }
        }
        e.exports = t;
        var s = {
            on: function(e, t) {
                return n(this, e).push(t),
                this
            },
            once: function(e, t) {
                function r() {
                    i.call(s, e, r),
                    t.apply(this, arguments)
                }
                var s = this;
                return r.originalListener = t,
                n(s, e).push(r),
                s
            },
            off: i,
            emit: function(e, t) {
                var r = this
                  , i = n(r, e, !0);
                if (!i)
                    return !1;
                var s = arguments.length;
                if (1 === s)
                    i.forEach(function(e) {
                        e.call(r)
                    });
                else if (2 === s)
                    i.forEach(function(e) {
                        e.call(r, t)
                    });
                else {
                    var a = Array.prototype.slice.call(arguments, 1);
                    i.forEach(function(e) {
                        e.apply(r, a)
                    })
                }
                return !!i.length
            }
        };
        r(t.prototype),
        t.mixin = r
    }(/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
    function e() {
        if (!(this instanceof e))
            return new e
    })
}
, function(e) {
    e.exports = "DEV"
}
, function(e, t, r) {
    "use strict";
    r.d(t, "a", function() {
        return i
    });
    var i = function() {
        function e() {
            this._hasWeakSet = "function" == typeof WeakSet,
            this._inner = this._hasWeakSet ? new WeakSet : []
        }
        return e.prototype.memoize = function(e) {
            if (this._hasWeakSet)
                return !!this._inner.has(e) || (this._inner.add(e),
                !1);
            for (var t = 0; t < this._inner.length; t++)
                if (this._inner[t] === e)
                    return !0;
            return this._inner.push(e),
            !1
        }
        ,
        e.prototype.unmemoize = function(e) {
            if (this._hasWeakSet)
                this._inner.delete(e);
            else
                for (var t = 0; t < this._inner.length; t++)
                    if (this._inner[t] === e) {
                        this._inner.splice(t, 1);
                        break
                    }
        }
        ,
        e
    }()
}
, function(e, t) {
    var r, i;
    e.exports.events = ["onShoot", "onMelee", "onDamage", "onEnter", "onDestroy", "onRespawn"],
    e.exports.actions = [{
        name: "Give Player Score",
        execute: function(e, t, r, i) {
            e.players.score(r, i.triggerConstant || 1)
        }
    }, {
        name: "Kill Player",
        execute: function(e, t, r) {
            e.players.kill(r)
        }
    }, {
        name: "Respawn Player",
        execute: function(e, t, r) {
            var i = e.getSpawnPoint(r.team, r);
            r.x = i.x,
            r.y = i.y,
            r.z = i.z
        }
    }, {
        name: "Change Player Health",
        execute: function(e, t, r, i) {
            e.players.changeHealth(r, null, -(i.triggerConstant || 0), !0) && e.players.kill(r, null, {})
        }
    }, {
        name: "Destroy Interface",
        execute: function(e, t, r, n) {
            for (var s = 0; s < e.map.manager.interfaces.length; ++s)
                (i = e.map.manager.objects[e.map.manager.interfaces[s]]).sid != n.sid && i.health && i.interface != n.interface && i.interface == n.interfaceT && (i.active = !1,
                i.health = 0,
                i.destroyedBy = r,
                e.destObjs.push(i.uid),
                t.broadcast("game" + e.sid, "do", i.uid),
                (i.onDestroy || i.onDamage) && e.onTrigger(r, i))
        }
    }, {
        name: "Toggle Interface Gate",
        execute: function(e, t, r, n) {
            for (var s = 0; s < e.map.manager.interfaces.length; ++s)
                (i = e.map.manager.objects[e.map.manager.interfaces[s]]).sid != n.sid && i.gate && i.interface != n.interface && i.interface == n.interfaceT && (i.active = !i.active,
                t.broadcast("game" + e.sid, "gte", i.uid, i.active))
        }
    }, {
        name: "Change Interface Health",
        execute: function(e, t, r, n) {
            for (var s = 0; s < e.map.manager.interfaces.length; ++s)
                (i = e.map.manager.objects[e.map.manager.interfaces[s]]).sid != n.sid && i.health && i.interface != n.interface && i.interface == n.interfaceT && (i.health -= -(n.triggerConstant || 0),
                0 >= i.health && (i.active = !1,
                i.health = 0,
                i.destroyedBy = r,
                e.destObjs.push(i.uid),
                t.broadcast("game" + e.sid, "do", i.uid),
                i && i.onDestroy && e.onTrigger(r, i)),
                i && i.onDamage && e.onTrigger(r, i))
        }
    }, {
        name: "Teleport To Interface",
        execute: function(e, t, r, n) {
            for (var s = 0; s < e.map.manager.interfaces.length; ++s)
                (i = e.map.manager.objects[e.map.manager.interfaces[s]]).sid != n.sid && i.interface != n.interface && i.interface == n.interfaceT && e.players.changePosition(r, i.x, i.y - i.height, i.z, !0)
        }
    }, {
        name: "Change Interface Deposit Box Amount",
        execute: function(e, t, r, n) {
            for (var s = 0; s < e.map.manager.interfaces.length; ++s)
                (i = e.map.manager.objects[e.map.manager.interfaces[s]]).sid != n.sid && i.interface != n.interface && i.interface == n.interfaceT && i.bank && (i.deposited += n.triggerConstant || 0,
                t.broadcast("game" + e.sid, "bnk", i.uid, i.deposited))
        }
    }, {
        name: "Kill Opposing Team",
        execute: function(e, t, i) {
            for (var n = 0; n < e.players.list.length; ++n)
                (r = e.players.list[n]).active && r != i && (!r.team || i.team != r.team) && e.players.kill(r, null, null, !0)
        }
    }, {
        name: "Respawn Opposing Team",
        execute: function(e, t, i) {
            for (var n = 0; n < e.players.list.length; ++n)
                if ((r = e.players.list[n]).active && r != i && (!r.team || i.team != r.team)) {
                    var s = e.getSpawnPoint(r.team, r);
                    r.x = s.x,
                    r.y = s.y,
                    r.z = s.z
                }
        }
    }, {
        name: "Respawn Destructible Interface",
        execute: function(e, t, n, s) {
            for (var a = 0; a < e.map.manager.interfaces.length; ++a)
                r = e.map.manager.objects[e.map.manager.interfaces[a]],
                i = e.destObjs.indexOf(r.uid),
                r.sid != s.sid && r.startHealth && 0 == r.health && -1 != i && r.interface != s.interface && r.interface == s.interfaceT && (e.destObjs.splice(i, 1),
                r.active = !0,
                r.respawnT = r.respawnR ? 0 : r.respawnTStart,
                null != r.health && (r.health = r.startHealth),
                t.broadcast("game" + e.sid, "ro", r.uid),
                r && r.onRespawn && r.destroyedBy && e.onTrigger(r.destroyedBy, r),
                r.destroyedBy = null)
        }
    }, {
        name: "Toggle Destructible Interface",
        execute: function(e, t, n, s) {
            for (var a = 0; a < e.map.manager.interfaces.length; ++a)
                r = e.map.manager.objects[e.map.manager.interfaces[a]],
                i = e.destObjs.indexOf(r.uid),
                r.sid != s.sid && r.startHealth && r.interface != s.interface && r.interface == s.interfaceT && (-1 == i ? (r.active = !1,
                r.health = 0,
                r.destroyedBy = n,
                e.destObjs.push(r.uid),
                t.broadcast("game" + e.sid, "do", r.uid),
                (r.onDestroy || r.onDamage) && e.onTrigger(n, r)) : (e.destObjs.splice(i, 1),
                r.active = !0,
                r.respawnT = r.respawnR ? 0 : r.respawnTStart,
                null != r.health && (r.health = r.startHealth),
                t.broadcast("game" + e.sid, "ro", r.uid),
                r && r.onRespawn && r.destroyedBy && e.onTrigger(r.destroyedBy, r),
                r.destroyedBy = null))
        }
    }]
}
, function(e, t, r) {
    let i = r(4);
    const n = r(7)
      , s = r(24)
      , a = r(8)
      , o = r(23);
    let c = new i.TextureLoader
      , l = new i.LoadingManager
      , p = new i.OBJLoader(l);
    function h(e, t, r, n, s, o=0, l=0, h=0, u=null) {
        return new Promise(d=>{
            p.load(a.assetsUrl(t), t=>{
                let p;
                r && (p = c.load(a.assetsUrl(r), e=>{
                    e.wrapS = i.RepeatWrapping,
                    e.wrapT = i.RepeatWrapping,
                    e.repeat.set(1, 1),
                    e.minFilter = i.NearestFilter,
                    e.magFilter = i.NearestFilter,
                    e.needsUpdate = !0
                }
                ));
                let f = new i.StrippedLambertMaterial({
                    map: p
                })
                  , m = new i.Geometry;
                t.traverse(e=>{
                    e instanceof i.Mesh && (e.geometry.isBufferGeometry ? (m.fromBufferGeometry(e.geometry),
                    m.computeFlatVertexNormals(),
                    e.geometry.fromGeometry(m)) : e.geometry.computeFlatVertexNormals(),
                    e.material = f)
                }
                ),
                f.vertexColors = i.VertexColors,
                f.color.set(s || 16777215),
                t.scale.setScalar(n || 1),
                t.position.y += o,
                t.rotateX(l || 0),
                t.rotateY(h || 0),
                u ? (e[u] && (e.remove(e[u]),
                e[u] = null),
                e[u] = t,
                e.add(e[u])) : e.add(t),
                d(t)
            }
            )
        }
        )
    }
    new i.BoxBufferGeometry(1,1,1);
    new i.PlaneBufferGeometry(1,1).rotateX(-Math.PI / 2);
    new i.StrippedLambertMaterial({
        color: 65280
    }),
    new i.StrippedLambertMaterial({
        color: 5592405
    });
    function u(e, t, r, n) {
        var a = s.generateCube([1, 1, 1, 1, 1, 1], e, t, r, {
            scale: 1,
            amb: n,
            useScale: !0
        });
        return a = (new i.BufferGeometry).fromGeometry(a)
    }
    let d = (e,t,r,n,a,o,c,l,p,h)=>{
        (c = c || {}).premultipliedAlpha = !0;
        var u = new i.Mesh(s.generatePlane(o, a, c, t, r, n));
        u.position.set(t, r, n),
        u.rotateY(l || 0),
        u.rotateX((p || 0) - Math.PI / 2),
        u.rotateZ(h || 0),
        u.scale.set(2 * a, 2 * o, 1),
        u.updateMatrix(),
        e.merge(u.geometry, u.matrix)
    }
      , f = (e,t,r,n,a,o,c,l,p)=>{
        p = p || {};
        var h = new i.Mesh(s.generateCube(l, a, o, c, p));
        return h.position.set(t, r, n),
        h.rotation.set(p.yR || 0, p.xR || 0, p.zR || 0),
        h.scale.set(a, o, c),
        e instanceof i.Geometry ? (h.updateMatrix(),
        e.merge(h.geometry, h.matrix)) : e.add(h),
        h
    }
    ;
    e.exports.prefabs = {
        CRATE: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/crate_0.obj", "textures/crate_0.png", n.crateScale, e.color),
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        STACK: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/stack_0.obj", "textures/stack_0.png", n.crateScale, e.color),
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        BARREL: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/barrel_0.obj", "textures/barrel_0.png", n.barrelScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        ACIDBARREL: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            emiss: !0,
            gen: e=>h(e, "models/acidbarrel_0.obj", "textures/acidbarrel_0.png", n.acidbarrelScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        TREE: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            complex: !0,
            gen: e=>h(e, "models/tree_0.obj", "textures/tree_0.png", n.treeScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        CONE: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            complex: !0,
            gen: e=>h(e, "models/cone_0.obj", "textures/cone_0.png", n.coneScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        TEDDY: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            complex: !0,
            gen: e=>h(e, "models/teddy_0.obj", "textures/teddy_0.png", n.teddyScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        CONTAINER: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/container_0.obj", "textures/container_0.png", n.containerScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        CONTAINERR: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/containerr_0.obj", "textures/containerr_0.png", n.containerScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        DOOR: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/door_0.obj", "textures/door_0.png", n.doorScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        WINDOW: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            gen: e=>h(e, "models/window_0.obj", "textures/window_0.png", n.windowScale, e.color),
            castShadow: !0,
            transparent: !0,
            receiveShadow: !0
        },
        GRASS: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            complex: !0,
            doubleSide: !0,
            transparent: !0,
            gen: e=>h(e, "models/grass_0.obj", "textures/grass_0.png", n.grassScale, e.color),
            receiveShadow: !0
        },
        WEAPON_PICKUP: {
            notStyleable: !0,
            interact: !0,
            customScore: !0,
            defaultSize: [n.pickupZoneX, n.pickupZoneH, n.pickupZoneZ],
            scalable: !1,
            tool: !0,
            scaleWithSize: !1,
            lineCol: 3595263,
            noTexture: !0,
            texturable: !1,
            opacity: .1,
            genGeo: async(e,t)=>(function(e, t) {
                let r = s.generateCube([1, 1, 1, 1, 1, 1], ...e.size, {
                    scale: 1,
                    amb: t,
                    useScale: !0
                });
                return r = (new i.BufferGeometry).fromGeometry(r),
                h(e, "models/weapons/" + o[e.weaponId].src + ".obj", "textures/weapons/" + o[e.weaponId].src + ".png", o[e.weaponId].scale, 16777215, -.5, -1.6, 0, "wepMesh"),
                r
            }
            )(e, t),
            stepSrc: "a"
        },
        VEHICLE: {
            canInterface: !0,
            hasHealth: !0,
            editColor: !0,
            dontRound: !0,
            complex: !0,
            emiss: !0,
            gen: e=>h(e, "models/vehicle_0.obj", "textures/vehicle_0.png", n.vehicleScale, e.color),
            castShadow: !0,
            receiveShadow: !0
        },
        LADDER: {
            notTechnical: !0,
            defaultSize: [2, 10, 4],
            scalable: !0,
            scaleWithSize: !1,
            editColor: !0,
            hideBoundingBox: !1,
            texturable: !0,
            genGeo: async e=>(function(e, t, r, s) {
                var o = new i.Geometry;
                s = s * Math.PI / 2;
                let c = {
                    x: 0 + n.ladderScale * Math.cos(s),
                    z: 0 + n.ladderScale * Math.sin(s),
                    y: 0 - t / 2
                };
                f(o, c.x + n.ladderWidth * Math.sin(s), c.y, c.z + n.ladderWidth * Math.cos(s), 2 * n.ladderScale, t + 2, 2 * n.ladderScale, [1, 1, 1, 1, 1, 1], {
                    scale: .02
                }),
                f(o, c.x - n.ladderWidth * Math.sin(s), c.y, c.z - n.ladderWidth * Math.cos(s), 2 * n.ladderScale, t + 2, 2 * n.ladderScale, [1, 1, 1, 1, 1, 1], {
                    scale: .02
                });
                for (var l = Math.floor(t / 6), p = 0; p < l; ++p)
                    d(o, c.x, c.y + 6 * (p + 1) + a.randFloat(-1, 1), c.z, n.ladderWidth, n.ladderScale, {
                        scale: .02
                    }, -s + Math.PI / 2, Math.PI / 2, a.randFloat(-.1, .1));
                return o
            }
            )(...e.size, e.direction),
            customDirection: !0,
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        CUBE: {
            canInterface: !0,
            movingTexture: !0,
            defaultSize: [10, 10, 10],
            hasHealth: !0,
            scalable: !0,
            editAmb: !0,
            scaleWithSize: !1,
            editColor: !0,
            editEmissive: !0,
            editOpac: !0,
            hideBoundingBox: !1,
            editPen: !0,
            texturable: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            hasBorder: !0
        },
        RAMP: {
            notTechnical: !0,
            defaultSize: [10, 5, 10],
            movingTexture: !0,
            scalable: !0,
            scaleWithSize: !1,
            hideBoundingBox: !1,
            boostable: !0,
            editColor: !0,
            editEmissive: !0,
            texturable: !0,
            genGeo: async e=>(function(e, t, r, n, a, o, c) {
                var l = new i.Geometry;
                t = 0 - a / 2;
                var p = 0 != (c = c * Math.PI / 2) && c != Math.PI;
                return ((e,t,r,n,a,o,c,p,h)=>{
                    p = p || {};
                    var u = new i.Mesh(s.generatePlane(2 * o, n, p));
                    u.position.set(e, t + a / 2, r),
                    o *= 2;
                    var d = Math.sqrt(a * a + o * o);
                    u.scale.set(n, d, 2),
                    u.rotateY(-Math.PI / 2 - c),
                    u.rotateX(Math.asin(a / d) - Math.PI / 2),
                    u.rotateZ(h || 0),
                    u.updateMatrix(),
                    l.merge(u.geometry, u.matrix)
                }
                )(e, t, r, p ? n : o, a, (p ? o : n) / 2, c, {
                    scale: 1
                }),
                l
            }
            )(0, 0, 0, ...e.size, e.direction),
            shootable: !0,
            customDirection: !0,
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            doubleSide: !0
        },
        PLANE: {
            canInterface: !0,
            hasHealth: !0,
            defaultSize: [4, .01, 4],
            movingTexture: !0,
            dontRound: !0,
            scalable: !0,
            canTerrain: !0,
            edgeNoise: !0,
            scaleWithSize: !0,
            editColor: !0,
            editPen: !0,
            editEmissive: !0,
            editOpac: !0,
            hideBoundingBox: !1,
            texturable: !0,
            genGeo: async e=>(function(e, t) {
                let r = new i.PlaneGeometry(e,t);
                return r.rotateX(-Math.PI / 2),
                r
            }
            )(e.size[0], e.size[2]),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            doubleSide: !0
        },
        OBJECTIVE: {
            objectiveLink: !0,
            notTechnical: !0,
            notStyleable: !0,
            defaultSize: [50, 50, 50],
            scalable: !0,
            noTexture: !0,
            opacity: .2,
            lineCol: 13107455,
            tool: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        PARTICLES: {
            customDirection: !0,
            notTechnical: !0,
            defaultSize: [20, 20, 20],
            hasParticles: !0,
            editColor: !0,
            scalable: !0,
            noTexture: !0,
            opacity: .3,
            lineCol: 3080191,
            tool: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        BILLBOARD: {
            canInterface: !0,
            hasHealth: !0,
            defaultSize: [40, .01, 10],
            lineCol: 16776960,
            dontRound: !0,
            scalable: !0,
            canTerrain: !0,
            scaleWithSize: !0,
            hideBoundingBox: !1,
            genGeo: async e=>(function(e, t, r, n, s, a) {
                var o = new i.Geometry;
                return d(o, e, t, r, n / 2, a / 2),
                o
            }
            )(0, 0, 0, ...e.size),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            doubleSide: !0
        },
        SCORE_ZONE: {
            notStyleable: !0,
            customScore: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noTexture: !0,
            opacity: .3,
            lineCol: 16776960,
            tool: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        DEATH_ZONE: {
            notTechnical: !0,
            notStyleable: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noTexture: !0,
            opacity: .3,
            lineCol: 16711680,
            tool: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        SPAWN_POINT: {
            notTechnical: !0,
            notStyleable: !0,
            scalable: !1,
            alwaysSee: !0,
            tool: !0,
            scaleWithSize: !1,
            teamable: !0,
            noTexture: !0,
            opacity: 1e-5,
            stepSrc: "a",
            customDirection: !0,
            dontRound: !0,
            genGeo: async(e,t)=>(function(e, t) {
                h(e, "models/spawn_0.obj", "textures/spawn_0.png", 1, 16777215, -5.5, 0, -((e.direction || 0) + 1) * Math.PI / 2, "spwnMesh");
                let r = s.generateCube([1, 1, 1, 1, 1, 1], 7, 11, 7, {
                    scale: 1,
                    amb: t,
                    transparent: !0,
                    useScale: !0,
                    depthWrite: !1,
                    side: 2
                });
                return r = (new i.BufferGeometry).fromGeometry(r)
            }
            )(e, t),
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        },
        CHECK_POINT: {
            notStyleable: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noTexture: !0,
            opacity: .3,
            lineCol: 252613,
            tool: !0,
            customDirection: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        TELEPORTER: {
            notStyleable: !0,
            hasSignals: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noTexture: !0,
            opacity: .3,
            lineCol: 11665392,
            tool: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        },
        CAMERA_POSITION: {
            notTechnical: !0,
            notStyleable: !0,
            defaultSize: [2, 2, 2],
            scalable: !1,
            alwaysSee: !0,
            tool: !0,
            scaleWithSize: !1,
            hideBoundingBox: !0,
            editorGen: e=>(function(e, t, r) {
                let n = (new i.TextureLoader).load(t);
                n.magFilter = i.NearestFilter;
                let s = new i.SpriteMaterial({
                    map: n,
                    color: 16777215
                })
                  , a = new i.Sprite(s);
                r && a.scale.set(r, r, 1),
                e.add(a)
            }
            )(e, "img/crosshair.png", 5),
            stepSrc: "a",
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        },
        SPECTATE_CAM: {
            objectiveLink: !0,
            isCam: !0,
            notTechnical: !0,
            notStyleable: !0,
            defaultSize: [10, 10, 10],
            scalable: !1,
            tool: !0,
            scaleWithSize: !1,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        },
        FLAG: {
            notTechnical: !0,
            notStyleable: !0,
            defaultSize: [n.flagZoneS, n.flagZoneH, n.flagZoneS],
            scalable: !1,
            tool: !0,
            scaleWithSize: !1,
            lineCol: 13107455,
            teamable: !0,
            noDefault: !0,
            genGeo: async(e,t)=>(function(e, t) {
                h(e, "models/crystal_0.obj", "textures/crystal_0.png", n.flagScale, 16777215, n.flagOff / 2);
                var r = s.generateCube([1, 1, 0, 0, 1, 1], ...e.size, {
                    scale: 1,
                    amb: t,
                    useScale: !0,
                    transparent: !0,
                    depthWrite: !1,
                    side: 2
                });
                return r = (new i.BufferGeometry).fromGeometry(r)
            }
            )(e, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        },
        GATE: {
            canInterface: !0,
            canUndo: !0,
            interact: !0,
            customScore: !0,
            movingTexture: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            forceCollision: !0,
            editAmb: !0,
            scaleWithSize: !1,
            editColor: !0,
            editEmissive: !0,
            editOpac: !0,
            lineCol: 16711935,
            texturable: !0,
            tool2: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            complex: !0,
            hasBorder: !0
        },
        TRIGGER: {
            canInterface: !0,
            canTargetInterface: !0,
            hasHealth: !0,
            movingTexture: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            forceCollision: !0,
            editAmb: !0,
            scaleWithSize: !1,
            editColor: !0,
            editEmissive: !0,
            editOpac: !0,
            lineCol: 16711935,
            texturable: !0,
            tool2: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            complex: !0
        },
        SIGN: {
            notTechnical: !0,
            movingTexture: !0,
            hasText: !0,
            defaultSize: [40, .01, 10],
            forceCollision: !0,
            lineCol: 16776960,
            scalable: !0,
            scaleWithSize: !0,
            hideBoundingBox: !1,
            tool: !0,
            genGeo: async e=>(function(e, t, r, n, s, a, o) {
                var c = new i.Geometry;
                return d(c, 0, 0, 0, s / 2, o / 2),
                c
            }
            )(e, 0, 0, 0, ...e.size),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            doubleSide: !0
        },
        DEPOSIT_BOX: {
            canInterface: !0,
            movingTexture: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            forceCollision: !0,
            editAmb: !0,
            scaleWithSize: !1,
            editColor: !0,
            editEmissive: !0,
            editOpac: !0,
            lineCol: 16711935,
            texturable: !0,
            tool2: !0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            complex: !0,
            hasBorder: !0
        },
        LIGHT_CONE: {
            notTechnical: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noCollision: !0,
            scaleWithSize: !1,
            editOpac: !0,
            editColor: !0,
            lineCol: 16711935,
            tool2: !0,
            genGeo: async(e,t)=>(function(e, t, r) {
                var n = s.generateCone(e, t, r, {
                    scale: 1,
                    useScale: !0
                });
                return n = (new i.BufferGeometry).fromGeometry(n)
            }
            )(...e.size, t),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0,
            complex: !0,
            doubleSide: !0,
            blending: i.AdditiveBlending
        },
        PLACEHOLDER: {
            notStyleable: !0,
            defaultSize: [10, 10, 10],
            scalable: !0,
            noTexture: !0,
            noExport: !0,
            tool: !0,
            opacity: .1,
            lineCol: 0,
            genGeo: async(e,t)=>u(...e.size, t),
            stepSrc: "a"
        }
    },
    e.exports.texturePrefabs = {
        WALL: {
            src: "wall_0",
            filter: i.NearestFilter
        },
        DIRT: {
            src: "dirt_0",
            filter: i.NearestFilter
        },
        FLOOR: {
            src: "floor_0",
            filter: i.NearestFilter
        },
        GRID: {
            src: "grid_0",
            filter: i.NearestFilter
        },
        GREY: {
            src: "grey_0",
            filter: i.NearestFilter
        },
        DEFAULT: {
            src: "default",
            filter: i.NearestFilter
        },
        ROOF: {
            src: "roof_0",
            filter: i.NearestFilter
        },
        FLAG: {
            src: "flag_0",
            filter: i.NearestFilter
        },
        CHECK: {
            src: "check_0",
            filter: i.NearestFilter
        },
        GRASS: {
            src: "grass_1",
            filter: i.NearestFilter
        },
        LINES: {
            src: "lines_0",
            filter: i.NearestFilter
        },
        BRICK: {
            src: "brick_0",
            filter: i.NearestFilter
        },
        LINK: {
            src: "link_0",
            trans: !0,
            filter: i.NearestFilter
        }
    };
    let m = e=>({
        src: e,
        filter: i.NearestFilter
    });
    e.exports.loadTexturePrefab = function(t, r=null) {
        if (r.prefab.hasText)
            return (e=>{
                var t = new i.Texture(e);
                return t.wrapS = i.RepeatWrapping,
                t.wrapT = i.RepeatWrapping,
                t.repeat.set(1, 1),
                t.minFilter = i.NearestFilter,
                t.magFilter = i.NearestFilter,
                t.needsUpdate = !0,
                t
            }
            )(a.createCanvasText(r.size[0], r.size[2], r.text || "Hello World", r.fsize || 10, r.fcolor || "#000", r.bcolor || "#fff", !r.backVisible, r.tAlign || 0));
        let s = "BILLBOARD" == r.objType ? m("pubs/b_" + (r.poster || a.randInt(1, n.billboardCnt))) : e.exports.texturePrefabs[t];
        return s = "FLAG" == r.objType ? m("zone_r") : s,
        s = "LIGHT_CONE" == r.objType ? m("lightcone_0") : s,
        "default" == (s = "SPECTATE_CAM" == r.objType ? m("spectatecam_0") : s).src ? void 0 : c.load(a.assetsUrl("/textures/" + s.src + ".png"), e=>{
            e.wrapS = i.RepeatWrapping,
            e.wrapT = i.RepeatWrapping,
            e.repeat.set(1, 1),
            e.minFilter = s.filter,
            e.magFilter = s.filter,
            e.needsUpdate = !0
        }
        )
    }
}
, function(e, t, r) {
    t.encode = r(26).encode,
    t.decode = r(31).decode,
    t.Encoder = r(51).Encoder,
    t.Decoder = r(52).Decoder,
    t.createCodec = r(53).createCodec,
    t.codec = r(54).codec
}
, function(e, t, r) {
    (function(t) {
        function r(e) {
            return e && e.isBuffer && e
        }
        e.exports = r(void 0 !== t && t) || r(this.Buffer) || r("undefined" != typeof window && window.Buffer) || this.Buffer
    }
    ).call(this, r(28).Buffer)
}
, function(e, t, r) {
    "use strict";
    t.byteLength = function(e) {
        var t = l(e)
          , r = t[0]
          , i = t[1];
        return 3 * (r + i) / 4 - i
    }
    ,
    t.toByteArray = function(e) {
        for (var t, r = l(e), i = r[0], a = r[1], o = new s(function(e, t, r) {
            return 3 * (t + r) / 4 - r
        }(0, i, a)), c = 0, p = 0 < a ? i - 4 : i, h = 0; h < p; h += 4)
            t = n[e.charCodeAt(h)] << 18 | n[e.charCodeAt(h + 1)] << 12 | n[e.charCodeAt(h + 2)] << 6 | n[e.charCodeAt(h + 3)],
            o[c++] = 255 & t >> 16,
            o[c++] = 255 & t >> 8,
            o[c++] = 255 & t;
        return 2 === a && (t = n[e.charCodeAt(h)] << 2 | n[e.charCodeAt(h + 1)] >> 4,
        o[c++] = 255 & t),
        1 === a && (t = n[e.charCodeAt(h)] << 10 | n[e.charCodeAt(h + 1)] << 4 | n[e.charCodeAt(h + 2)] >> 2,
        o[c++] = 255 & t >> 8,
        o[c++] = 255 & t),
        o
    }
    ,
    t.fromByteArray = function(e) {
        for (var t, r = e.length, n = r % 3, s = [], a = 16383, o = 0, c = r - n; o < c; o += a)
            s.push(h(e, o, o + a > c ? c : o + a));
        return 1 === n ? (t = e[r - 1],
        s.push(i[t >> 2] + i[63 & t << 4] + "==")) : 2 === n && (t = (e[r - 2] << 8) + e[r - 1],
        s.push(i[t >> 10] + i[63 & t >> 4] + i[63 & t << 2] + "=")),
        s.join("")
    }
    ;
    for (var i = [], n = [], s = "undefined" == typeof Uint8Array ? Array : Uint8Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, c = a.length; o < c; ++o)
        i[o] = a[o],
        n[a.charCodeAt(o)] = o;
    function l(e) {
        var t = e.length;
        if (0 < t % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        return -1 === r && (r = t),
        [r, r === t ? 0 : 4 - r % 4]
    }
    function p(e) {
        return i[63 & e >> 18] + i[63 & e >> 12] + i[63 & e >> 6] + i[63 & e]
    }
    function h(e, t, r) {
        for (var i, n = [], s = t; s < r; s += 3)
            i = (16711680 & e[s] << 16) + (65280 & e[s + 1] << 8) + (255 & e[s + 2]),
            n.push(p(i));
        return n.join("")
    }
    n[45] = 62,
    n[95] = 63
}
, function(e, t, r) {
    var i = r(3);
    function n(e) {
        return Array(e)
    }
    (t = e.exports = n(0)).alloc = n,
    t.concat = i.concat,
    t.from = function(e) {
        if (!i.isBuffer(e) && i.isView(e))
            e = i.Uint8Array.from(e);
        else if (i.isArrayBuffer(e))
            e = new Uint8Array(e);
        else {
            if ("string" == typeof e)
                return i.from.call(t, e);
            if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number')
        }
        return Array.prototype.slice.call(e)
    }
}
, function(e, t, r) {
    var i = r(3)
      , n = i.global;
    function s(e) {
        return new n(e)
    }
    (t = e.exports = i.hasBuffer ? s(0) : []).alloc = i.hasBuffer && n.alloc || s,
    t.concat = i.concat,
    t.from = function(e) {
        if (!i.isBuffer(e) && i.isView(e))
            e = i.Uint8Array.from(e);
        else if (i.isArrayBuffer(e))
            e = new Uint8Array(e);
        else {
            if ("string" == typeof e)
                return i.from.call(t, e);
            if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number')
        }
        return n.from && 1 !== n.from.length ? n.from(e) : new n(e)
    }
}
, function(e, t, r) {
    var i = r(3);
    function n(e) {
        return new Uint8Array(e)
    }
    (t = e.exports = i.hasArrayBuffer ? n(0) : []).alloc = n,
    t.concat = i.concat,
    t.from = function(e) {
        if (i.isView(e)) {
            var r = e.byteOffset
              , n = e.byteLength;
            (e = e.buffer).byteLength !== n && (e.slice ? e = e.slice(r, r + n) : (e = new Uint8Array(e)).byteLength !== n && (e = Array.prototype.slice.call(e, r, r + n)))
        } else {
            if ("string" == typeof e)
                return i.from.call(t, e);
            if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number')
        }
        return new Uint8Array(e)
    }
}
, function(e, t) {
    t.copy = function(e, t, r, i) {
        var n;
        r || (r = 0),
        i || 0 === i || (i = this.length),
        t || (t = 0);
        var s = i - r;
        if (e === this && r < t && t < i)
            for (n = s - 1; 0 <= n; n--)
                e[n + t] = this[n + r];
        else
            for (n = 0; n < s; n++)
                e[n + t] = this[n + r];
        return s
    }
    ,
    t.toString = function(e, t, r) {
        var i = this
          , n = 0 | t;
        r || (r = i.length);
        for (var s = "", a = 0; n < r; )
            128 > (a = i[n++]) ? s += String.fromCharCode(a) : (192 == (224 & a) ? a = (31 & a) << 6 | 63 & i[n++] : 224 == (240 & a) ? a = (15 & a) << 12 | (63 & i[n++]) << 6 | 63 & i[n++] : 240 == (248 & a) && (a = (7 & a) << 18 | (63 & i[n++]) << 12 | (63 & i[n++]) << 6 | 63 & i[n++]),
            65536 <= a ? (a -= 65536,
            s += String.fromCharCode(55296 + (a >>> 10), 56320 + (1023 & a))) : s += String.fromCharCode(a));
        return s
    }
    ,
    t.write = function(e, t) {
        for (var r = this, i = t || (t |= 0), n = e.length, s = 0, a = 0; a < n; )
            128 > (s = e.charCodeAt(a++)) ? r[i++] = s : 2048 > s ? (r[i++] = 192 | s >>> 6,
            r[i++] = 128 | 63 & s) : 55296 > s || 57343 < s ? (r[i++] = 224 | s >>> 12,
            r[i++] = 128 | 63 & s >>> 6,
            r[i++] = 128 | 63 & s) : (s = 65536 + (s - 55296 << 10 | e.charCodeAt(a++) - 56320),
            r[i++] = 240 | s >>> 18,
            r[i++] = 128 | 63 & s >>> 12,
            r[i++] = 128 | 63 & s >>> 6,
            r[i++] = 128 | 63 & s);
        return i - t
    }
}
, function(e, t, r) {
    t.setExtPackers = function(e) {
        e.addExtPacker(14, Error, [h, c]),
        e.addExtPacker(1, EvalError, [h, c]),
        e.addExtPacker(2, RangeError, [h, c]),
        e.addExtPacker(3, ReferenceError, [h, c]),
        e.addExtPacker(4, SyntaxError, [h, c]),
        e.addExtPacker(5, TypeError, [h, c]),
        e.addExtPacker(6, URIError, [h, c]),
        e.addExtPacker(10, RegExp, [p, c]),
        e.addExtPacker(11, Boolean, [l, c]),
        e.addExtPacker(12, String, [l, c]),
        e.addExtPacker(13, Date, [Number, c]),
        e.addExtPacker(15, Number, [l, c]),
        "undefined" != typeof Uint8Array && (e.addExtPacker(17, Int8Array, a),
        e.addExtPacker(18, Uint8Array, a),
        e.addExtPacker(19, Int16Array, a),
        e.addExtPacker(20, Uint16Array, a),
        e.addExtPacker(21, Int32Array, a),
        e.addExtPacker(22, Uint32Array, a),
        e.addExtPacker(23, Float32Array, a),
        "undefined" != typeof Float64Array && e.addExtPacker(24, Float64Array, a),
        "undefined" != typeof Uint8ClampedArray && e.addExtPacker(25, Uint8ClampedArray, a),
        e.addExtPacker(26, ArrayBuffer, a),
        e.addExtPacker(29, DataView, a)),
        n.hasBuffer && e.addExtPacker(27, s, n.from)
    }
    ;
    var i, n = r(3), s = n.global, a = n.Uint8Array.from, o = {
        name: 1,
        message: 1,
        stack: 1,
        columnNumber: 1,
        fileName: 1,
        lineNumber: 1
    };
    function c(e) {
        return i || (i = r(26).encode),
        i(e)
    }
    function l(e) {
        return e.valueOf()
    }
    function p(e) {
        (e = RegExp.prototype.toString.call(e).split("/")).shift();
        var t = [e.pop()];
        return t.unshift(e.join("/")),
        t
    }
    function h(e) {
        var t = {};
        for (var r in o)
            t[r] = e[r];
        return t
    }
}
, function(e, t, r) {
    var i = r(11)
      , n = r(19)
      , s = n.Uint64BE
      , a = n.Int64BE
      , o = r(3)
      , c = r(18)
      , l = r(48)
      , p = r(29).uint8
      , h = r(16).ExtBuffer
      , u = "undefined" != typeof Uint8Array
      , d = "undefined" != typeof Map
      , f = [];
    f[1] = 212,
    f[2] = 213,
    f[4] = 214,
    f[8] = 215,
    f[16] = 216,
    t.getWriteType = function(e) {
        function t(e, t) {
            if (null === t)
                return r(e, t);
            if (b(t))
                return w(e, t);
            if (i(t))
                return function(e, t) {
                    var r = t.length;
                    g[16 > r ? 144 + r : 65535 >= r ? 220 : 221](e, r);
                    for (var i = e.codec.encode, n = 0; n < r; n++)
                        i(e, t[n])
                }(e, t);
            if (s.isUint64BE(t))
                return function(e, t) {
                    g[207](e, t.toArray())
                }(e, t);
            if (a.isInt64BE(t))
                return function(e, t) {
                    g[211](e, t.toArray())
                }(e, t);
            var n = e.codec.getExtPacker(t);
            return n && (t = n(t)),
            t instanceof h ? function(e, t) {
                var r = t.buffer
                  , i = r.length
                  , n = f[i] || (255 > i ? 199 : 65535 >= i ? 200 : 201);
                g[n](e, i),
                p[t.type](e),
                e.send(r)
            }(e, t) : void x(e, t)
        }
        function r(e, t) {
            g[192](e, t)
        }
        function n(e, t) {
            var r = t.length
              , i = 255 > r ? 196 : 65535 >= r ? 197 : 198;
            g[i](e, r),
            e.send(t)
        }
        function m(e, t) {
            var r = Object.keys(t)
              , i = r.length
              , n = 16 > i ? 128 + i : 65535 >= i ? 222 : 223;
            g[n](e, i);
            var s = e.codec.encode;
            r.forEach(function(r) {
                s(e, r),
                s(e, t[r])
            })
        }
        var g = l.getWriteToken(e)
          , v = e && e.useraw
          , y = u && e && e.binarraybuffer
          , b = y ? o.isArrayBuffer : o.isBuffer
          , w = y ? function(e, t) {
            n(e, new Uint8Array(t))
        }
        : n
          , x = d && e && e.usemap ? function(e, t) {
            if (!(t instanceof Map))
                return m(e, t);
            var r = t.size
              , i = 16 > r ? 128 + r : 65535 >= r ? 222 : 223;
            g[i](e, r);
            var n = e.codec.encode;
            t.forEach(function(t, r) {
                n(e, r),
                n(e, t)
            })
        }
        : m;
        return {
            boolean: function(e, t) {
                var r = t ? 195 : 194;
                g[r](e, t)
            },
            function: r,
            number: function(e, t) {
                var r = 0 | t;
                t === r ? g[-32 <= r && 127 >= r ? 255 & r : 0 <= r ? 255 >= r ? 204 : 65535 >= r ? 205 : 206 : -128 <= r ? 208 : -32768 <= r ? 209 : 210](e, r) : g[203](e, t)
            },
            object: v ? function(e, r) {
                return b(r) ? function(e, t) {
                    var r = t.length;
                    g[32 > r ? 160 + r : 65535 >= r ? 218 : 219](e, r),
                    e.send(t)
                }(e, r) : void t(e, r)
            }
            : t,
            string: function(e) {
                return function(t, r) {
                    var i = r.length
                      , n = 5 + 3 * i;
                    t.offset = t.reserve(n);
                    var s = t.buffer
                      , a = e(i)
                      , o = t.offset + a;
                    i = c.write.call(s, r, o);
                    var l = e(i);
                    if (a !== l) {
                        var p = o + i;
                        c.copy.call(s, s, o + l - a, o, p)
                    }
                    var h = 1 === l ? 160 + i : 3 >= l ? 215 + l : 219;
                    g[h](t, i),
                    t.offset += i
                }
            }(v ? function(e) {
                return 32 > e ? 1 : 65535 >= e ? 3 : 5
            }
            : function(e) {
                return 32 > e ? 1 : 255 >= e ? 2 : 65535 >= e ? 3 : 5
            }
            ),
            symbol: r,
            undefined: r
        }
    }
}
, function(e, t, r) {
    var i = r(17)
      , n = r(19)
      , s = n.Uint64BE
      , a = n.Int64BE
      , o = r(29).uint8
      , c = r(3)
      , l = c.global
      , p = c.hasBuffer && "TYPED_ARRAY_SUPPORT"in l && !l.TYPED_ARRAY_SUPPORT
      , h = c.hasBuffer && l.prototype || {};
    function u() {
        var e = o.slice();
        return e[196] = d(196),
        e[197] = f(197),
        e[198] = m(198),
        e[199] = d(199),
        e[200] = f(200),
        e[201] = m(201),
        e[202] = g(202, 4, h.writeFloatBE || b, !0),
        e[203] = g(203, 8, h.writeDoubleBE || w, !0),
        e[204] = d(204),
        e[205] = f(205),
        e[206] = m(206),
        e[207] = g(207, 8, v),
        e[208] = d(208),
        e[209] = f(209),
        e[210] = m(210),
        e[211] = g(211, 8, y),
        e[217] = d(217),
        e[218] = f(218),
        e[219] = m(219),
        e[220] = f(220),
        e[221] = m(221),
        e[222] = f(222),
        e[223] = m(223),
        e
    }
    function d(e) {
        return function(t, r) {
            var i = t.reserve(2)
              , n = t.buffer;
            n[i++] = e,
            n[i] = r
        }
    }
    function f(e) {
        return function(t, r) {
            var i = t.reserve(3)
              , n = t.buffer;
            n[i++] = e,
            n[i++] = r >>> 8,
            n[i] = r
        }
    }
    function m(e) {
        return function(t, r) {
            var i = t.reserve(5)
              , n = t.buffer;
            n[i++] = e,
            n[i++] = r >>> 24,
            n[i++] = r >>> 16,
            n[i++] = r >>> 8,
            n[i] = r
        }
    }
    function g(e, t, r, i) {
        return function(n, s) {
            var a = n.reserve(t + 1);
            n.buffer[a++] = e,
            r.call(n.buffer, s, a, i)
        }
    }
    function v(e, t) {
        new s(this,t,e)
    }
    function y(e, t) {
        new a(this,t,e)
    }
    function b(e, t) {
        i.write(this, e, t, !1, 23, 4)
    }
    function w(e, t) {
        i.write(this, e, t, !1, 52, 8)
    }
    t.getWriteToken = function(e) {
        return e && e.uint8array ? function() {
            var e = u();
            return e[202] = g(202, 4, b),
            e[203] = g(203, 8, w),
            e
        }() : p || c.hasBuffer && e && e.safe ? function() {
            var e = o.slice();
            return e[196] = g(196, 1, l.prototype.writeUInt8),
            e[197] = g(197, 2, l.prototype.writeUInt16BE),
            e[198] = g(198, 4, l.prototype.writeUInt32BE),
            e[199] = g(199, 1, l.prototype.writeUInt8),
            e[200] = g(200, 2, l.prototype.writeUInt16BE),
            e[201] = g(201, 4, l.prototype.writeUInt32BE),
            e[202] = g(202, 4, l.prototype.writeFloatBE),
            e[203] = g(203, 8, l.prototype.writeDoubleBE),
            e[204] = g(204, 1, l.prototype.writeUInt8),
            e[205] = g(205, 2, l.prototype.writeUInt16BE),
            e[206] = g(206, 4, l.prototype.writeUInt32BE),
            e[207] = g(207, 8, v),
            e[208] = g(208, 1, l.prototype.writeInt8),
            e[209] = g(209, 2, l.prototype.writeInt16BE),
            e[210] = g(210, 4, l.prototype.writeInt32BE),
            e[211] = g(211, 8, y),
            e[217] = g(217, 1, l.prototype.writeUInt8),
            e[218] = g(218, 2, l.prototype.writeUInt16BE),
            e[219] = g(219, 4, l.prototype.writeUInt32BE),
            e[220] = g(220, 2, l.prototype.writeUInt16BE),
            e[221] = g(221, 4, l.prototype.writeUInt32BE),
            e[222] = g(222, 2, l.prototype.writeUInt16BE),
            e[223] = g(223, 4, l.prototype.writeUInt32BE),
            e
        }() : u()
    }
}
, function(e, t, r) {
    t.setExtUnpackers = function(e) {
        e.addExtUnpacker(14, [o, l(Error)]),
        e.addExtUnpacker(1, [o, l(EvalError)]),
        e.addExtUnpacker(2, [o, l(RangeError)]),
        e.addExtUnpacker(3, [o, l(ReferenceError)]),
        e.addExtUnpacker(4, [o, l(SyntaxError)]),
        e.addExtUnpacker(5, [o, l(TypeError)]),
        e.addExtUnpacker(6, [o, l(URIError)]),
        e.addExtUnpacker(10, [o, c]),
        e.addExtUnpacker(11, [o, p(Boolean)]),
        e.addExtUnpacker(12, [o, p(String)]),
        e.addExtUnpacker(13, [o, p(Date)]),
        e.addExtUnpacker(15, [o, p(Number)]),
        "undefined" != typeof Uint8Array && (e.addExtUnpacker(17, p(Int8Array)),
        e.addExtUnpacker(18, p(Uint8Array)),
        e.addExtUnpacker(19, [h, p(Int16Array)]),
        e.addExtUnpacker(20, [h, p(Uint16Array)]),
        e.addExtUnpacker(21, [h, p(Int32Array)]),
        e.addExtUnpacker(22, [h, p(Uint32Array)]),
        e.addExtUnpacker(23, [h, p(Float32Array)]),
        "undefined" != typeof Float64Array && e.addExtUnpacker(24, [h, p(Float64Array)]),
        "undefined" != typeof Uint8ClampedArray && e.addExtUnpacker(25, p(Uint8ClampedArray)),
        e.addExtUnpacker(26, h),
        e.addExtUnpacker(29, [h, p(DataView)])),
        n.hasBuffer && e.addExtUnpacker(27, p(s))
    }
    ;
    var i, n = r(3), s = n.global, a = {
        name: 1,
        message: 1,
        stack: 1,
        columnNumber: 1,
        fileName: 1,
        lineNumber: 1
    };
    function o(e) {
        return i || (i = r(31).decode),
        i(e)
    }
    function c(e) {
        return RegExp.apply(null, e)
    }
    function l(e) {
        return function(t) {
            var r = new e;
            for (var i in a)
                r[i] = t[i];
            return r
        }
    }
    function p(e) {
        return function(t) {
            return new e(t)
        }
    }
    function h(e) {
        return new Uint8Array(e).buffer
    }
}
, function(e, t, r) {
    var i = r(33);
    function n(e) {
        var t, r = Array(256);
        for (t = 0; 127 >= t; t++)
            r[t] = s(t);
        for (t = 128; 143 >= t; t++)
            r[t] = o(t - 128, e.map);
        for (t = 144; 159 >= t; t++)
            r[t] = o(t - 144, e.array);
        for (t = 160; 191 >= t; t++)
            r[t] = o(t - 160, e.str);
        for (r[192] = s(null),
        r[193] = null,
        r[194] = s(!1),
        r[195] = s(!0),
        r[196] = a(e.uint8, e.bin),
        r[197] = a(e.uint16, e.bin),
        r[198] = a(e.uint32, e.bin),
        r[199] = a(e.uint8, e.ext),
        r[200] = a(e.uint16, e.ext),
        r[201] = a(e.uint32, e.ext),
        r[202] = e.float32,
        r[203] = e.float64,
        r[204] = e.uint8,
        r[205] = e.uint16,
        r[206] = e.uint32,
        r[207] = e.uint64,
        r[208] = e.int8,
        r[209] = e.int16,
        r[210] = e.int32,
        r[211] = e.int64,
        r[212] = o(1, e.ext),
        r[213] = o(2, e.ext),
        r[214] = o(4, e.ext),
        r[215] = o(8, e.ext),
        r[216] = o(16, e.ext),
        r[217] = a(e.uint8, e.str),
        r[218] = a(e.uint16, e.str),
        r[219] = a(e.uint32, e.str),
        r[220] = a(e.uint16, e.array),
        r[221] = a(e.uint32, e.array),
        r[222] = a(e.uint16, e.map),
        r[223] = a(e.uint32, e.map),
        t = 224; 255 >= t; t++)
            r[t] = s(t - 256);
        return r
    }
    function s(e) {
        return function() {
            return e
        }
    }
    function a(e, t) {
        return function(r) {
            var i = e(r);
            return t(r, i)
        }
    }
    function o(e, t) {
        return function(r) {
            return t(r, e)
        }
    }
    t.getReadToken = function(e) {
        var t = i.getReadFormat(e);
        return e && e.useraw ? function(e) {
            var t, r = n(e).slice();
            for (r[217] = r[196],
            r[218] = r[197],
            r[219] = r[198],
            t = 160; 191 >= t; t++)
                r[t] = o(t - 160, e.bin);
            return r
        }(t) : n(t)
    }
}
, function(e, t, r) {
    t.Encoder = s;
    var i = r(34)
      , n = r(27).EncodeBuffer;
    function s(e) {
        return this instanceof s ? void n.call(this, e) : new s(e)
    }
    s.prototype = new n,
    i.mixin(s.prototype),
    s.prototype.encode = function(e) {
        this.write(e),
        this.emit("data", this.read())
    }
    ,
    s.prototype.end = function(e) {
        arguments.length && this.encode(e),
        this.flush(),
        this.emit("end")
    }
}
, function(e, t, r) {
    t.Decoder = s;
    var i = r(34)
      , n = r(32).DecodeBuffer;
    function s(e) {
        return this instanceof s ? void n.call(this, e) : new s(e)
    }
    s.prototype = new n,
    i.mixin(s.prototype),
    s.prototype.decode = function(e) {
        arguments.length && this.write(e),
        this.flush()
    }
    ,
    s.prototype.push = function(e) {
        this.emit("data", e)
    }
    ,
    s.prototype.end = function(e) {
        this.decode(e),
        this.emit("end")
    }
}
, function(e, t, r) {
    r(20),
    r(15),
    t.createCodec = r(12).createCodec
}
, function(e, t, r) {
    r(20),
    r(15),
    t.codec = {
        preset: r(12).preset
    }
}
, function(e, t, r) {
    const i = r(7)
      , n = r(59)
      , s = r(60)
      , a = r(23)
      , o = r(37);
    var c = [{
        id: "ffa",
        name: "Free for All",
        alias: "ffa"
    }, {
        id: "tdm",
        name: "Team Deathmatch",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists", "reward"],
        alias: "tdm",
        teams: !0
    }, {
        id: "point",
        name: "Hardpoint",
        alias: "point",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists", "reward"],
        objective: !0,
        teams: !0,
        gameStart: function(e) {
            e.activeObjective = -1,
            e.nextObjective(null, !0)
        }
    }, {
        id: "ctf",
        name: "Capture the Flag",
        alias: "ctf",
        endStats: ["sid", "name", "score", "kills", "deaths", "caps", "reward"],
        onKill: function(e, t, r) {
            e.dropFlag(r.flag)
        },
        flags: !0,
        teams: !0,
        noScoreC: !0
    }, {
        id: "bhop",
        name: "Parkour",
        endStats: ["sid", "name", "score", "deaths"],
        alias: "bhop",
        noKick: !0,
        friendly: !0
    }, {
        id: "hide",
        name: "Hide & Seek",
        alias: "hide",
        endStats: ["sid", "name", "score", "found", "reward"],
        winCondition: function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "hide" == e.players.list[r].team && t++;
            return 0 < t ? "hide" : "seek"
        },
        condition: [function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "hide" == e.players.list[r].team && t++;
            return 0 < t
        }
        ],
        minPlayers: 2,
        waitTimers: [{
            time: 1e4,
            msg: "picking seeker in ",
            trigger: function(e) {
                e.pickSeeker()
            }
        }, {
            time: 45e3,
            msg: "releasing seeker in ",
            trigger: function(e) {
                e.releaseSeeker()
            }
        }],
        spdMlt: {
            hide: .8
        },
        killConv: !0,
        noKick: !0,
        showTeam: !0,
        startTeam: "hide",
        convTeam: "seek",
        convWord: "found",
        noWeap: !0,
        friendly: !0,
        hideNames: !0
    }, {
        id: "infect",
        name: "Infected",
        alias: "infect",
        endStats: ["sid", "name", "score", "kills", "infected", "reward"],
        winCondition: function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "surv" == e.players.list[r].team && t++;
            return 0 < t ? "surv" : "inf"
        },
        condition: [function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "surv" == e.players.list[r].team && t++;
            return 0 < t
        }
        ],
        minPlayers: 2,
        waitTimers: [{
            time: 2e4,
            msg: "infection in ",
            trigger: function(e) {
                e.infectRandom()
            }
        }],
        teamClass: {
            inf: 9
        },
        spdMlt: {
            inf: 1.15
        },
        killConv: !0,
        noKick: !0,
        startTeam: "surv",
        convWord: "infected",
        convTeam: "inf"
    }, {
        id: "race",
        name: "Race",
        alias: "race",
        endStats: ["sid", "name", "score", "time"],
        gameTime: 0,
        showMS: !0,
        timed: !0,
        endSort: function(e, t) {
            return e.score === t.score && e.gameTimer && t.gameTimer ? e.gameTimer - t.gameTimer : t.score - e.score
        },
        gameStart: function(e) {
            e.lockMove(!0),
            e.targetScore = 0;
            for (var t = 0; t < e.map.manager.objects.length; ++t)
                e.map.manager.objects[t].score && (e.targetScore += e.map.manager.objects[t].scoreP)
        },
        condition: [function(e) {
            for (var t = 0; t < e.players.list.length; ++t)
                e.players.list[t].score >= e.targetScore && !e.players.list[t].timer && (e.players.list[t].timer = e.lastTimer,
                e.players.list[t].gameTimer = e.gameTimer,
                e.waitTimers || (e.waitTimers = [{
                    time: 1e4,
                    contTime: !0,
                    msg: "race ends in ",
                    trigger: function(e) {
                        e.gameTimer = "skip"
                    }
                }]));
            return !0
        }
        ],
        waitTimers: [{
            time: 15e3,
            msg: "race starting in ",
            trigger: function(e) {
                e.lockMove(!1)
            }
        }],
        noWeap: !0,
        friendly: !0
    }, {
        id: "lms",
        name: "Last Man Standing",
        alias: "lms",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists"],
        noRegen: !0,
        noKick: !0,
        teams: !0,
        lives: 1,
        winCondition: function(e) {
            for (var t = 0, r = 0, i = 0; i < e.players.list.length; ++i)
                if (0 < e.players.list[i].lives) {
                    var n = e.players.list[i].lives;
                    1 == e.players.list[i].team ? t += n : r += n
                }
            return t > r ? 1 : 2
        },
        gameTime: 3e5
    }, {
        id: "simon",
        name: "Simon Says",
        alias: "simon",
        endStats: ["sid", "name", "score", "reward"],
        condition: [function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "foll" == e.players.list[r].team && t++;
            return 0 < t
        }
        ],
        minPlayers: 3,
        waitTimers: [{
            time: 1e4,
            msg: "starts in ",
            trigger: function(e) {
                e.pickSimon()
            }
        }],
        noKick: !0,
        teamSee: ["simon", "foll"],
        startTeam: "foll"
    }, {
        id: "gun",
        name: "Gun Game",
        alias: "gun",
        endStats: ["sid", "name", "weapon", "kills", "melees", "setbacks", "reward"],
        leaderStat: "weaponTier",
        winCondition: function(e) {
            for (var t = 0; t < e.players.list.length; ++t)
                if (e.players.list[t].weaponTier >= e.mode.weaponOrder.length)
                    return e.players.list[t];
            return null
        },
        condition: [function(e) {
            for (var t = 0; t < e.players.list.length; ++t)
                if (e.players.list[t].weaponTier >= e.mode.weaponOrder.length)
                    return !1;
            return !0
        }
        ],
        onKill: function(e, t, r, i, n) {
            i && i != r ? e.weapons[null == n.weaponId ? i.loadout[i.weaponIndex] : n.weaponId].melee ? e.decreaseWeapon(r) : e.increaseWeapon(i, n) : e.decreaseWeapon(r),
            t && e.players.syncLeaders()
        },
        startingLoadout: [2],
        keepLoadout: !0,
        rewardMlt: 50,
        noReward: !0,
        noAssists: !0,
        noStreaks: !0,
        minPlayers: 2,
        noWeap: !0,
        weaponOrder: [2, 10, 4, 11, 5, 3, 9, 1, 14, 6, 0, 7, 8, 13]
    }, {
        id: "prop",
        name: "Prop Hunt",
        alias: "prop",
        genID: "p",
        endStats: ["sid", "name", "score", "kills"],
        noRegen: !0,
        noKick: !0,
        teams: !0,
        lives: 1,
        winCondition: function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "prop" == e.players.list[r].team && t++;
            return 0 < t ? "prop" : "seek"
        },
        condition: [function(e) {
            for (var t = 0, r = 0, i = 0; i < e.players.list.length; ++i)
                0 < e.players.list[i].lives && e.players.list[i].active && ("prop" == e.players.list[i].team ? t++ : r++);
            return 1 <= t && 1 <= r
        }
        ],
        minPlayers: 2,
        waitTimers: [{
            time: 1e4,
            msg: "locking seekers in ",
            trigger: function(e) {
                e.lockSeekers()
            }
        }, {
            time: 3e4,
            msg: "releasing seekers in ",
            noJoin: !0,
            trigger: function(e) {
                e.releaseSeeker()
            }
        }],
        teamNs: ["seek", "prop"],
        showTeam: !0,
        hideNames: !0
    }, {
        id: "boss",
        name: "Boss Hunt",
        alias: "boss",
        winCondition: function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "boss" == e.players.list[r].team && t++;
            return 0 < t ? "boss" : "heros"
        },
        condition: [function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "boss" == e.players.list[r].team && t++;
            return 0 < t
        }
        ],
        waitTimers: [{
            time: 15e3,
            msg: "picking boss in ",
            trigger: function(e) {
                e.pickBoss()
            }
        }],
        noReward: !0,
        minPlayers: 2,
        startTeam: "heros"
    }, {
        id: "ranked",
        name: "Ranked",
        alias: "ranked",
        noReward: !0,
        preventCustomGames: !0,
        endStats: ["sid", "name", "score", "kills", "deaths", "MMR"],
        isRanked: !0,
        noKick: !0,
        needAll: !0,
        infEndTimer: !0,
        objective: !0,
        teams: !0,
        waitTimers: [{
            time: 1e4,
            msg: "starts in ",
            trigger: function(e) {
                e.lockMove(!1)
            }
        }],
        gameStart: function(e) {
            e.lockMove(!0),
            e.activeObjective = -1,
            e.nextObjective(null, !0)
        }
    }, {
        id: "ranked",
        name: "Ranked",
        alias: "ranked",
        noReward: !0,
        preventCustomGames: !0,
        endStats: ["sid", "name", "score", "kills", "deaths", "MMR"],
        isRanked: !0,
        noKick: !0,
        needAll: !0,
        infEndTimer: !0,
        noRegen: !0,
        killSort: !0,
        forceSpawn: 15,
        winCondition: function(e) {
            for (var t = 0, r = null, i = 0; i < e.players.list.length; ++i)
                (null == r || e.players.list[i].kills > t) && (t = e.players.list[i].kills,
                r = e.players.list[i]);
            return 0 == t ? null : r
        },
        condition: [function(e) {
            for (var t = 0; t < e.players.list.length; ++t)
                if (10 <= e.players.list[t].kills)
                    return !1;
            return !0
        }
        ],
        waitTimers: [{
            time: 1e4,
            msg: "starts in ",
            trigger: function(e) {
                e.lockMove(!1)
            }
        }],
        gameStart: function(e) {
            e.lockMove(!0)
        }
    }, {
        id: "stalk",
        name: "Stalker",
        alias: "stalk",
        endStats: ["sid", "name", "score", "reward"],
        genID: "st",
        ambInd: 5,
        minPlayers: 2,
        fogD: 250,
        fogC: 1842204,
        skyCol: 1842204,
        lightCol: 855309,
        ambCol: 1513239,
        lives: 1,
        condition: [function(e) {
            for (var t = 0, r = 0, i = 0; i < e.players.list.length; ++i)
                0 < e.players.list[i].lives && ("liv" == e.players.list[i].team ? t++ : "stalk" == e.players.list[i].team && r++);
            return 1 <= t && 1 <= r
        }
        ],
        winCondition: function(e) {
            for (var t = 0, r = 0; r < e.players.list.length; ++r)
                e.players.list[r].active && "stalk" == e.players.list[r].team && t++;
            return 0 < t ? "stalk" : "liv"
        },
        waitTimers: [{
            time: 15e3,
            msg: "picking stalker in ",
            trigger: function(e) {
                e.pickStalker()
            }
        }],
        onMelee: function(e, t, r) {
            var i = t && r && "stalk" == t.team;
            return i && (e.triggerImgSound("scare_0", "scare_0", r),
            e.players.changeHealth(t, null, -40)),
            i
        },
        hideNames: !0,
        noReward: !0,
        noKick: !0,
        startTeam: "liv",
        spdMlt: {
            liv: .65
        }
    }]
      , l = [0, 1, 2, 3];
    e.exports.modes = c;
    for (var p = [{
        name: "Burg",
        ambInd: 1,
        modURL: "",
        terrainSeed: "",
        terrainWidth: 2048,
        terrainHeight: 2048,
        terrainMntMlt: 1,
        terrainMntCol: "#a0a0a0",
        terrainGrsCol: "#4a6904",
        terrainDrtCol: "#8c6835",
        skyDome: !1,
        skyDomeCol0: "#ffffff",
        skyDomeCol1: "#7196a2",
        skyDomeCol2: "#184452",
        zone: !1,
        zoneSize: 500,
        zoneSpeed: 1,
        zoneCol0: "#c542d9",
        zoneCol1: "#c542d9",
        zoneCol2: "#c542d9",
        sizeMlt: 2,
        shadowR: 1024,
        ambient: 8220268,
        light: 16771304,
        sky: 14141126,
        fog: 13812161,
        fogD: 918.7540927106669,
        dthY: -100,
        camPos: [11, 33, -217],
        spawns: [[-80, 18, 35, 0], [177, 0, -188, 0], [215, 10, -504, 0, 1], [-169, 2, -514, 0, 2], [-328, 0, -255, 0], [-154, 0, -134, 0, 1], [-125, -28, -341, 0], [32, -28, -509, 0, 1], [331, 0, -227, 0, 2], [102, 0, -365, 0]],
        ambO: .7,
        ambS: 5,
        modes: [0, 1],
        shadScale: 170,
        objects: [{
            p: [-96, 16, 41],
            s: [288, 2, 62],
            t: 1
        }]
    }], h = 0; h < p.length; ++h)
        for (var u = 0; u < p[h].objects.length; ++u)
            p[h].objects[u].i = i.prefabIDS[p[h].objects[u].i || p[h].objects[u].id || 0],
            p[h].objects[u].t = i.textureIDS[p[h].objects[u].t || ("LADDER" == p[h].objects[u].i ? 2 : 0)];
    e.exports.maps = p,
    e.exports.manager = function(e, t, i, h) {
        var u, d;
        this.manager = new (r(68).manager)(e,i,h),
        this.maps = p,
        this.modes = c,
        this.rotationModes = l,
        this.rotationMaps = [0, 1, 2, 3, 4, 6],
        this.spawns = [],
        this.lastGen = null,
        this.terrain = null,
        this.zone = null,
        this.deathY = h.deathY,
        this.mapHeight = 0,
        this.setMaps = function(e) {
            this.maps = e || p
        }
        ,
        this.getRandomMap = function() {
            return i.randInt(0, this.maps.length - 1)
        }
        ;
        var f = "";
        this.generate = function(r, c, l) {
            var p = this.maps[r];
            p.game = p.game || {},
            this.config = {};
            for (var m, g = 0; g < h.gameConfig.length; ++g)
                if ((m = h.gameConfig[g]).bool)
                    this.config[m.varN] = null == p.game[m.varN] ? m.def : !!p.game[m.varN];
                else if (m.input) {
                    var v = p.game[m.varN];
                    i.isString(v) || (v = m.def),
                    this.config[m.varN] = i.sanitizeStr(v),
                    16 < v.length && (v = v.substring(0, 16))
                } else {
                    v = p.game[m.varN];
                    i.isNumber(v) || (v = m.def),
                    this.config[m.varN] = i.limitMM(v, m.min, m.max)
                }
            if (null != p.dthY && i.isNumber(p.dthY) && (this.deathY = p.dthY),
            e)
                try {
                    mapInfo.innerHTML = c.alias + "_" + p.name,
                    gameMessage.innerHTML = specGMessage.innerHTML = "",
                    curGameInfo.innerHTML = c.name + "<div style='color:rgba(255,255,255,0.6)'>on " + p.name + "</div>" + (p.creator ? "<div style='color:#fff'><span style='color:rgba(255,255,255,0.6)'>by</span> " + p.creator + "</div>" : ""),
                    specGameInfo.innerHTML = c.name
                } catch (e) {}
            e && f != p.modURL && ((f = p.modURL) && "" != f && loadModPack(f, !0));
            var y = r + (null == c.genID ? "" : "_" + c.genID);
            if (l || this.lastGen !== y) {
                this.lastGen = y,
                this.manager.removeAll(),
                e && e.init(p, c),
                t && (t.reset(),
                e.scene.add(t.ExplosionManager)),
                p.terrainSeed && p.terrainWidth && p.terrainHeight ? (this.terrain = n.fromConfig(p),
                this.terrain.rotation.x = -Math.PI / 2,
                e && e.scene.add(this.terrain)) : this.terrain = null,
                p.zone && p.zoneSize && p.zoneSpeed ? (this.zone = s.fromConfig(p, e),
                e && e.scene.add(this.zone)) : this.zone = null;
                var b = 0
                  , w = 0
                  , x = 0
                  , M = 0
                  , _ = 0;
                for (g = 0; g < p.objects.length; ++g) {
                    var S = (u = p.objects[g]).p[0]
                      , T = u.p[1]
                      , E = u.p[2]
                      , A = u.t.toLowerCase() + "_" + ("GRASS" == u.t ? 1 : 0);
                    if (u.l || u.col || "CUBE" != u.i || (S - u.s[0] < b && (b = S - u.s[0]),
                    S + u.s[0] > w && (w = S + u.s[0]),
                    E - u.s[2] < x && (x = E - u.s[2]),
                    E + u.s[2] > M && (M = E + u.s[2]),
                    T + u.s[1] > M && (_ = T + u.s[1])),
                    "CUBE" == u.i) {
                        for (var P = 1, O = 0; O < p.objects.length; ++O)
                            if ("CUBE" == (d = p.objects[O]).i && u != d && T <= d.p[1] + d.s[1] && T >= d.p[1] && S + u.s[0] / 2 < d.p[0] + d.s[0] / 2 && S - u.s[0] / 2 > d.p[0] - d.s[0] / 2 && E + u.s[2] / 2 < d.p[2] + d.s[2] / 2 && E - u.s[2] / 2 > d.p[2] - d.s[2] / 2) {
                                P = 0;
                                break
                            }
                        this.manager.addBlock(S, T, E, u.s[0], u.s[2], u.s[1], [1, 1, 1, P, 1, 1], {
                            src: A,
                            colr: u.c,
                            emissive: u.e || null,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            transparent: 1 != u.o && null != u.o,
                            penetrable: u.pe,
                            health: u.h || u.hp,
                            respawnT: 1e3 * parseFloat(u.rt),
                            respawnR: null != u.rr,
                            amb: p.nAmb || null != u.ab ? null : h.ambientVal,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0,
                            noCol: u.l || u.col,
                            isBorder: u.bo,
                            noVis: u.v,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td,
                            noAmb: null != u.ab,
                            interface: parseInt(u.in) || null
                        })
                    } else if ("GATE" == u.i)
                        this.manager.addGate(S, T, E, u.s[0], u.s[2], u.s[1], {
                            src: A,
                            colr: u.c,
                            emissive: u.e || null,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            transparent: 1 != u.o && null != u.o,
                            penetrable: u.pe,
                            amb: p.nAmb || null != u.ab ? null : h.ambientVal,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0,
                            isBorder: u.bo,
                            noVis: u.v,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td,
                            noAmb: null != u.ab,
                            scoreP: parseInt(u.sp) || 0,
                            noMsg: null != u.nm,
                            method: parseInt(u.md) || 0,
                            closeable: null != u.cl,
                            startClosed: null != u.stc,
                            interface: parseInt(u.in) || null
                        });
                    else if ("TRIGGER" == u.i)
                        this.manager.addTrigger(S, T, E, u.s[0], u.s[2], u.s[1], {
                            src: A,
                            colr: u.c,
                            emissive: u.e || null,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            transparent: 1 != u.o && null != u.o,
                            health: u.h || u.hp,
                            respawnT: 1e3 * parseFloat(u.rt),
                            respawnR: null != u.rr,
                            amb: p.nAmb || null != u.ab ? null : h.ambientVal,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0,
                            noVis: u.v,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td,
                            noAmb: null != u.ab,
                            constant: parseInt(u.tc) || 0,
                            event: parseInt(u.te) || 0,
                            eventN: o.events[parseInt(u.te) || 0],
                            action: parseInt(u.ta) || 0,
                            interface: parseInt(u.in) || null,
                            interfaceT: parseInt(u.tin) || null
                        });
                    else if ("DEPOSIT_BOX" == u.i)
                        this.manager.addBank(S, T, E, u.s[0], u.s[2], u.s[1], {
                            src: A,
                            colr: u.c,
                            emissive: u.e || null,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            transparent: 1 != u.o && null != u.o,
                            penetrable: u.pe,
                            amb: p.nAmb || null != u.ab ? null : h.ambientVal,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0,
                            isBorder: u.bo,
                            noVis: u.v,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td,
                            noAmb: null != u.ab,
                            interface: parseInt(u.in) || null,
                            withdraw: null == u.wd ? 1e3 : parseInt(u.wd) || 0,
                            deposit: null == u.dp ? 1e3 : parseInt(u.dp) || 0
                        });
                    else if ("LIGHT_CONE" == u.i)
                        this.manager.addLightCone(S, T, E, u.s[0], u.s[2], u.s[1], {
                            colr: u.c,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0,
                            noVis: u.v
                        });
                    else if ("OBJECTIVE" == u.i)
                        this.manager.addObjective(S, T, E, u.s[0], u.s[2], u.s[1], u.obi || 0);
                    else if ("FLAG" == u.i)
                        this.manager.addFlag(S, T, E, parseInt(u.tm || 0) + 1);
                    else if ("WEAPON_PICKUP" == u.i)
                        this.manager.addWeapon(S, T, E, {
                            scoreP: parseInt(u.sp) || 0,
                            noMsg: null != u.nm,
                            method: parseInt(u.md) || 0,
                            noRep: u.wr,
                            weapon: a[parseInt(u.w || u.wid || 0)],
                            weaponId: parseInt(u.w || u.wid || 0)
                        }, u.r ? u.r[2] : 0, u.r ? u.r[0] : 0, u.r ? u.r[1] : 0);
                    else if ("PARTICLES" != u.i)
                        "PLANE" == u.i || "BILLBOARD" == u.i ? this.manager.addPlane(S, T, E, u.s[2] / 2, u.s[0] / 2, {
                            src: "BILLBOARD" == u.i ? "pubs/b_" + (u.bb || i.randInt(1, h.billboardCnt)) : A,
                            emissive: u.e || null,
                            noise: u.en || 0,
                            opacity: 1 != u.o && null != u.o ? u.o : 1,
                            penetrable: u.pe,
                            health: u.h || u.hp,
                            respawnT: 1e3 * parseFloat(u.rt),
                            respawnR: null != u.rr,
                            colr: u.c,
                            noCol: u.l || u.col,
                            noVis: u.v,
                            side: "BILLBOARD" == u.i ? 2 : 0,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td,
                            noAmb: null != u.ab,
                            interface: parseInt(u.in) || null
                        }, u.r ? u.r[2] : 0, (u.r ? u.r[0] : 0) - Math.PI / 2, u.r ? u.r[1] : 0) : "SIGN" == u.i ? this.manager.addCanvas(S, T, E, u.s[2] / 2, u.s[0] / 2, {
                            noCol: u.l || u.col,
                            fontSize: parseInt(u.sf) || 10,
                            text: u.st,
                            tAlign: parseInt(u.sa) || 0,
                            fcolr: u.sc,
                            bcolr: u.sb,
                            noBVis: u.bv,
                            movT: null != u.ts && u.ts / 1e4,
                            movD: u.td
                        }, u.r ? -u.r[2] : 0, (u.r ? u.r[0] : 0) - Math.PI / 2, u.r ? u.r[1] : 0) : "SPECTATE_CAM" == u.i ? this.manager.addSpectateCam(S, T, E, {
                            objLink: u.obi || 0,
                            yR: u.r ? u.r[0] : 0,
                            xR: u.r ? u.r[1] : 0,
                            zR: u.r ? u.r[2] : 0
                        }) : "RAMP" == u.i ? this.manager.addRamp(S, T, E, u.s[0], u.s[1], u.s[2], (u.d || 0) * Math.PI / 2, u.b, u.t ? A : "grey_0", u.v, u.c, h.ambScale, null != u.ts && u.ts / 1e4, u.td, null != u.ab, u.e || null) : "SCORE_ZONE" == u.i ? this.manager.addScoreZone(S, T, E, u.s[0], u.s[2], u.s[1], parseInt(u.sp) || 1) : "DEATH_ZONE" == u.i ? this.manager.addDeathZone(S, T, E, u.s[0], u.s[2], u.s[1]) : "CHECK_POINT" == u.i ? this.manager.addCheckPoint(S, T, E, u.s[0], u.s[2], u.s[1], u.su || !1, u.d || 0) : "TELEPORTER" == u.i ? this.manager.addTeleporter(S, T, E, u.s[0], u.s[2], u.s[1], parseInt(u.ch || 0), parseInt(u.n || 0), null != u.m) : "LADDER" == u.i ? this.manager.addLadder(S, T, E, u.s[1], (u.d || 0) * Math.PI / 2, u.v, u.t ? A : "floor_0", u.c) : this.manager.addMesh(S, T, E, u.r, u.s[0] / 2, u.s[1] / 2, u.s[2] / 2, {
                            src: u.i.toLowerCase(),
                            health: u.h || u.hp,
                            respawnT: 1e3 * parseFloat(u.rt),
                            respawnR: null != u.rr,
                            colr: u.c,
                            noCol: u.l || u.col,
                            noVis: u.v,
                            noAmb: null != u.ab,
                            interface: parseInt(u.in) || null
                        });
                    else if (t) {
                        var R = t.prefabs[parseInt(u.pr || 0)];
                        t.area(S, T, E, u.s[0], u.s[1], u.s[2], {
                            src: R.src,
                            blending: R.blending,
                            spd: R.spd * (parseInt(u.psp) || 1),
                            cnt: R.cnt,
                            count: 0 < (parseInt(u.pc) || 0) ? parseInt(u.pc) : Math.round((u.s[0] + u.s[2] + u.s[1]) / R.cnt),
                            grav: R.grav.map(e=>e * (parseInt(u.pg) || 1)),
                            scl: R.scl.map(e=>e * (parseInt(u.ps) || 1)),
                            dir: u.d || R.dir,
                            colr: u.c
                        })
                    }
                }
                if (this.mapHeight = _,
                this.manager.addNoisePlanes(),
                p.shadLength = Math.round(Math.abs(w - b) / 2.5),
                p.shadWidth = Math.round(Math.abs(M - x) / 2.5),
                e && e.updateLightMap(p),
                this.manager.aoOpac = 1,
                e) {
                    var C, L = h.ambScale;
                    for (g = 0; g < this.manager.objects.length; ++g)
                        if (!((u = this.manager.objects[g]).noVis || "prop" == c.id && u.propID || u.complexMesh || u.health || u.noAmb || u.gate))
                            for (O = g + 1; O < this.manager.objects.length; ++O)
                                if (!(d = this.manager.objects[O]).noVis && ("prop" != c.id || !d.propID) && !d.health && !d.noAmb && !d.gate && !d.complexMesh && this.manager.collision(u, d, 0)) {
                                    if (C = i.boxIntersection(u, d, "x", "z", [Math.PI, 0, Math.PI / 2, -Math.PI / 2]))
                                        for (var I = 0; I < C.length; ++I)
                                            if (!C[I].dontUse) {
                                                for (var k = i.getIntersection(u, d, "y"), D = L * (u.aoMlt || 1) * (d.aoMlt || 1), z = 0; 2 > z; z++)
                                                    v = (C[I].d + Math.PI / 2 * z) % (2 * Math.PI),
                                                    D = Math.min(D, this.manager.limitAmb(L, C[I], v, "x", "z", u, d));
                                                for (z = 0; 2 > z; z++)
                                                    if (v = (C[I].d + Math.PI / 2 * z) % (2 * Math.PI),
                                                    this.manager.addAmbient(C[I].x + D * Math.cos(v), k.y, C[I].z + D * Math.sin(v), -v + Math.PI, 0, 0, k.height, D + h.ambOff, 1),
                                                    v == Math.PI / 2 || v == -Math.PI / 2 || v == 1.5 * Math.PI) {
                                                        var B = i.limitRect(C[I].z + D * Math.sin(v), k.y + D + k.height + h.ambOff, D, D, 0, [u, d], "z", "y");
                                                        this.manager.addAmbient(C[I].x + D * Math.cos(v), B.y, B.z, -v + Math.PI, Math.PI, 0, B.length, B.height, 0, [u, d], "g1-" + z + "-" + I, [C[I].x, k.y + k.height, C[I].z]),
                                                        B = i.limitRect(C[I].z + D * Math.sin(v), k.y - D - k.height - h.ambOff, D, D, 0, [u, d], "z", "y"),
                                                        this.manager.addAmbient(C[I].x + D * Math.cos(v), B.y, B.z, -v + Math.PI, 0, 0, B.length, B.height, 0, [u, d], "g2-" + z + "-" + I, [C[I].x, k.y - k.height, C[I].z])
                                                    } else {
                                                        B = i.limitRect(C[I].x + D * Math.cos(v), k.y + D + k.height + h.ambOff, D, D, 0, [u, d], "x", "y");
                                                        this.manager.addAmbient(B.x, B.y, C[I].z + D * Math.sin(v), -v + Math.PI, Math.PI, 0, B.width, B.height, 0, [u, d], "g1-" + z + "-" + I, [C[I].x, k.y + k.height, C[I].z]),
                                                        B = i.limitRect(C[I].x + D * Math.cos(v), k.y - D - k.height - h.ambOff, D, D, 0, [u, d], "x", "y"),
                                                        this.manager.addAmbient(B.x, B.y, C[I].z + D * Math.sin(v), -v + Math.PI, 0, 0, B.width, B.height, 0, [u, d], "g2-" + z + "-" + I, [C[I].x, k.y - k.height, C[I].z])
                                                    }
                                            }
                                    if (C = i.boxIntersection(u, d, "z", "y", [Math.PI, 0, -Math.PI / 2, Math.PI / 2]))
                                        for (I = 0; I < C.length; ++I)
                                            if (!C[I].dontUse) {
                                                for (k = i.getIntersection(u, d, "x"),
                                                D = L * (u.aoMlt || 1) * (d.aoMlt || 1),
                                                z = 0; 2 > z; z++)
                                                    v = C[I].d + Math.PI / 2 * (z ? 0 : 1),
                                                    D = Math.min(D, this.manager.limitAmb(L, C[I], -v + Math.PI / 2, "z", "y", u, d));
                                                for (z = 0; 2 > z; z++) {
                                                    v = C[I].d + Math.PI / 2 * (z ? 0 : 1),
                                                    this.manager.addAmbient(k.x, C[I].y + D * Math.cos(v), C[I].z + D * Math.sin(v), 0, v, -Math.PI / 2, k.width, D + h.ambOff, 1);
                                                    B = i.limitRect(k.x + k.width + D + h.ambOff, C[I].z + D * Math.sin(v), D, D, 0, [u, d], "x", "z");
                                                    this.manager.addAmbient(B.x, C[I].y + D * Math.cos(v), C[I].z + D * Math.sin(v), Math.PI, v == Math.PI ? v : -v % Math.PI, v == 1.5 * Math.PI ? 0 : -Math.PI / 2, v == 1.5 * Math.PI ? D : B.length, v == 1.5 * Math.PI ? B.length : D, 0, [u, d], "g3-" + z + "-" + I, [k.x + k.width, C[I].y, C[I].z]),
                                                    B = i.limitRect(k.x - k.width - D - h.ambOff, C[I].z + D * Math.sin(v), D, D, Math.PI / 2, [u, d], "x", "z"),
                                                    this.manager.addAmbient(B.x, C[I].y + D * Math.cos(v), C[I].z + D * Math.sin(v), Math.PI, -v % Math.PI, v == Math.PI || v == 1.5 * Math.PI ? Math.PI / 2 : Math.PI, v == Math.PI || v == 1.5 * Math.PI ? B.width : D, v == Math.PI || v == 1.5 * Math.PI ? D : B.width, 0, [u, d], "g4-" + z + "-" + I, [k.x - k.width, C[I].y, C[I].z])
                                                }
                                            }
                                    if (C = i.boxIntersection(u, d, "x", "y", [Math.PI, 0, -Math.PI / 2, Math.PI / 2]))
                                        for (I = 0; I < C.length; ++I)
                                            if (!C[I].dontUse) {
                                                for (k = i.getIntersection(u, d, "z"),
                                                D = L * (u.aoMlt || 1) * (d.aoMlt || 1),
                                                z = 0; 2 > z; z++)
                                                    v = C[I].d + Math.PI / 2 * (z ? 0 : 1),
                                                    D = Math.min(D, this.manager.limitAmb(L, C[I], -v + Math.PI / 2, "x", "y", u, d));
                                                for (z = 0; 2 > z; z++)
                                                    if (v = C[I].d + Math.PI / 2 * (z ? 0 : 1),
                                                    this.manager.addAmbient(C[I].x + D * Math.sin(v), C[I].y + D * Math.cos(v), k.z, Math.PI / 2, v, -Math.PI / 2, k.length, D + h.ambOff, 1),
                                                    v == Math.PI || 0 == v) {
                                                        B = i.limitRect(C[I].z + D * Math.sin(v), k.z + k.length + D + h.ambOff, D, D, Math.PI / 2, [u, d], "x", "z");
                                                        this.manager.addAmbient(C[I].x + D * Math.sin(v), C[I].y + D * Math.cos(v), B.z, Math.PI / 2, v, -Math.PI / 2, B.length, B.width, 0, [u, d], "g5-" + z + "-" + I, [C[I].x, C[I].y, k.z + k.length]),
                                                        B = i.limitRect(C[I].z + D * Math.sin(v), k.z - k.length - D - h.ambOff, D, D, Math.PI / 2, [u, d], "x", "z"),
                                                        this.manager.addAmbient(C[I].x + D * Math.sin(v), C[I].y + D * Math.cos(v), B.z, Math.PI / 2, v, Math.PI, B.width, B.length, 0, [u, d], "g6-" + z + "-" + I, [C[I].x, C[I].y, k.z - k.length])
                                                    } else {
                                                        B = i.limitRect(C[I].x + D * Math.sin(v), k.z + k.length + D + h.ambOff, D, D, Math.PI / 2, [u, d], "x", "z");
                                                        this.manager.addAmbient(B.x, C[I].y + D * Math.cos(v), B.z, Math.PI / 2, v, -Math.PI / 2, B.length, B.width, 0, [u, d], "g5-" + z + "-" + I, [C[I].x, C[I].y, k.z + k.length]),
                                                        B = i.limitRect(C[I].x + D * Math.sin(v), k.z - k.length - D - h.ambOff, D, D, Math.PI / 2, [u, d], "x", "z"),
                                                        this.manager.addAmbient(B.x, C[I].y + D * Math.cos(v), B.z, Math.PI / 2, v, Math.PI, B.width, B.length, 0, [u, d], "g6-" + z + "-" + I, [C[I].x, C[I].y, k.z - k.length])
                                                    }
                                            }
                                }
                    this.manager.addPendingAOs()
                }
                this.spawns.length = 0;
                for (g = 0; g < p.spawns.length; ++g)
                    this.spawns.push({
                        x: p.spawns[g][0],
                        y: p.spawns[g][1],
                        z: p.spawns[g][2],
                        team: p.spawns[g][3],
                        dir: parseInt(p.spawns[g][4]) || 0,
                        comp: !!p.spawns[g][5]
                    });
                e && e.addMeshGroups()
            }
            this.manager.resetAll()
        }
    }
}
, function(e, t) {
    e.exports = [{
        name: "Triggerman",
        loadout: [1],
        secondary: !0,
        colors: [10975328, 4013373, 2302755, 2631720, 7098434, 12566463],
        health: 100,
        segs: 6,
        speed: 1.05
    }, {
        name: "Hunter",
        loadout: [0],
        secondary: !0,
        colors: [10975328, 8083261, 6506290, 2631720, 6506290, 4008733],
        health: 60,
        segs: 5,
        speed: 1.05
    }, {
        name: "Run N Gun",
        loadout: [3],
        colors: [10975328, 4088706, 3099491, 2631720, 6506290, 1715002],
        health: 100,
        segs: 6,
        speed: 1.18
    }, {
        name: "Spray N Pray",
        loadout: [6],
        txts: ["Calling in the Big Guns?", "Remember - No Russian.", "Pesky Snipers..."],
        colors: [10975328, 5793865, 4806204, 2631720, 2631720, 3160103],
        health: 170,
        segs: 7,
        regen: .05,
        speed: 1
    }, {
        name: "Vince",
        loadout: [5],
        secondary: !0,
        colors: [8412234, 5526119, 4144461, 2631720, 2631720, 2697267],
        health: 100,
        segs: 6,
        speed: 1
    }, {
        name: "Detective",
        loadout: [4],
        colors: [10975328, 7360054, 4410462, 2631720, 6506290, 4140062],
        health: 100,
        segs: 6,
        speed: 1
    }, {
        name: "Marksman",
        loadout: [7],
        secondary: !0,
        colors: [10975328, 5793865, 4806204, 2631720, 2631720, 2699298],
        health: 90,
        segs: 6,
        speed: 1
    }, {
        name: "Rocketeer",
        loadout: [8],
        secondary: !0,
        txts: ["..."],
        colors: [10975328, 5793865, 4806204, 2631720, 7098434, 2831140],
        health: 130,
        segs: 7,
        speed: .86
    }, {
        name: "Agent",
        loadout: [9],
        colors: [10975328, 4013373, 2302755, 2631720, 2631720, 12566463],
        health: 100,
        segs: 6,
        speed: 1.2
    }, {
        name: "Runner",
        txts: ["You sure about this?", "...", "Oh boy", "I don't know about this...", "Not me again..."],
        loadout: [12],
        colors: [10975328, 4013373, 2302755, 2631720, 2631720, 2302755],
        health: 100,
        segs: 6,
        regen: .2,
        speed: 1
    }, {
        name: "Deagler",
        hide: !0,
        loadout: [10],
        colors: [10975328, 4013373, 2302755, 2631720, 2631720, 2302755],
        health: 60,
        segs: 5,
        speed: 1
    }, {
        name: "Bowman",
        loadout: [13],
        secondary: !0,
        colors: [10975328, 9530450, 6308654, 2631720, 2631720, 4666663],
        health: 100,
        segs: 6,
        speed: 1
    }, {
        name: "Commando",
        loadout: [14],
        secondary: !0,
        colors: [10975328, 4013373, 2302755, 2631720, 10050604, 1513239],
        health: 100,
        segs: 6,
        speed: 1
    }]
}
, function(e, t, r) {
    var i, n, s = r(7), a = r(4), o = r(58);
    e.exports = function(t, s, a, c, l) {
        t.ImageUtils.crossOrigin = "";
        var p = r(24)
          , h = new t.LoadingManager
          , u = new t.OBJLoader(h);
        this.cubeGeo = new t.BoxGeometry(1,1,1),
        this.getCubeMesh = function() {
            return new t.Mesh(this.cubeGeo)
        }
        ;
        var d = new t.PlaneGeometry(1,1);
        new t.CylinderGeometry(.1,1,1,4,1,!1,Math.PI / 4).computeFlatVertexNormals();
        var f = new t.TextureLoader
          , m = new t.MeshBasicMaterial({
            color: 16777215
        })
          , g = new t.MeshBasicMaterial({
            color: 65280
        })
          , v = {}
          , y = {}
          , b = {};
        this.movTextures = [],
        this.pulsMats = [],
        this.frameMats = [],
        this.pulsVal = 0;
        var w, x = this, M = {};
        this.frustum = new t.Frustum;
        var _ = new t.Matrix4;
        this.camera = new t.PerspectiveCamera(0,window.innerWidth / window.innerHeight,.1,6e3),
        this.fpsCamera = new t.PerspectiveCamera(c.fov,window.innerWidth / window.innerHeight,.1,300),
        this.fpsCamera.layers.set(1),
        this.camera.add(this.fpsCamera),
        this.weaponLean = 1,
        this.weaponOffX = 1,
        this.weaponOffY = 1,
        this.weaponOffZ = 1,
        this.weaponBob = 1,
        this.hideADS = 0,
        this.renderDst = 0,
        this.customADS = "",
        this.lowSpec = !1,
        this.customRatio = null,
        this.aspectRatio = "",
        this.init = function(r, i) {
            this.clearPendingMeshes(),
            this.scene = new t.Scene,
            this.backgroundScene = new t.Scene,
            r.skyDome && i && null == i.skyCol && (this.skyDome = o.fromConfig(r),
            this.backgroundScene.add(this.skyDome)),
            e.exports.initScene.apply(this, [r, i])
        }
        ,
        this.getRes = function() {
            var e = this.aspectRatio.split("x");
            return (parseInt(e[0]) || window.innerWidth) / (parseInt(e[1]) || window.innerHeight)
        }
        ;
        var S = 0;
        this.flash = function(e, t) {
            l.showFlash = !0,
            l.flashX = e,
            l.flashY = 1 - t,
            S = 1
        }
        ,
        this.updateLightMap = function(e) {
            this.skyLight && (this.skyLight.shadow.camera.right = e.shadWidth,
            this.skyLight.shadow.camera.left = -e.shadWidth,
            this.skyLight.shadow.camera.top = e.shadLength,
            this.skyLight.shadow.camera.bottom = -e.shadLength)
        }
        ,
        this.useDepthMap = 0,
        this.toggleDepthMap = function(r) {
            if (this.useDepthMap = r,
            this.scene) {
                var s = r && "0" != r;
                this.scene.overrideMaterial = s ? m : null,
                s ? (this.scene.fog = new t.Fog(0,0,r),
                this.renderer.setClearColor(0)) : e.exports.initScene.apply(this, [i, n])
            }
        }
        ,
        this.greenScreen = !1,
        this.updateGreenScreen = function(e) {
            x.greenScreen && !e.noGreen ? (e.realMat = e.material,
            e.material = g) : e.material = e.realMat || e.material
        }
        ,
        this.toggleGreenscreen = function(e) {
            this.greenScreen = e,
            this.scene && (e ? (this.renderer.setClearColor(65280),
            this.scene.fog.near = .1,
            this.scene.fog.far = 0) : (this.scene.fog.near = 1,
            this.scene.fog.far = n && null != n.fogD ? n.fogD : i.fogD,
            this.renderer.setClearColor(n && null != n.skyCol ? n.skyCol : i.sky)),
            this.scene.traverse(function(e) {
                x.updateGreenScreen(e)
            }))
        }
        ,
        this.renderer = new t.WebGLRenderer({
            precision: "mediump",
            powerPreference: "high-performance",
            antialias: !0
        }),
        this.renderer.shadowMap.enabled = !0,
        this.renderer.shadowMap.autoUpdate = !1,
        this.renderer.shadowMap.type = t.BasicShadowMap,
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.setSize(window.innerWidth, window.innerHeight),
        this.renderer.autoClear = !1,
        document.body.appendChild(this.renderer.domElement),
        this.shadows = !0,
        this.updateShadowMap = function() {
            this.shadows && (this.renderer.shadowMap.needsUpdate = !0)
        }
        ,
        this.toggleShadowMap = function(e) {
            e ? (this.shadows = !0,
            this.updateShadowMap()) : (this.shadows = !1,
            this.skyLight && (this.renderer.setRenderTarget(this.skyLight.shadow.map),
            this.renderer.clear(),
            this.renderer.setRenderTarget(null)))
        }
        ,
        this.zoomVal = 1,
        this.zoom = function(e) {
            this.zoomVal = e,
            this.updateCamFOV(),
            this.fpsCamera.fov = this.fpsFov / e,
            this.fpsCamera.updateProjectionMatrix()
        }
        ,
        this.setFPSFov = function(e) {
            this.fpsFov = e,
            this.fpsCamera.fov = e,
            this.fpsCamera.updateProjectionMatrix()
        }
        ,
        this.setFPSFov(c.fov),
        this.fovMult = function(e) {
            this.fovMlt != e && (this.fovMlt = e,
            this.updateCamFOV())
        }
        ,
        this.fovMlt = 1,
        this.updateCamFOV = function() {
            this.camera.fov = this.fov / this.zoomVal * this.fovMlt,
            this.camera.updateProjectionMatrix()
        }
        ,
        this.setFov = function(e) {
            this.fov = e,
            this.updateCamFOV()
        }
        ,
        this.setFov(c.fov),
        this.resize = function() {
            this.camera.aspect = this.getRes(),
            this.camera.updateProjectionMatrix(),
            this.fpsCamera.aspect = this.getRes(),
            this.fpsCamera.updateProjectionMatrix(),
            this.renderer.setSize(window.innerWidth, window.innerHeight)
        }
        ,
        this.resMltV = 1,
        this.setResMlt = function(e) {
            this.resMltV = e,
            this.renderer.setPixelRatio(window.devicePixelRatio * this.resMltV),
            this.renderer.setSize(window.innerWidth, window.innerHeight)
        }
        ,
        this.updateFrustum = function() {
            this.frustum.setFromMatrix(_.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse))
        }
        ;
        var T = 0
          , E = 0;
        this.shakeX = 0,
        this.shakeY = 0,
        this.updateShake = function(e) {
            T && (T *= Math.pow(.99, e),
            E += s.randFloat(-Math.PI, Math.PI),
            this.shakeX = Math.cos(E) * T,
            this.shakeY = Math.sin(E) * T,
            .01 >= T && (T = 0,
            this.shakeX = this.shakeY = 0))
        }
        ,
        this.shake = function(e) {
            T = e
        }
        ,
        this.render = function(e, t) {
            if (this.scene || t) {
                for (var r = 0; r < this.movTextures.length; ++r)
                    (w = this.movTextures[r]).tex.offset && (w.tex.offset[0 == w.movD ? "x" : "y"] += w.mov * e);
                this.pulsVal += .003 * e;
                var i;
                for (r = 0; r < this.pulsMats.length; ++r)
                    i = 1.2 * (Math.sin(this.pulsVal) / 2 + .5),
                    this.pulsMats[r].mat.emissiveIntensity = i;
                for (r = 0; r < this.frameMats.length; ++r)
                    (w = this.frameMats[r]).dur -= e,
                    0 >= w.dur && (w.dur = w.orgDur,
                    w.cur++,
                    w.cur > w.num && (w.cur = 0),
                    w.mat.map && (w.mat.map.offset.x = w.cur % w.num / w.num));
                t || (this.renderer.clear(),
                this.camera.layers.set(0),
                this.skyDome && (this.camera.getWorldPosition(this.skyDome.position),
                this.renderer.render(this.backgroundScene, this.camera),
                this.renderer.clearDepth()),
                this.renderer.render(this.scene, this.camera),
                this.camera.layers.set(2),
                this.renderer.clearDepth(),
                this.renderer.render(this.scene, this.camera),
                this.renderer.clearDepth(),
                this.renderer.render(this.scene, this.fpsCamera),
                l.showFlash && (0 >= S && (S = 0,
                l.showFlash = !1),
                S -= e),
                this.updateShake(e))
            }
        }
        ,
        this.updateTexture = function(e, r, i) {
            i = i || {};
            var n = 0;
            for (var s in b)
                s.substring(0, e.length + 2) == e + "mt" && (n++,
                b[s].image = r,
                b[s].needsUpdate = !0);
            if (!n) {
                var a = e + (null == i.movT ? "mt" : "mt" + i.movT) + (null == i.movD ? "md" : i.movD) + (i.fontSize || "fs") + (i.fcolr || "fc") + (i.bcolr || "bc") + (i.noBVis || "bv") + (i.text || "txt") + (i.tAlign || "ta")
                  , o = b[a];
                o = new t.Texture(r),
                b[a] = o,
                b[a].needsUpdate = !0
            }
        }
        ,
        this.loadTexture = function(e, r, i, n) {
            var a = r + (null == (i = i || {}).movT ? "mt" : "mt" + i.movT) + (null == i.movD ? "md" : i.movD) + (i.fontSize || "fs") + (i.fcolr || "fc") + (i.bcolr || "bc") + (i.noBVis || "bv") + (i.text || "txt") + (i.tAlign || "ta");
            if (b[a])
                b[a].mats ? b[a].mats.push({
                    t: n,
                    m: e
                }) : (e[n || "map"] = b[a],
                e.needsUpdate = !0);
            else if (b[a] = {
                mats: [{
                    t: n,
                    m: e
                }]
            },
            i.canvas) {
                var o = new t.Texture(i.canvas);
                o.wrapS = t.RepeatWrapping,
                o.wrapT = t.RepeatWrapping,
                o.repeat.set(i.repeatX || 1, i.repeatY || 1),
                o.minFilter = i.tFilter || t.NearestFilter,
                o.magFilter = i.tFilter || t.NearestFilter,
                o.needsUpdate = !0;
                for (var c = 0; c < b[a].mats.length; ++c)
                    b[a].mats[c].m[b[a].mats[c].t || "map"] = o,
                    b[a].mats[c].m.needsUpdate = !0;
                b[a] = o,
                i.movT && this.movTextures.push({
                    tex: o,
                    mov: i.movT,
                    movD: i.movD || 0
                })
            } else
                "string" != typeof r || r.includes("default") || f.load(s.assetsUrl("/textures/" + r + ".png"), e=>{
                    e.wrapS = t.RepeatWrapping,
                    e.wrapT = t.RepeatWrapping,
                    e.repeat.set(i.frames ? 1 / i.frames : i.repeatX || 1, i.repeatY || 1),
                    e.minFilter = i.tFilter || t.NearestFilter,
                    e.magFilter = i.tFilter || t.NearestFilter,
                    e.needsUpdate = !0;
                    for (var r = 0; r < b[a].mats.length; ++r)
                        b[a].mats[r].m[b[a].mats[r].t || "map"] = e,
                        b[a].mats[r].m.needsUpdate = !0;
                    b[a] = e,
                    i.movT && this.movTextures.push({
                        tex: e,
                        mov: i.movT,
                        movD: i.movD || 0
                    })
                }
                );
            return e
        }
        ,
        this.getMat = function(e, r) {
            var i = (r && r.texSrc || e) + (r ? (r.rotation || "x") + (r.noFog || "y") + (r.opacity || "z") + (r.color || "b") + (r.mat ? "ma" : "nm") + (r.ao || "a") + (r.emissive || "e") + (r.glowText || "g") + (null == r.movT ? "mt" : r.movT) + (null == r.movD ? "md" : r.movD) + (null == r.canvas ? "" : "canvas") + (null == r.pulsT ? "npt" : "pt" + r.pulsT) + (null == r.frames ? "nfr" : "fr" + r.frames) + (null == r.frameT ? "nfrt" : "frt" + r.frameT) + (null == r.depthWrite ? "d" : r.depthWrite) + (r.fontSize || "fs") + (r.fcolr || "fc") + (r.bcolr || "bc") + (r.noBVis || "bv") + (r.text || "txt") + (r.tAlign || "ta") : "")
              , n = y[i];
            return n || (n = new ((r = r || {}).mat ? r.mat : t.StrippedLambertMaterial)(r),
            r.canvas && this.loadTexture(n, i, r),
            e && "default" != e && this.loadTexture(n, r.texSrc || e, r),
            r && r.emissive && this.loadTexture(n, (r.glowText && r.texSrc || e) + (r.sameGlow ? "" : "_e"), r, "emissiveMap"),
            r && r.ao && (this.loadTexture(n, e + "_ao", r, "aoMap"),
            n.aoMapIntensity = 1.3),
            r && r.normal && this.loadTexture(n, e + "_n", r, "normalMap"),
            "default" == e && (n.vertexColors = t.VertexColors),
            r && r.noFog && (n.fog = !1),
            n.shading = t.SmoothShading,
            y[i] = n,
            r.pulsT && this.pulsMats.push({
                mat: n,
                pul: r.pulsT
            }),
            r.frames && this.frameMats.push({
                mat: n,
                num: r.frames,
                cur: 0,
                dur: r.frameT,
                orgDur: r.frameT
            })),
            n
        }
        ,
        this.genColorCube = function(e, r, i, n, s, a) {
            for (var o = (a = a || {}).us ? "us" : "ns", c = 0; c < n.length; ++c) {
                for (var l = 0; l < n[c].length; ++l)
                    o += n[c][l] + "_";
                o += "|"
            }
            var h = v[o];
            if (!h) {
                h = new t.Geometry;
                var u = .5 + (s || 0);
                for (c = 0; c < n.length; ++c) {
                    var d = n[c][1]
                      , f = n[c][2] || 1;
                    if (a.us) {
                        m = p.generateCube([1, 1, 1, 1, 1, 1], 1, 1, 1, {
                            colr: n[c][0],
                            fAmb: n[c][4],
                            amb: n[c][3]
                        });
                        (g = new t.Mesh(m)).scale.set(f, d, f),
                        this.moveMesh(g, 0, u - d, 0)
                    } else {
                        var m = new t.BoxGeometry(f,d,f);
                        p.colorize(m, n[c][0]),
                        g = new t.Mesh(m),
                        this.moveMesh(g, 0, u - d / 2, 0)
                    }
                    this.merge(h, g),
                    u -= d
                }
                v[o] = h
            }
            var g = new t.Mesh(h,this.getMat("default"));
            return this.scaleMesh(g, e, r, i),
            g
        }
        ;
        var A = {};
        this.genBody = function(e, r, i, n, s) {
            var a = e + "-" + r + "-" + i + "-" + n
              , o = A[a];
            if (!o) {
                o = new t.Geometry;
                var l = c.fvcbEmTb - c.headScale - c.legHeight
                  , p = this.genColorCube(c.chestWidth, l, c.chestScale, [[e, .8, 1, .8], [r, .2, 1.05]], 0, {
                    us: s
                });
                this.moveMesh(p, 0, l / 2, 0),
                this.merge(o, p);
                var h = this.genColorCube(c.headScale, c.headScale, c.headScale, [[i, .2, 1, .6], [n, .8]], 0, {
                    us: s
                });
                this.moveMesh(h, 0, c.fvcbEmTb - c.headScale / 2 - c.legHeight, 0),
                this.merge(o, h),
                o = (new t.BufferGeometry).fromGeometry(o),
                A[a] = o
            }
            var u = new t.Mesh(o,this.getMat("default"));
            return u.receiveShadow = !0,
            u.noGreen = !0,
            u
        }
        ;
        var P = {};
        this.genLeg = function(e, r, i, n, s) {
            var a = c.legScale
              , o = null;
            if (n) {
                var l = r + "-" + (n || "");
                if (!(o = P[l])) {
                    var p = c.legHeight / 2
                      , h = a / 2
                      , u = [.5, 2]
                      , d = this.genColorCube(a, p, a, [[r, 1]], 0, {
                        us: s
                    });
                    this.moveMesh(d, 0, -p / 2 * Math.cos(u[1]), -p / 2 * Math.sin(u[1])),
                    this.rotateMesh(d, 0, u[1], 0);
                    var f = Math.sqrt(h * h + h * h - 2 * h * h * Math.cos(u[0] - u[1]))
                      , m = 2 * Math.sqrt(h * h - f / 2 * (f / 2))
                      , g = this.genColorCube(a, f, m, [[r, 1]], 0, {
                        us: s
                    });
                    this.moveMesh(g, 0, -p * Math.cos(u[1]), -p * Math.sin(u[1])),
                    this.rotateMesh(g, 0, (u[1] + u[0]) / 2, 0);
                    var v = this.genColorCube(a, p, a, [[r, .5, 1, .8], [i, .5]], 0, {
                        us: s
                    });
                    this.moveMesh(v, 0, -p * Math.cos(u[1]) - p / 2 * Math.cos(u[0]), -p * Math.sin(u[1]) - p / 2 * Math.sin(u[0])),
                    this.rotateMesh(v, 0, u[0], 0);
                    o = new t.Geometry;
                    this.merge(o, d),
                    this.merge(o, g),
                    this.merge(o, v),
                    P[l] = o
                }
                o = (new t.BufferGeometry).fromGeometry(o),
                o = new t.Mesh(o,this.getMat("default")),
                this.moveMesh(o, c.legScale / 2 * (e ? -1 : 1), c.legHeight - c.crouchDst + .5, 0)
            } else
                o = this.genColorCube(a, c.legHeight, a, [[r, .75, 1], [i, .25]], -.5, {
                    us: s
                }),
                this.moveMesh(o, c.legScale / 2 * (e ? -1 : 1), c.legHeight, 0);
            return o.receiveShadow = !0,
            o.noGreen = !0,
            o
        }
        ;
        var O = {};
        this.genArms = function(e, r, i, n, s, a) {
            var o = O[e.name + "-" + i + "-" + n + "-" + a + "-" + (s || 0)];
            if (!o) {
                o = new t.Geometry;
                var l = (-c.chestWidth + c.armScale / 2 - c.armInset) * (a ? e.holdW || .4 : 1);
                s && 1 != s || this.merge(o, this.genArm(l, c.armOff, e, !0, r, i, n, a)),
                s && 2 != s || this.merge(o, this.genArm(-l, c.armOff, e, !1, r, i, n, a)),
                o = (new t.BufferGeometry).fromGeometry(o),
                O[e.name + "-" + i + "-" + a + "-" + (s || 0)] = o
            }
            return (o = new t.Mesh(o,this.getMat("default"))).position.z += a && e.hDstOff || 0,
            o.noGreen = !0,
            o.receiveShadow = !0,
            o
        }
        ,
        this.genArm = function(e, r, i, n, a, o, l, p) {
            var h = n ? i.leftHoldY : i.rightHoldY
              , u = n ? i.leftHoldZ : i.rightHoldZ;
            u += p && i.hDstOff || 0;
            var d = n ? i.leftHoldX || 0 : i.rightHoldX || 0
              , f = c.armScale * (p ? .7 : 1)
              , m = Math.min(c.uArmLength + c.lArmLength - .01, s.getD3D(e, r, 0, (i.xOff - d) * (n && i.akimbo ? -1 : 1), i.yOff + h, i.zOff - u))
              , g = s.getAnglesSSS(m, c.uArmLength, c.lArmLength)
              , v = Math.PI / 2;
            if (!p) {
                var y = this.genColorCube(f, c.uArmLength, f, [[a, 1]], 0, {
                    us: p
                });
                this.moveMesh(y, 0, -c.uArmLength / 2 * Math.cos(v), -c.uArmLength / 2 * Math.sin(v)),
                this.rotateMesh(y, 0, v, 0);
                var b = f / 2
                  , w = Math.sqrt(b * b + b * b - 2 * b * b * Math.cos(Math.PI + g[0] + Math.PI / 2))
                  , x = 2 * Math.sqrt(b * b - w / 2 * (w / 2))
                  , M = this.genColorCube(f, w, x, [[a, 1]], 0, {
                    us: p
                });
                this.moveMesh(M, 0, -c.uArmLength * Math.cos(v), -c.uArmLength * Math.sin(v)),
                this.rotateMesh(M, 0, (v + g[0]) / 2, 0)
            }
            var _ = this.genColorCube(f, c.lArmLength, f, [[a, .65, 1, .6], [o, .15, 1.1], [l, .2, 1, .5, !0]], 0, {
                us: p
            })
              , S = c.lArmLength / 2;
            this.moveMesh(_, 0, -c.uArmLength * Math.cos(v) - S * Math.cos(g[0]), -c.uArmLength * Math.sin(v) - S * Math.sin(g[0])),
            this.rotateMesh(_, 0, g[0], 0);
            var T = new t.Geometry;
            if (p) {
                var E = this.genColorCube(f, 20, f, [[a, 1]], 0, {
                    us: p
                });
                this.moveMesh(E, 0, -c.uArmLength * Math.cos(v) - -10 * Math.cos(g[0]), -c.uArmLength * Math.sin(v) - -10 * Math.sin(g[0])),
                this.rotateMesh(E, 0, g[0], 0),
                this.merge(T, E)
            } else
                this.merge(T, y),
                this.merge(T, M);
            return this.merge(T, _),
            T = new t.Mesh(T),
            this.moveMesh(T, e - i.xOff, r - i.yOff, -i.zOff),
            T.rotation.order = "YXZ",
            T.rotation.x = -g[1] - s.getDir(0, r, i.zOff - u, i.yOff + h),
            T.rotation.y = s.getDir(-e, 0, (n && i.akimbo ? 1 : -1) * (i.xOff - d), i.zOff - u) - Math.PI / 2,
            T
        }
        ,
        this.addCube = function(e, r, i, n, s, a, o, c) {
            c = c || {};
            var l = new t.Mesh(p.generateCube(o, n, s, a, c));
            return this.moveMesh(l, e, r, i),
            l.rotation.set(c.yR || 0, c.xR || 0, c.zR || 0),
            l.scale.set(n, s, a),
            c.src && !c.noGroup ? this.meshGroup(l, c) : this.add(l, c),
            l
        }
        ,
        this.addCone = function(e, r, i, n, s, a, o) {
            o = o || {};
            var c = new t.Mesh(p.generateCone(n, s, a, o));
            return this.moveMesh(c, e, r, i),
            c.rotation.set(o.yR || 0, o.xR || 0, o.zR || 0),
            o.src && !o.noGroup ? this.meshGroup(c, o) : this.add(c, o),
            c
        }
        ;
        var R = [];
        this.addSpray = function(e, r, i, n, a, o, l, p) {
            w = null;
            for (var h = 0; h < R.length; ++h)
                if (R[h].sid == e) {
                    w = R[h];
                    break
                }
            w || ((w = new t.Mesh(d)).sid = e,
            w.scale.set(c.sprayScale, c.sprayScale, 1),
            w.receiveShadow = !0,
            R.push(w),
            this.add(w)),
            this.moveMesh(w, i, n, a),
            w.rotation.y = s.toRad(o),
            w.rotation.x = s.toRad(l),
            w.material = this.getMat("sprays/" + r, {
                depthWrite: !1,
                opacity: p,
                transparent: !0
            })
        }
        ,
        this.clearSprays = function() {
            for (var e = 0; e < R.length; ++e)
                R[e] && R[e].material.map && R[e].material.map.dispose(),
                this.scene.remove(R[e]);
            R.length = 0
        }
        ,
        this.addPlane = function(e, r, i, n, s, a, o, c, l) {
            (a = a || {}).premultipliedAlpha = !0;
            var h = new t.Mesh(p.generatePlane(s, n, a, e, r, i));
            return a.euler && (h.rotation.order = a.euler),
            this.moveMesh(h, e, r, i),
            h.rotateY(o || 0),
            h.rotateX((c || 0) - Math.PI / 2),
            h.rotateZ(l || 0),
            h.scale.set(2 * n, 2 * s, 1),
            a.dontAdd ? a.src && (h.material = this.getMat(a.src, a)) : a.src && !a.noGroup ? this.meshGroup(h, a, 1) : this.add(h, a),
            h
        }
        ,
        this.addRamp = function(e, r, i, n, s, a, o, c, l) {
            c = c || {};
            var h = new t.Mesh(p.generatePlane(2 * a, n, c));
            this.moveMesh(h, e, r + s / 2, i),
            a *= 2;
            var u = Math.sqrt(s * s + a * a);
            return h.scale.set(n, u, 2),
            h.rotateY(-Math.PI / 2 - o),
            h.rotateX(Math.asin(s / u) - Math.PI / 2),
            h.rotateZ(l || 0),
            c.src ? this.meshGroup(h, c, 1) : this.add(h, c),
            h
        }
        ,
        this.addGrass = function(e, r, i, n, s, a, o) {
            o = o || {};
            let c = new t.Geometry
              , l = 2 * Math.PI * Math.random()
              , h = new t.Mesh(p.generatePlane(n, s, o));
            h.rotateY(l * (Math.PI / 2)),
            this.merge(c, h);
            let u = new t.Mesh(p.generatePlane(n, s, o));
            u.rotateY((l + 1) * (Math.PI / 2)),
            this.merge(c, u);
            let d = new t.Mesh(c);
            return this.moveMesh(d, e, r + s / 2, i),
            d.rotation.set(o.yR || 0, o.xR || 0, o.zR || 0),
            d.scale.set(n, s, a),
            o.src && !o.noGroup ? this.meshGroup(d, o) : this.add(d, o),
            d
        }
        ;
        var C = []
          , L = [];
        this.loadMesh = function(e, r, i, n, a, o, c, l) {
            var p = this.getMat(e.src, e)
              , h = C[e.src];
            if (h) {
                if (e.centerZ) {
                    h.computeBoundingBox();
                    var d = h.boundingBox.getCenter();
                    c.translateZ(d.x * o)
                }
            } else
                h = l ? new t.Geometry : new t.BufferGeometry,
                C[e.src] = h,
                u.load(s.assetsUrl("/models/" + e.src + ".obj"), function(r) {
                    if (h.copy(l ? (new t.Geometry).fromBufferGeometry(r.children[0].geometry) : r.children[0].geometry),
                    e.uv2 && h.addAttribute("uv2", new t.BufferAttribute(h.attributes.uv.array,2)),
                    l) {
                        for (var i = new t.Geometry, n = 0; n < L[e.src].length; ++n)
                            x.merge(i, L[e.src][n]);
                        x.add(new t.Mesh((new t.BufferGeometry).fromGeometry(i),p), e),
                        L[e.src].length = 0,
                        L[e.src].loaded = !0
                    }
                    if (e.centerZ) {
                        h.computeBoundingBox();
                        var s = h.boundingBox.getCenter();
                        c.translateZ(s.x * o)
                    }
                });
            var f = new t.Mesh(h,p);
            return f.receiveShadow = !e.noShadow,
            f.noGreen = e.noGreen,
            f.castShadow = e.shadows,
            "object" == typeof a ? (f.rotation.x = f.xR = a[0] || 0,
            f.rotation.y = f.yR = a[1] || 0,
            f.rotation.z = f.zR = a[2] || 0) : f.rotation.y = a || 0,
            f.xP = r,
            f.yP = i,
            f.zP = n,
            x.moveMesh(f, r, i, n),
            x.scaleMesh(f, o || 1, o || 1, o || 1),
            l ? L[e.src] ? L[e.src].loaded ? this.meshGroup(f, e) : L[e.src].push(f) : L[e.src] = [f] : c.add(f),
            f
        }
        ,
        this.clearPendingMeshes = function() {
            for (var e in L)
                L.hasOwnProperty(e) && L[e] && (L[e].length = 0)
        }
        ,
        this.updateMesh = function(e, r) {
            var i = u.parse(r)
              , n = new t.BufferGeometry;
            C[e] = n,
            n.copy(i.children[0].geometry),
            n.needsUpdate = !0
        }
        ,
        this.genObj3D = function(e, r, i) {
            var n = new t.Object3D;
            return this.moveMesh(n, e || 0, r || 0, i || 0),
            n
        }
        ,
        this.merge = function(e, t, r) {
            t.updateMatrix(),
            e.merge(t.geometry, t.matrix, r)
        }
        ,
        this.meshGroup = function(e, r) {
            var i = r.src + "-" + (r.shadowsR || "a") + (r.emissive || "e") + (r.opacity || "o") + (null == r.movT ? "mt" : r.movT) + (null == r.movD ? "md" : r.movD);
            M[i] || (M[i] = new t.Geometry,
            M[i].data = r),
            e.updateMatrix(),
            M[i].merge(e.geometry, e.matrix)
        }
        ,
        this.addMeshGroups = function() {
            for (var e in M)
                if (M.hasOwnProperty(e)) {
                    var r = new t.Mesh((new t.BufferGeometry).fromGeometry(M[e]));
                    r.groupSrc = M[e].data.src,
                    r.visible = !I[r.groupSrc],
                    r.matrixAutoUpdate = !1,
                    this.add(r, M[e].data)
                }
            M = {}
        }
        ;
        var I = {};
        this.toggleMeshGroup = function(e, r) {
            I[e] = !r,
            this.scene && this.scene.traverse(function(i) {
                i instanceof t.Mesh && i.groupSrc == e && (i.visible = r)
            })
        }
        ,
        this.add = function(e, t) {
            t && (e.castShadow = t.shadows,
            e.receiveShadow = t.shadows || t.shadowsR,
            e.material = this.getMat(t.src, t)),
            this.updateGreenScreen(e),
            this.scene.add(e),
            this.updateShadowMap()
        }
        ,
        this.remove = function(e) {
            this.scene.remove(e)
        }
        ,
        this.moveMesh = function(e, t, r, i) {
            e && (null != t && (e.position.x = t),
            null != r && (e.position.y = r),
            null != i && (e.position.z = i))
        }
        ,
        this.scaleMesh = function(e, t, r, i) {
            e.scale.set(t, r, i)
        }
        ,
        this.rotateMesh = function(e, t, r, i) {
            e && ((t || 0 == t) && (e.rotation.y = t),
            (r || 0 == r) && (e.rotation.x = r),
            (i || 0 == i) && (e.rotation.z = i))
        }
        ,
        this.reset = function() {
            C = [],
            L = [],
            M = {},
            y = {},
            b = {},
            this.movTextures = [],
            this.pulsMats = [],
            this.frameMats = [],
            this.pulsVal = 0
        }
    }
    ,
    e.exports.initScene = function(e, t) {
        if (i = e,
        n = t,
        (t && null != t.ambCol || e.ambient) && (this.ambientLight = new a.AmbientLight(t && null != t.ambCol ? t.ambCol : e.ambient),
        this.ambientLight.layers.enable(1),
        this.ambientLight.layers.enable(2),
        this.ambientLight.name = "ambLight",
        !this.scene.getObjectByName("ambLight") && this.scene.add(this.ambientLight)),
        t && null != t.lightCol || e.light) {
            this.skyLight = new a.DirectionalLight(t && null != t.lightCol ? t.lightCol : e.light,1.3),
            this.skyLight.name = "skyLight",
            this.skyLight.layers.enable(1),
            this.skyLight.layers.enable(2),
            this.scene.getObjectByName("skyLight") || this.scene.add(this.skyLight);
            var r = -.3 * Math.PI
              , o = 2 * Math.PI * -.25;
            this.skyLight.position.x = s.lightDistance * Math.cos(o),
            this.skyLight.position.y = s.lightDistance * Math.sin(o) * Math.sin(r),
            this.skyLight.position.z = s.lightDistance * Math.sin(o) * Math.cos(r),
            this.skyLight.castShadow = !0,
            this.skyLight.shadow.mapSize.width = e.shadowR || s.shadowRes,
            this.skyLight.shadow.mapSize.height = e.shadowR || s.shadowRes,
            this.skyLight.shadow.camera.far = s.shadowDst
        }
        this.scene.fog = new a.Fog(t && null != t.fogC ? t.fogC : e.fog,1,t && null != t.fogD ? t.fogD : e.fogD),
        this.renderer.setClearColor(t && null != t.skyCol ? t.skyCol : e.sky),
        this.useDepthMap && "0" != this.useDepthMap && this.toggleDepthMap(this.useDepthMap),
        this.greenScreen && this.toggleGreenscreen(this.greenScreen)
    }
}
, function(e, t, r) {
    const i = r(21)
      , n = r(4)
      , s = new n.MeshBasicMaterial({
        color: 16777215,
        flatShading: !1,
        vertexColors: n.VertexColors,
        side: n.BackSide
    })
      , a = 32
      , o = !0
      , c = "y"
      , l = [{
        stp: 0,
        col: null
    }, {
        stp: .5,
        col: null
    }, {
        stp: 1,
        col: null
    }];
    class p extends n.Object3D {
        static fromConfig(e) {
            return new p(e.skyDomeCol0,e.skyDomeCol1,e.skyDomeCol2)
        }
        constructor(e, t, r) {
            super(),
            l[0].col = new n.Color(e || i.skyDome[0]),
            l[1].col = new n.Color(t || i.skyDome[1]),
            l[2].col = new n.Color(r || i.skyDome[2]);
            let p = new n.SphereGeometry(50,a,a);
            p.computeBoundingBox();
            let h = p.boundingBox
              , u = (new n.Vector3).subVectors(h.max, h.min)
              , d = ["a", "b", "c"]
              , f = new n.Vector3
              , m = 0;
            for (let e, t = 0; t < l.length - 1; t++) {
                e = l[t + 1].stp - l[t].stp;
                for (let r, i = 0; i < p.faces.length; i++) {
                    r = p.faces[i];
                    for (var g = 0; 3 > g; g++)
                        m = f.subVectors(p.vertices[r[d[g]]], h.min).divide(u)[c],
                        o && (m = 1 - m),
                        m >= l[t].stp && m <= l[t + 1].stp && (r.vertexColors[g] = l[t].col.clone().lerp(l[t + 1].col, (m - l[t].stp) / e))
                }
            }
            p.computeVertexNormals(!0),
            p.computeFaceNormals(),
            this.baseMesh = new n.Mesh(p,s),
            this.baseMesh.doubleSided = !1,
            this.add(this.baseMesh)
        }
    }
    e.exports = p
}
, function(e, t, r) {
    const i = r(4)
      , n = (r(8),
    r(66))
      , s = r(67).easing;
    let a, o = "undefined" != typeof location;
    o && (a = new i.StrippedLambertMaterial({
        color: 9211020,
        flatShading: !1,
        vertexColors: i.VertexColors
    }));
    const c = {
        GRASS: 0,
        MOUNTAIN: 1
    }
      , l = Object.keys(c).length
      , p = {
        [c.GRASS]: [56, 226, 102],
        [c.MOUNTAIN]: [160, 160, 160]
    }
      , h = {
        DIRT: [140, 104, 53],
        GRASS: [155, 186, 46],
        MOUNTAIN: [160, 160, 160]
    }
      , u = e=>e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (e,t,r,i)=>"#" + t + t + r + r + i + i).substring(1).match(/.{2}/g).map(e=>parseInt(e, 16))
      , d = 60
      , f = 3;
    class m extends i.Object3D {
        static fromConfig(e) {
            return new m(e.terrainSeed,e.terrainWidth,e.terrainHeight,e.sizeMlt,e.terrainMntMlt,e.terrainDrtCol,e.terrainGrsCol,e.terrainMntCol)
        }
        constructor(e, t, r, s, c, p, m, g) {
            super(),
            s = f,
            this.sizeMlt = s,
            this.sizeX = t,
            this.sizeY = r,
            this.edgeSize = 500,
            this.mntMlt = c,
            h.DIRT = u(p),
            h.MOUNTAIN = u(g),
            h.GRASS = u(m),
            this.simplex = new n(e);
            let v = Math.floor(t / d)
              , y = Math.floor(r / d);
            this.xSegmentCount = v,
            this.ySegmentCount = y;
            let b = t / v
              , w = r / y;
            this.xSegmentSize = b,
            this.ySegmentSize = w;
            let x = new i.BufferGeometry
              , M = v * y * 6
              , _ = new i.BufferAttribute(new Float32Array(3 * M),3);
            x.addAttribute("position", _);
            let S = new i.BufferAttribute(new Uint8Array(3 * M),3,!0);
            x.addAttribute("color", S),
            this.vertPositions = _,
            this.terrainPoints = (v + 1) * (y + 1),
            this.terrainHeights = new Float32Array(this.terrainPoints),
            this.terrainBiomes = new Float32Array(this.terrainPoints * l);
            for (let e = 0; e < v + 1; e++)
                for (let i = 0; i < y + 1; i++) {
                    let n = e + i * (v + 1)
                      , s = this._vertPos(e, b, t)
                      , a = this._vertPos(i, w, r)
                      , [o,c] = this.evaluate(s, a);
                    this.terrainHeights[n] = o,
                    this.terrainBiomes.set(c, n * l)
                }
            for (let e = 0; e < v; e++)
                for (let i = 0; i < y; i++) {
                    let n = 6 * (e + i * v)
                      , s = this._vertPos(e, b, t)
                      , a = this._vertPos(i, w, r)
                      , o = [s, a, this.terrainHeight(e, i)]
                      , c = [s + b, a, this.terrainHeight(e + 1, i)]
                      , l = [s + b, a + w, this.terrainHeight(e + 1, i + 1)]
                      , p = [s, a + w, this.terrainHeight(e, i + 1)]
                      , h = this.calcAOWeight(e, i)
                      , u = this.calcAOWeight(e + 1, i)
                      , d = this.calcAOWeight(e + 1, i + 1)
                      , f = this.calcAOWeight(e, i + 1);
                    _.setXYZ(n, ...o),
                    _.setXYZ(n + 1, ...c),
                    _.setXYZ(n + 2, ...l),
                    _.setXYZ(n + 3, ...l),
                    _.setXYZ(n + 4, ...p),
                    _.setXYZ(n + 5, ...o);
                    let m = this._centroid3D(o, c, l)
                      , g = this._centroid3D(l, p, o)
                      , y = this._normal3D(o, c, l)
                      , x = this._normal3D(l, p, o)
                      , M = this.terrainBiomeAt(m)
                      , T = this.terrainBiomeAt(g)
                      , E = this.evaluateColor(m, y, M)
                      , A = this.evaluateColor(g, x, T);
                    S.setXYZ(n, ...this._weightColor(E, h)),
                    S.setXYZ(n + 1, ...this._weightColor(E, u)),
                    S.setXYZ(n + 2, ...this._weightColor(E, d)),
                    S.setXYZ(n + 3, ...this._weightColor(A, d)),
                    S.setXYZ(n + 4, ...this._weightColor(A, f)),
                    S.setXYZ(n + 5, ...this._weightColor(A, h))
                }
            o && (x.computeVertexNormals(!0),
            x.computeFaceNormals(),
            this.baseMesh = new i.Mesh(x,a),
            this.baseMesh.receiveShadow = !0,
            this.baseMesh.scale.set(s, s, 1),
            this.add(this.baseMesh)),
            this._raycastRay = new i.Ray,
            this._raycastTriA = new i.Vector3,
            this._raycastTriB = new i.Vector3,
            this._raycastTriC = new i.Vector3,
            this._raycastTriangle = new i.Triangle,
            this._raycastNormal = new i.Vector3,
            this._raycastTarget = new i.Vector3,
            this._raycastClosestTarget = new i.Vector3
        }
        terrainIndex(e, t) {
            let r = e + t * (this.xSegmentCount + 1);
            return 0 > r || r >= this.terrainHeights.length ? 0 : r
        }
        terrainHeight(e, t) {
            return this.terrainHeights[this.terrainIndex(e, t)]
        }
        terrainBiome(e, t) {
            let r = this.terrainIndex(e, t) * l;
            return this.terrainBiomes.slice(r, r + l)
        }
        terrainBiomeAt(e, t) {
            let r = Math.floor(e / this.xSegmentSize)
              , i = Math.ceil(e / this.xSegmentSize)
              , n = Math.floor(t / this.ySegmentSize)
              , s = Math.ceil(t / this.ySegmentSize);
            return (this.terrainBiome(r, n) + this.terrainBiome(i, n) + this.terrainBiome(r, s) + this.terrainBiome(i, s)) / 4
        }
        calcAOWeight(e, t) {
            let r = this._vertPos(e, this.xSegmentSize, this.sizeX)
              , i = this._vertPos(t, this.ySegmentSize, this.sizeY)
              , n = this._topAngleOnTerrain(r - this.xSegmentSize, this.terrainHeight(e - 1, t), r, this.terrainHeight(e, t), r + this.xSegmentSize, this.terrainHeight(e + 1, t))
              , s = this._topAngleOnTerrain(i - this.xSegmentSize, this.terrainHeight(e, t - 1), i, this.terrainHeight(e, t), i + this.ySegmentSize, this.terrainHeight(e, t + 1))
              , a = Math.PI
              , o = 1 - (1 - Math.max(a - n, 0) / a) * (1 - Math.max(a - s, 0) / a);
            return .5 <= o ? o = .65 : .2 <= o ? o = .3 : .1 <= o && (o = .25),
            o
        }
        _worldToLocal(e, t, r) {
            return (e + t / 2) / r
        }
        raycast(e, t, r, i, n, s, a=!1) {
            e /= this.sizeMlt,
            t /= this.sizeMlt,
            i /= this.sizeMlt,
            n /= this.sizeMlt;
            let o = Math.sqrt(i * i + n * n + s * s);
            this._raycastRay.origin.set(e, t, r),
            this._raycastRay.direction.set(i, n, s);
            let c, l, p, h = this._worldToLocal(e, this.sizeX, this.xSegmentSize), u = this._worldToLocal(t, this.sizeY, this.ySegmentSize), d = h + i / this.xSegmentSize, f = u + n / this.ySegmentSize, m = Math.abs(d - h), g = Math.abs(f - u), v = Math.floor(h), y = Math.floor(u), b = 1;
            for (0 == m ? (c = 0,
            p = Number.POSITIVE_INFINITY) : d > h ? (c = 1,
            b += Math.floor(d) - v,
            p = (Math.floor(h) + 1 - h) * g) : (c = -1,
            b += v - Math.floor(d),
            p = (h - Math.floor(h)) * g),
            0 == g ? (l = 0,
            p -= Number.POSITIVE_INFINITY) : f > u ? (l = 1,
            b += Math.floor(f) - y,
            p -= (Math.floor(u) + 1 - u) * m) : (l = -1,
            b += y - Math.floor(f),
            p -= (u - Math.floor(u)) * m); 0 < b; b--) {
                if (this._raycastVisit(v, y, e, t, r, i, n, s, o, a)) {
                    let e = this._raycastClosestTarget;
                    return e.x *= this.sizeMlt,
                    e.y *= this.sizeMlt,
                    e
                }
                0 < p ? (y += l,
                p -= m) : (v += c,
                p += g)
            }
        }
        _raycastVisit(e, t, r, i, n, s, a, o, c, l) {
            let p = e + t * this.xSegmentCount
              , h = Number.POSITIVE_INFINITY
              , u = !1;
            for (let e, t = 0; 2 > t; t++) {
                e = 6 * p + 3 * t,
                this._raycastTriA.set(this.vertPositions.getX(e), this.vertPositions.getY(e), this.vertPositions.getZ(e)),
                this._raycastTriB.set(this.vertPositions.getX(e + 1), this.vertPositions.getY(e + 1), this.vertPositions.getZ(e + 1)),
                this._raycastTriC.set(this.vertPositions.getX(e + 2), this.vertPositions.getY(e + 2), this.vertPositions.getZ(e + 2));
                let r = this._raycastRay.intersectTriangle(this._raycastTriA, this._raycastTriB, this._raycastTriC, !0, this._raycastTarget);
                if (r) {
                    let e = r.distanceTo(this._raycastRay.origin);
                    e < h && e < c && (h = e,
                    u = !0,
                    this._raycastClosestTarget.copy(r),
                    this._raycastTriangle.set(this._raycastTriA, this._raycastTriB, this._raycastTriC))
                }
            }
            return l && u && this._raycastTriangle.getNormal(this._raycastNormal),
            u
        }
        evaluate(e, t) {
            let r = 0;
            this.sampleIndex = 0;
            let i = [];
            for (let r = 0; r < l; r++)
                i.push(this._sample(e, t, 1300));
            let n = i.reduce((e,t)=>e + t, 0);
            i = (i = i.map((e,t)=>[t, e / n])).sort((e,t)=>t[1] - e[1]);
            let s = {}
              , [a,o] = i[0];
            s[a] = this._easeTerrain(o / (o + i[1][1]));
            for (let e = 1; e < i.length; e++) {
                let[t,r] = i[e];
                s[t] = this._easeTerrain(r / (o + r))
            }
            let p = this._sample(e, t, 300);
            r += 25 * (p = Math.floor(3 * p) / 3) * s[c.GRASS] * this.sizeMlt;
            let h = .4 + .3 * this._sample(e, t, 200);
            r += (1 - 2 * Math.abs(h - this._sample(e, t, 500))) * (.4 + 1.4 * this._sample(e, t, 400)) * (220 * this.mntMlt) * s[c.MOUNTAIN] * this.sizeMlt;
            let u = this._calcEdgeFade(e, this.sizeX) * this._calcEdgeFade(t, this.sizeY);
            return r *= u,
            r += 2e3 * (u - 1),
            (Math.abs(e) >= this.sizeX / 2 || Math.abs(t) >= this.sizeY / 2) && (r = -1e3),
            [r, s]
        }
        evaluateColor(e, t, r) {
            let i, n = e[2], s = Math.atan2(Math.abs(t[0]), Math.abs(t[2])), a = Math.atan2(Math.abs(t[1]), Math.abs(t[2]));
            return i = .85 >= (1 - s / (2 * Math.PI)) * (1 - a / (2 * Math.PI)) ? h.MOUNTAIN : 100 < n ? h.MOUNTAIN : 5 < n ? h.GRASS : h.DIRT
        }
        _sample(e, t, r) {
            return this.sampleIndex++,
            this.simplex.noise3D(e / r, t / r, 1e4 * this.sampleIndex) / 2 + .5
        }
        _easeTerrain(e) {
            return s.easeInOutQuint(s.easeInOutQuint(e))
        }
        _calcEdgeFade(e, t) {
            if (Math.abs(e) >= t / 2)
                return 0;
            let r = (Math.abs(e) - t / 2 + this.edgeSize) / this.edgeSize;
            return r = 1 - Math.max(r, 0),
            s.easeOutQuint(r)
        }
        _blendColors(e) {
            let t = Object.values(e).reduce((e,t)=>e + t, 0)
              , r = [0, 0, 0];
            for (let i in e) {
                let n = p[i]
                  , s = e[i] / t;
                for (let e = 0; 3 > e; e++)
                    r[e] += n[e] * s
            }
            return r
        }
        _vertPos(e, t, r) {
            return e * t - r / 2
        }
        _avgPos(e, t) {
            return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2, (e[2] + t[2]) / 2]
        }
        _centroid3D(e, t, r) {
            return [(e[0] + t[0] + r[0]) / 3, (e[1] + t[1] + r[1]) / 3, (e[2] + t[2] + r[2]) / 3]
        }
        _normal3D(e, t, r) {
            let i = r[0] - t[0]
              , n = r[1] - t[1]
              , s = r[2] - t[2]
              , a = e[0] - t[0]
              , o = e[1] - t[1]
              , c = e[2] - t[2]
              , l = n * c - s * o
              , p = s * a - i * c
              , h = i * o - n * a
              , u = Math.sqrt(l * l + p * p + h + h);
            return [l / u, p / u, h / u]
        }
        _topAngleOnTerrain(e, t, r, i, n, s) {
            let a = Math.atan2(t - i, e - r)
              , o = Math.atan2(s - i, n - r);
            return 0 > a && (a += 2 * Math.PI),
            a - o
        }
        _weightColor(e, t) {
            return e.map(e=>e * (1 - t))
        }
    }
    e.exports = m
}
, function(e, t, r) {
    const i = r(21)
      , n = r(4)
      , s = r(8)
      , a = 32;
    var o, c;
    const l = !0
      , p = "y"
      , h = [{
        stp: 0,
        col: null
    }, {
        stp: .5,
        col: null
    }, {
        stp: 1,
        col: null
    }]
      , u = 2.5
      , d = 1e3;
    class f extends n.Object3D {
        static fromConfig(e, t) {
            return new f(e.zoneSize,e.zoneSpeed,e.zoneCol0,e.zoneCol1,e.zoneCol2,t)
        }
        constructor(e, t, r, d, f, m) {
            if (super(),
            this._size = e || 50,
            this._shrink = u * (t || 1),
            m) {
                o || (o = (new n.TextureLoader).load(s.assetsUrl("/textures/zone_0.png"), e=>{
                    e.wrapS = n.RepeatWrapping,
                    e.wrapT = n.RepeatWrapping,
                    e.minFilter = n.NearestFilter,
                    e.magFilter = n.NearestFilter,
                    e.repeat.set(20, 20),
                    e.needsUpdate = !0
                }
                )),
                c || (c = new n.MeshBasicMaterial({
                    color: 16777215,
                    depthWrite: !1,
                    flatShading: !1,
                    map: o,
                    vertexColors: n.VertexColors,
                    side: n.DoubleSide,
                    transparent: !0,
                    opacity: .5
                })),
                h[0].col = new n.Color(r || i.zones.BR[0]),
                h[1].col = new n.Color(d || i.zone.BR[1]),
                h[2].col = new n.Color(f || i.zone.BR[2]);
                let e = new n.SphereGeometry(1,a,a);
                e.computeBoundingBox();
                let t = e.boundingBox
                  , u = (new n.Vector3).subVectors(t.max, t.min)
                  , m = ["a", "b", "c"]
                  , v = new n.Vector3
                  , y = 0;
                for (let r, i = 0; i < h.length - 1; i++) {
                    r = h[i + 1].stp - h[i].stp;
                    for (let n, s = 0; s < e.faces.length; s++) {
                        n = e.faces[s];
                        for (var g = 0; 3 > g; g++)
                            y = v.subVectors(e.vertices[n[m[g]]], t.min).divide(u)[p],
                            l && (y = 1 - y),
                            y >= h[i].stp && y <= h[i + 1].stp && (n.vertexColors[g] = h[i].col.clone().lerp(h[i + 1].col, (y - h[i].stp) / r))
                    }
                }
                e.computeVertexNormals(!0),
                e.computeFaceNormals(),
                this.baseMesh = new n.Mesh(e,c)
            }
            this.reset(),
            m && this.add(this.baseMesh)
        }
        shrink() {
            0 >= this.scale.x ? this.visible = !1 : (this.scale.x -= this._shrink,
            this.scale.z -= this._shrink)
        }
        animate(e) {
            this.baseMesh && this.baseMesh.material.map && (this.baseMesh.material.map.offset.y += 3e-5 * e)
        }
        update(e) {
            this.scale.set(e.x, d, e.z),
            0 >= this.scale.x && (this.visible = !1)
        }
        reset() {
            this.scale.set(this._size, d, this._size),
            this.visible = !0
        }
        isOutside(e) {
            return s.getDistance(e.x, e.z, this.position.x, this.position.z) > this.scale.x
        }
    }
    e.exports = f
}
, , function(e, t, r) {
    r(71)
}
, function(e, t) {
    e.exports = function(e) {
        if (!e.webpackPolyfill) {
            var t = Object.create(e);
            t.children || (t.children = []),
            Object.defineProperty(t, "loaded", {
                enumerable: !0,
                get: function() {
                    return t.l
                }
            }),
            Object.defineProperty(t, "id", {
                enumerable: !0,
                get: function() {
                    return t.i
                }
            }),
            Object.defineProperty(t, "exports", {
                enumerable: !0
            }),
            t.webpackPolyfill = 1
        }
        return t
    }
}
, function(e, t) {
    e.exports = function(e) {
        return function() {
            function t() {
                var e = {
                    objects: [],
                    object: {},
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    materialLibraries: [],
                    startObject: function(e, t) {
                        if (this.object && !1 === this.object.fromDeclaration)
                            return this.object.name = e,
                            void (this.object.fromDeclaration = !1 !== t);
                        var r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                        if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
                        this.object = {
                            name: e || "",
                            fromDeclaration: !1 !== t,
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: []
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function(e, t) {
                                var r = this._finalize(!1);
                                r && (r.inherited || 0 >= r.groupCount) && this.materials.splice(r.index, 1);
                                var i = {
                                    index: this.materials.length,
                                    name: e || "",
                                    mtllib: Array.isArray(t) && 0 < t.length ? t[t.length - 1] : "",
                                    smooth: void 0 === r ? this.smooth : r.smooth,
                                    groupStart: void 0 === r ? 0 : r.groupEnd,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function(e) {
                                        var t = {
                                            index: "number" == typeof e ? e : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return t.clone = this.clone.bind(t),
                                        t
                                    }
                                };
                                return this.materials.push(i),
                                i
                            },
                            currentMaterial: function() {
                                return 0 < this.materials.length ? this.materials[this.materials.length - 1] : void 0
                            },
                            _finalize: function(e) {
                                var t = this.currentMaterial();
                                if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3,
                                t.groupCount = t.groupEnd - t.groupStart,
                                t.inherited = !1),
                                e && 1 < this.materials.length)
                                    for (var r = this.materials.length - 1; 0 <= r; r--)
                                        0 >= this.materials[r].groupCount && this.materials.splice(r, 1);
                                return e && 0 === this.materials.length && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }),
                                t
                            }
                        },
                        r && r.name && "function" == typeof r.clone) {
                            var i = r.clone(0);
                            i.inherited = !0,
                            this.object.materials.push(i)
                        }
                        this.objects.push(this.object)
                    },
                    finalize: function() {
                        this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                    },
                    parseVertexIndex: function(e, t) {
                        var r = parseInt(e, 10);
                        return 3 * (0 <= r ? r - 1 : r + t / 3)
                    },
                    parseNormalIndex: function(e, t) {
                        var r = parseInt(e, 10);
                        return 3 * (0 <= r ? r - 1 : r + t / 3)
                    },
                    parseUVIndex: function(e, t) {
                        var r = parseInt(e, 10);
                        return 2 * (0 <= r ? r - 1 : r + t / 2)
                    },
                    addVertex: function(e, t, r) {
                        var i = this.vertices
                          , n = this.object.geometry.vertices;
                        n.push(i[e + 0], i[e + 1], i[e + 2]),
                        n.push(i[t + 0], i[t + 1], i[t + 2]),
                        n.push(i[r + 0], i[r + 1], i[r + 2])
                    },
                    addVertexPoint: function(e) {
                        var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                    },
                    addVertexLine: function(e) {
                        var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                    },
                    addNormal: function(e, t, r) {
                        var i = this.normals
                          , n = this.object.geometry.normals;
                        n.push(i[e + 0], i[e + 1], i[e + 2]),
                        n.push(i[t + 0], i[t + 1], i[t + 2]),
                        n.push(i[r + 0], i[r + 1], i[r + 2])
                    },
                    addColor: function(e, t, r) {
                        var i = this.colors
                          , n = this.object.geometry.colors;
                        n.push(i[e + 0], i[e + 1], i[e + 2]),
                        n.push(i[t + 0], i[t + 1], i[t + 2]),
                        n.push(i[r + 0], i[r + 1], i[r + 2])
                    },
                    addUV: function(e, t, r) {
                        var i = this.uvs
                          , n = this.object.geometry.uvs;
                        n.push(i[e + 0], i[e + 1]),
                        n.push(i[t + 0], i[t + 1]),
                        n.push(i[r + 0], i[r + 1])
                    },
                    addUVLine: function(e) {
                        var t = this.uvs;
                        this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                    },
                    addFace: function(e, t, r, i, n, s, a, o, c) {
                        var l = this.vertices.length
                          , p = this.parseVertexIndex(e, l)
                          , h = this.parseVertexIndex(t, l)
                          , u = this.parseVertexIndex(r, l);
                        if (this.addVertex(p, h, u),
                        void 0 !== i && "" !== i) {
                            var d = this.uvs.length;
                            p = this.parseUVIndex(i, d),
                            h = this.parseUVIndex(n, d),
                            u = this.parseUVIndex(s, d),
                            this.addUV(p, h, u)
                        }
                        if (void 0 !== a && "" !== a) {
                            var f = this.normals.length;
                            p = this.parseNormalIndex(a, f),
                            h = a === o ? p : this.parseNormalIndex(o, f),
                            u = a === c ? p : this.parseNormalIndex(c, f),
                            this.addNormal(p, h, u)
                        }
                        0 < this.colors.length && this.addColor(p, h, u)
                    },
                    addPointGeometry: function(e) {
                        this.object.geometry.type = "Points";
                        for (var t = this.vertices.length, r = 0, i = e.length; r < i; r++)
                            this.addVertexPoint(this.parseVertexIndex(e[r], t))
                    },
                    addLineGeometry: function(e, t) {
                        this.object.geometry.type = "Line";
                        for (var r = this.vertices.length, i = this.uvs.length, n = 0, s = e.length; n < s; n++)
                            this.addVertexLine(this.parseVertexIndex(e[n], r));
                        var a = 0;
                        for (s = t.length; a < s; a++)
                            this.addUVLine(this.parseUVIndex(t[a], i))
                    }
                };
                return e.startObject("", !1),
                e
            }
            function r(t) {
                this.manager = void 0 === t ? e.DefaultLoadingManager : t,
                this.materials = null
            }
            var i = /^[og]\s*(.+)?/
              , n = /^mtllib /
              , s = /^usemtl /;
            return r.prototype = {
                constructor: r,
                load: function(t, r, i, n) {
                    var s = this
                      , a = new e.FileLoader(s.manager);
                    a.setPath(this.path),
                    a.load(t, function(e) {
                        r(s.parse(e))
                    }, i, n)
                },
                setPath: function(e) {
                    return this.path = e,
                    this
                },
                setMaterials: function(e) {
                    return this.materials = e,
                    this
                },
                parse: function(r) {
                    console.time("OBJLoader");
                    var a = new t;
                    -1 !== r.indexOf("\r\n") && (r = r.replace(/\r\n/g, "\n")),
                    -1 !== r.indexOf("\\\n") && (r = r.replace(/\\\n/g, ""));
                    for (var o = r.split("\n"), c = "", l = "", p = [], h = "function" == typeof "".trimLeft, u = 0, d = o.length; u < d; u++)
                        if (c = o[u],
                        0 !== (c = h ? c.trimLeft() : c.trim()).length && "#" !== (l = c.charAt(0)))
                            if ("v" === l) {
                                var f = c.split(/\s+/);
                                switch (f[0]) {
                                case "v":
                                    a.vertices.push(parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3])),
                                    7 <= f.length && a.colors.push(parseFloat(f[4]), parseFloat(f[5]), parseFloat(f[6]));
                                    break;
                                case "vn":
                                    a.normals.push(parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3]));
                                    break;
                                case "vt":
                                    a.uvs.push(parseFloat(f[1]), parseFloat(f[2]))
                                }
                            } else if ("f" === l) {
                                for (var m, g = c.substr(1).trim().split(/\s+/), v = [], y = 0, b = g.length; y < b; y++)
                                    if (0 < (m = g[y]).length) {
                                        var w = m.split("/");
                                        v.push(w)
                                    }
                                var x = v[0];
                                for (y = 1,
                                b = v.length - 1; y < b; y++) {
                                    var M = v[y]
                                      , _ = v[y + 1];
                                    a.addFace(x[0], M[0], _[0], x[1], M[1], _[1], x[2], M[2], _[2])
                                }
                            } else if ("l" === l) {
                                var S = c.substring(1).trim().split(" ")
                                  , T = []
                                  , E = [];
                                if (-1 === c.indexOf("/"))
                                    T = S;
                                else
                                    for (var A, P = 0, O = S.length; P < O; P++)
                                        "" !== (A = S[P].split("/"))[0] && T.push(A[0]),
                                        "" !== A[1] && E.push(A[1]);
                                a.addLineGeometry(T, E)
                            } else if ("p" === l) {
                                var R = c.substr(1).trim().split(" ");
                                a.addPointGeometry(R)
                            } else if (null !== (p = i.exec(c))) {
                                var C = (" " + p[0].substr(1).trim()).substr(1);
                                a.startObject(C)
                            } else if (s.test(c))
                                a.object.startMaterial(c.substring(7).trim(), a.materialLibraries);
                            else if (n.test(c))
                                a.materialLibraries.push(c.substring(7).trim());
                            else {
                                if ("s" !== l) {
                                    if ("\0" === c)
                                        continue;
                                    throw new Error('THREE.OBJLoader: Unexpected line: "' + c + '"')
                                }
                                if (1 < (p = c.split(" ")).length) {
                                    var L = p[1].trim().toLowerCase();
                                    a.object.smooth = "0" !== L && "off" !== L
                                } else
                                    a.object.smooth = !0;
                                (Y = a.object.currentMaterial()) && (Y.smooth = a.object.smooth)
                            }
                    a.finalize();
                    var I = new e.Group;
                    I.materialLibraries = [].concat(a.materialLibraries);
                    for (u = 0,
                    d = a.objects.length; u < d; u++) {
                        var k = a.objects[u]
                          , D = k.geometry
                          , z = k.materials
                          , B = "Line" === D.type
                          , N = "Points" === D.type
                          , j = !1;
                        if (0 !== D.vertices.length) {
                            var F, U = new e.BufferGeometry;
                            U.addAttribute("position", new e.Float32BufferAttribute(D.vertices,3)),
                            0 < D.normals.length ? U.addAttribute("normal", new e.Float32BufferAttribute(D.normals,3)) : U.computeVertexNormals(),
                            0 < D.colors.length && (j = !0,
                            U.addAttribute("color", new e.Float32BufferAttribute(D.colors,3))),
                            0 < D.uvs.length && U.addAttribute("uv", new e.Float32BufferAttribute(D.uvs,2));
                            for (var G = [], H = 0, V = z.length; H < V; H++) {
                                var W = z[H]
                                  , Y = void 0;
                                if (null !== this.materials)
                                    if (Y = this.materials.create(W.name),
                                    !B || !Y || Y instanceof e.LineBasicMaterial) {
                                        if (N && Y && !(Y instanceof e.PointsMaterial)) {
                                            var Z = new e.PointsMaterial({
                                                size: 10,
                                                sizeAttenuation: !1
                                            });
                                            X.copy(Y),
                                            Y = Z
                                        }
                                    } else {
                                        var X = new e.LineBasicMaterial;
                                        X.copy(Y),
                                        X.lights = !1,
                                        Y = X
                                    }
                                Y || ((Y = B ? new e.LineBasicMaterial : N ? new e.PointsMaterial({
                                    size: 1,
                                    sizeAttenuation: !1
                                }) : new e.MeshPhongMaterial).name = W.name),
                                Y.flatShading = !W.smooth,
                                Y.vertexColors = j ? e.VertexColors : e.NoColors,
                                G.push(Y)
                            }
                            if (1 < G.length) {
                                for (H = 0,
                                V = z.length; H < V; H++)
                                    W = z[H],
                                    U.addGroup(W.groupStart, W.groupCount, H);
                                F = B ? new e.LineSegments(U,G) : N ? new e.Points(U,G) : new e.Mesh(U,G)
                            } else
                                F = B ? new e.LineSegments(U,G[0]) : N ? new e.Points(U,G[0]) : new e.Mesh(U,G[0]);
                            F.name = k.name,
                            I.add(F)
                        }
                    }
                    return console.timeEnd("OBJLoader"),
                    I
                }
            },
            r
        }()
    }
}
, function(e, t) {
    e.exports = function(e) {
        e.StrippedLambertMaterial = function(t) {
            let r = new e.ShaderMaterial({
                name: "lambert-stripped",
                uniforms: e.UniformsUtils.merge([e.ShaderLib.lambert.uniforms]),
                lights: !0,
                fog: !0,
                vertexShader: "\n#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n    varying vec3 vLightBack;\n    varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\nvoid main() {\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    #include <beginnormal_vertex>\n    // #include <morphnormal_vertex>\n    // #include <skinbase_vertex>\n    // #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <begin_vertex>\n    // #include <morphtarget_vertex>\n    // #include <skinning_vertex>\n    #include <project_vertex>\n    // #include <logdepthbuf_vertex>\n    // #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    // #include <envmap_vertex>\n    #include <lights_lambert_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n}\n",
                fragmentShader: "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n    varying vec3 vLightBack;\n    varying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n// #include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n// #include <envmap_pars_fragment>\n#include <bsdfs>  // Shading functions\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n// #include <specularmap_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n    // #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\n    // #include <logdepthbuf_fragment>\n    #include <map_fragment>\n    #include <color_fragment>\n    // #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    // #include <specularmap_fragment>\n    #include <emissivemap_fragment>\n\n    // accumulation\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n    #ifdef DOUBLE_SIDED\n\n        reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n    #else\n\n        reflectedLight.indirectDiffuse += vIndirectFront;\n\n    #endif\n\n    #include <lightmap_fragment>\n\n    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n    #ifdef DOUBLE_SIDED\n\n        reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n    #else\n\n        reflectedLight.directDiffuse = vLightFront;\n\n    #endif\n\n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n    // #include <envmap_fragment>\n\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n    // #include <tonemapping_fragment>\n    // #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    // #include <dithering_fragment>\n}\n    "
            });
            return Object.assign(r, new e.MeshLambertMaterial(t)),
            r.isMeshLambertMaterial = !0,
            r.setValues(t),
            r
        }
    }
}
, function(e, t, r) {
    var i;
    !function() {
        "use strict";
        function n(e) {
            var t;
            t = "function" == typeof e ? e : e ? a(e) : Math.random,
            this.p = s(t),
            this.perm = new Uint8Array(512),
            this.permMod12 = new Uint8Array(512);
            for (var r = 0; 512 > r; r++)
                this.perm[r] = this.p[255 & r],
                this.permMod12[r] = this.perm[r] % 12
        }
        function s(e) {
            var t, r = new Uint8Array(256);
            for (t = 0; 256 > t; t++)
                r[t] = t;
            for (t = 0; 255 > t; t++) {
                var i = t + ~~(e() * (256 - t))
                  , n = r[t];
                r[t] = r[i],
                r[i] = n
            }
            return r
        }
        function a() {
            var e = 0
              , t = 0
              , r = 0
              , i = 1
              , n = function() {
                var e = 4022871197;
                return function(t) {
                    t = t.toString();
                    for (var r = 0; r < t.length; r++) {
                        var i = .02519603282416938 * (e += t.charCodeAt(r));
                        i -= e = i >>> 0,
                        e = (i *= e) >>> 0,
                        e += 4294967296 * (i -= e)
                    }
                    return 2.3283064365386963e-10 * (e >>> 0)
                }
            }();
            e = n(" "),
            t = n(" "),
            r = n(" ");
            for (var s = 0; s < arguments.length; s++)
                0 > (e -= n(arguments[s])) && (e += 1),
                0 > (t -= n(arguments[s])) && (t += 1),
                0 > (r -= n(arguments[s])) && (r += 1);
            return n = null,
            function() {
                var n = 2091639 * e + 2.3283064365386963e-10 * i;
                return e = t,
                t = r,
                r = n - (i = 0 | n)
            }
        }
        var o = .5 * (Math.sqrt(3) - 1)
          , c = (3 - Math.sqrt(3)) / 6
          , l = 1 / 6
          , p = (Math.sqrt(5) - 1) / 4
          , h = (5 - Math.sqrt(5)) / 20;
        n.prototype = {
            grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
            grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
            noise2D: function(e, t) {
                var r, i, n = this.permMod12, s = this.perm, a = this.grad3, l = 0, p = 0, h = 0, u = (e + t) * o, d = Math.floor(e + u), f = Math.floor(t + u), m = (d + f) * c, g = e - (d - m), v = t - (f - m);
                g > v ? (r = 1,
                i = 0) : (r = 0,
                i = 1);
                var y = g - r + c
                  , b = v - i + c
                  , w = g - 1 + 2 * c
                  , x = v - 1 + 2 * c
                  , M = 255 & d
                  , _ = 255 & f
                  , S = .5 - g * g - v * v;
                if (0 <= S) {
                    var T = 3 * n[M + s[_]];
                    l = (S *= S) * S * (a[T] * g + a[T + 1] * v)
                }
                var E = .5 - y * y - b * b;
                if (0 <= E) {
                    var A = 3 * n[M + r + s[_ + i]];
                    p = (E *= E) * E * (a[A] * y + a[A + 1] * b)
                }
                var P = .5 - w * w - x * x;
                if (0 <= P) {
                    var O = 3 * n[M + 1 + s[_ + 1]];
                    h = (P *= P) * P * (a[O] * w + a[O + 1] * x)
                }
                return 70 * (l + p + h)
            },
            noise3D: function(e, t, r) {
                var i, n, s, a, o, c, p, h, u, d, f = this.permMod12, m = this.perm, g = this.grad3, v = (e + t + r) * (1 / 3), y = Math.floor(e + v), b = Math.floor(t + v), w = Math.floor(r + v), x = (y + b + w) * l, M = e - (y - x), _ = t - (b - x), S = r - (w - x);
                M >= _ ? _ >= S ? (o = 1,
                c = 0,
                p = 0,
                h = 1,
                u = 1,
                d = 0) : M >= S ? (o = 1,
                c = 0,
                p = 0,
                h = 1,
                u = 0,
                d = 1) : (o = 0,
                c = 0,
                p = 1,
                h = 1,
                u = 0,
                d = 1) : _ < S ? (o = 0,
                c = 0,
                p = 1,
                h = 0,
                u = 1,
                d = 1) : M < S ? (o = 0,
                c = 1,
                p = 0,
                h = 0,
                u = 1,
                d = 1) : (o = 0,
                c = 1,
                p = 0,
                h = 1,
                u = 1,
                d = 0);
                var T = M - o + l
                  , E = _ - c + l
                  , A = S - p + l
                  , P = M - h + 2 * l
                  , O = _ - u + 2 * l
                  , R = S - d + 2 * l
                  , C = M - 1 + .5
                  , L = _ - 1 + .5
                  , I = S - 1 + .5
                  , k = 255 & y
                  , D = 255 & b
                  , z = 255 & w
                  , B = .6 - M * M - _ * _ - S * S;
                if (0 > B)
                    i = 0;
                else {
                    var N = 3 * f[k + m[D + m[z]]];
                    i = (B *= B) * B * (g[N] * M + g[N + 1] * _ + g[N + 2] * S)
                }
                var j = .6 - T * T - E * E - A * A;
                if (0 > j)
                    n = 0;
                else {
                    var F = 3 * f[k + o + m[D + c + m[z + p]]];
                    n = (j *= j) * j * (g[F] * T + g[F + 1] * E + g[F + 2] * A)
                }
                var U = .6 - P * P - O * O - R * R;
                if (0 > U)
                    s = 0;
                else {
                    var G = 3 * f[k + h + m[D + u + m[z + d]]];
                    s = (U *= U) * U * (g[G] * P + g[G + 1] * O + g[G + 2] * R)
                }
                var H = .6 - C * C - L * L - I * I;
                if (0 > H)
                    a = 0;
                else {
                    var V = 3 * f[k + 1 + m[D + 1 + m[z + 1]]];
                    a = (H *= H) * H * (g[V] * C + g[V + 1] * L + g[V + 2] * I)
                }
                return 32 * (i + n + s + a)
            },
            noise4D: function(e, t, r, i) {
                var n, s, a, o, c, l, u, d, f, m, g, v, y, b, w, x, M, _ = this.perm, S = this.grad4, T = (e + t + r + i) * p, E = Math.floor(e + T), A = Math.floor(t + T), P = Math.floor(r + T), O = Math.floor(i + T), R = (E + A + P + O) * h, C = e - (E - R), L = t - (A - R), I = r - (P - R), k = i - (O - R), D = 0, z = 0, B = 0, N = 0;
                C > L ? D++ : z++,
                C > I ? D++ : B++,
                C > k ? D++ : N++,
                L > I ? z++ : B++,
                L > k ? z++ : N++,
                I > k ? B++ : N++;
                var j = C - (l = 3 <= D ? 1 : 0) + h
                  , F = L - (u = 3 <= z ? 1 : 0) + h
                  , U = I - (d = 3 <= B ? 1 : 0) + h
                  , G = k - (f = 3 <= N ? 1 : 0) + h
                  , H = C - (m = 2 <= D ? 1 : 0) + 2 * h
                  , V = L - (g = 2 <= z ? 1 : 0) + 2 * h
                  , W = I - (v = 2 <= B ? 1 : 0) + 2 * h
                  , Y = k - (y = 2 <= N ? 1 : 0) + 2 * h
                  , Z = C - (b = 1 <= D ? 1 : 0) + 3 * h
                  , X = L - (w = 1 <= z ? 1 : 0) + 3 * h
                  , q = I - (x = 1 <= B ? 1 : 0) + 3 * h
                  , J = k - (M = 1 <= N ? 1 : 0) + 3 * h
                  , K = C - 1 + 4 * h
                  , Q = L - 1 + 4 * h
                  , $ = I - 1 + 4 * h
                  , ee = k - 1 + 4 * h
                  , te = 255 & E
                  , re = 255 & A
                  , ie = 255 & P
                  , ne = 255 & O
                  , se = .6 - C * C - L * L - I * I - k * k;
                if (0 > se)
                    n = 0;
                else {
                    var ae = _[te + _[re + _[ie + _[ne]]]] % 32 * 4;
                    n = (se *= se) * se * (S[ae] * C + S[ae + 1] * L + S[ae + 2] * I + S[ae + 3] * k)
                }
                var oe = .6 - j * j - F * F - U * U - G * G;
                if (0 > oe)
                    s = 0;
                else {
                    var ce = _[te + l + _[re + u + _[ie + d + _[ne + f]]]] % 32 * 4;
                    s = (oe *= oe) * oe * (S[ce] * j + S[ce + 1] * F + S[ce + 2] * U + S[ce + 3] * G)
                }
                var le = .6 - H * H - V * V - W * W - Y * Y;
                if (0 > le)
                    a = 0;
                else {
                    var pe = _[te + m + _[re + g + _[ie + v + _[ne + y]]]] % 32 * 4;
                    a = (le *= le) * le * (S[pe] * H + S[pe + 1] * V + S[pe + 2] * W + S[pe + 3] * Y)
                }
                var he = .6 - Z * Z - X * X - q * q - J * J;
                if (0 > he)
                    o = 0;
                else {
                    var ue = _[te + b + _[re + w + _[ie + x + _[ne + M]]]] % 32 * 4;
                    o = (he *= he) * he * (S[ue] * Z + S[ue + 1] * X + S[ue + 2] * q + S[ue + 3] * J)
                }
                var de = .6 - K * K - Q * Q - $ * $ - ee * ee;
                if (0 > de)
                    c = 0;
                else {
                    var fe = _[te + 1 + _[re + 1 + _[ie + 1 + _[ne + 1]]]] % 32 * 4;
                    c = (de *= de) * de * (S[fe] * K + S[fe + 1] * Q + S[fe + 2] * $ + S[fe + 3] * ee)
                }
                return 27 * (n + s + a + o + c)
            }
        },
        n._buildPermutationTable = s,
        void 0 !== (i = function() {
            return n
        }
        .call(t, r, t, e)) && (e.exports = i),
        t.SimplexNoise = n,
        e.exports = n
    }()
}
, function(e, t) {
    e.exports.easing = {
        linear: function(e) {
            return e
        },
        easeInQuad: function(e) {
            return e * e
        },
        easeOutQuad: function(e) {
            return e * (2 - e)
        },
        easeInOutQuad: function(e) {
            return .5 > e ? 2 * e * e : (4 - 2 * e) * e - 1
        },
        easeInCubic: function(e) {
            return e * e * e
        },
        easeOutCubic: function(e) {
            return --e * e * e + 1
        },
        easeInOutCubic: function(e) {
            return .5 > e ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
        },
        easeInQuart: function(e) {
            return e * e * e * e
        },
        easeOutQuart: function(e) {
            return 1 - --e * e * e * e
        },
        easeInOutQuart: function(e) {
            return .5 > e ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e
        },
        easeInQuint: function(e) {
            return e * e * e * e * e
        },
        easeOutQuint: function(e) {
            return 1 + --e * e * e * e * e
        },
        easeInOutQuint: function(e) {
            return .5 > e ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e
        }
    }
}
, function(e, t, r) {
    var i, n, s = 0, a = function(e) {
        this.sid = s++,
        this.uid = e.uid,
        this.width = e.w,
        this.length = e.l,
        this.height = e.h,
        this.active = !e.startClosed,
        this.x = e.x,
        this.orgX = this.x,
        this.y = e.y,
        this.orgY = this.y,
        this.z = e.z,
        this.orgZ = this.z,
        this.xR = e.xR,
        this.yR = e.yR,
        this.zR = e.zR,
        this.dir = e.d,
        this.src = e.src,
        this.ramp = e.ramp,
        this.ladder = e.ladder,
        this.jumpPad = e.jumpPad,
        this.noShoot = e.noShoot,
        this.stepSrc = e.s,
        this.score = e.score,
        this.scoreP = e.scoreP,
        this.kill = e.kill,
        this.dummy = e.dummy,
        this.noVis = e.noVis,
        this.complexMesh = e.complexMesh,
        this.penetrable = e.penetrable,
        this.health = e.health,
        this.startHealth = e.health,
        this.transparent = e.transparent,
        this.boost = e.boost,
        this.boostDr = e.boostDr,
        this.aoMlt = e.aoM,
        this.team = e.team,
        this.flag = e.flag,
        this.trigger = e.trigger,
        this.pickup = e.pickup,
        this.orgPickup = e.orgPickup,
        this.pickupRep = e.pickupRep,
        this.meshRef = e.meshRef,
        this.checkpoint = e.checkpoint,
        this.singleUse = e.singleUse,
        this.isBorder = e.isBorder,
        this.node = e.node,
        this.channel = e.channel,
        this.teleporter = e.teleporter,
        this.telCooldown = 0,
        this.propID = e.propID,
        this.telStopMo = e.momentum,
        this.noAmb = e.noAmb,
        this.tRadius = e.tRadius,
        this.gate = e.gate,
        this.noMsg = e.noMsg,
        this.method = e.method,
        this.closeable = e.closeable,
        this.startClosed = e.startClosed,
        this.triggerEvent = e.event,
        this.triggerAction = e.action,
        this.triggerConstant = e.constant,
        e.eventN && (this[e.eventN] = !0),
        this.classIndx = e.classIndx,
        e.respawnT = 0 != e.respawnT && 100 > e.respawnT ? 100 : e.respawnT,
        this.respawnT = e.respawnT,
        this.respawnR = e.respawnR,
        this.respawnTStart = e.respawnT,
        this.canRespawn = !(!e.respawnR && !e.respawnT),
        this.skill = e.skill,
        this.hpMlt = e.hpMlt,
        this.destroyedBy = null,
        this.interface = e.interface,
        this.interfaceT = e.interfaceT,
        this.deposited = 0,
        this.withdrawAmnt = e.withdraw,
        this.depositAmnt = e.deposit,
        this.bank = e.bank,
        this.objLink = e.objLink
    };
    e.exports.manager = function(e, t, s) {
        var o, c;
        e && (i = r(38).prefabs,
        n = r(4)),
        this.aoOpac = 0,
        this.objects = [],
        this.objectives = [],
        this.flags = [],
        this.pickups = [],
        this.gates = [],
        this.banks = [],
        this.interfaces = [],
        this.teleporters = [],
        this.spectateCams = {},
        this.collision = function(e, t, r) {
            return e.x - e.width - r <= t.x + t.width && e.x + e.width + r >= t.x - t.width && e.z - e.length - r <= t.z + t.length && e.z + e.length + r >= t.z - t.length && e.y - e.height - r <= t.y + t.height && e.y + e.height + r >= t.y - t.height
        }
        ,
        this.checkPos = function(e, r, i, n, s) {
            for (var a = 0; a < this.objects.length; ++a)
                if (this.objects[a] != n && this.objects[a] != s && !this.objects[a].ramp && t.pointInBox3D(e, r, i, this.objects[a]))
                    return !1;
            return !0
        }
        ,
        this.findByUid = function(e, t) {
            o = t || this.objects;
            for (var r = 0; r < o.length; ++r)
                if (o[r].uid === e)
                    return o[r];
            return null
        }
        ,
        this.findBySid = function(e, t) {
            o = t || this.objects;
            for (var r = 0; r < o.length; ++r)
                if (o[r].sid === e)
                    return o[r];
            return null
        }
        ,
        this.addCylinder = function(t, r, i, n, s, a) {
            e && (a.shadows = !0,
            e.addCylinder(t, r, i, n, s, a))
        }
        ,
        this.getZoneDat = function(e, t) {
            return {
                src: "zone_r",
                texSrc: "zone_" + (t && e == t.team ? "b" : "r"),
                noGroup: !0,
                mat: n.MeshBasicMaterial,
                transparent: !0,
                depthWrite: !1,
                side: 2
            }
        }
        ,
        this.getFlagDat = function(e, t) {
            var r = t && e == t.team ? "1" : "0";
            return {
                src: "crystal_0",
                texSrc: "crystal_" + r,
                noGroup: !0,
                noShadow: !0,
                noFog: !0,
                emissive: "0" == r ? 8729652 : 4360861
            }
        }
        ,
        this.addFlag = function(t, r, i, n) {
            var o = null;
            e && ((o = e.loadMesh(this.getFlagDat(n), t, r + s.flagOff, i, 0, s.flagScale, e.scene)).layers.set(2),
            o.zoneMesh = e.addCube(t, r, i, s.flagZoneS, s.flagZoneH, s.flagZoneS, [1, 1, 0, 0, 1, 1], this.getZoneDat(n)));
            var c = new a({
                uid: this.objects.length,
                meshRef: o,
                x: t,
                z: i,
                y: r + s.flagScale / 2 + s.flagOff,
                w: s.flagScale,
                l: s.flagScale,
                h: s.flagScale / 2,
                team: n,
                flag: !0,
                noShoot: !0,
                complexMesh: !0
            });
            this.flags.push(c),
            this.objects.push(c);
            var l = new a({
                x: t,
                z: i,
                y: r + s.flagZoneH / 2,
                w: s.flagZoneS / 2,
                l: s.flagZoneS / 2,
                h: s.flagZoneH / 2,
                team: n,
                trigger: !0,
                noShoot: !0,
                complexMesh: !0
            });
            l.flagObj = c,
            this.objects.push(l)
        }
        ,
        this.addWeapon = function(t, r, i, o, c, l, p) {
            o = o || {};
            var h = null;
            e && ((h = e.loadMesh({
                src: "weapons/" + o.weapon.src,
                texSrc: "weapons/" + o.weapon.src,
                tFilter: n.LinearFilter,
                noGroup: !0,
                uv2: !0,
                noShadow: !0,
                shininess: o.weapon.shine || 60,
                specular: 2697513,
                transparent: o.weapon.seeThrough,
                emissive: o.weapon.transp ? 16777215 : null
            }, t, r + s.pickupOff, i, 0, o.weapon.scale, e.scene)).rotateY(c || 0),
            h.rotateX((l || 0) - Math.PI / 2),
            h.rotateZ(p || 0));
            var u = new a({
                uid: this.objects.length,
                meshRef: h,
                x: t,
                z: i,
                y: r + s.pickupZoneH / 2,
                w: s.pickupZoneX,
                l: s.pickupZoneZ,
                h: 2 * s.pickupZoneH,
                pickup: o.weaponId,
                pickupRep: !o.noRep,
                orgPickup: o.weaponId,
                scoreP: o.scoreP,
                noMsg: o.noMsg,
                method: o.method,
                trigger: !0,
                noShoot: !0,
                complexMesh: !0
            });
            this.pickups.push(u),
            this.objects.push(u)
        }
        ,
        this.addObjective = function(t, r, i, s, a, o, c) {
            var l;
            e && ((l = e.addCube(t, r, i, s, o, a, [1, 1, 0, 0, 1, 1], {
                src: "objective_0",
                noGroup: !0,
                mat: n.MeshBasicMaterial,
                transparent: !0,
                depthWrite: !1,
                side: 2
            })).visible = !1),
            this.objectives.push({
                x: t,
                z: i,
                y: r + o / 2,
                mesh: l,
                width: s / 2,
                length: a / 2,
                height: o / 2,
                objLink: c || 0
            })
        }
        ,
        this.addDeathZone = function(e, t, r, i, n, s) {
            this.objects.push(new a({
                x: e,
                z: r,
                y: t + s / 2,
                w: i / 2,
                l: n / 2,
                h: s / 2,
                kill: !0,
                noShoot: !0,
                complexMesh: !0
            }))
        }
        ,
        this.addScoreZone = function(e, t, r, i, n, s, o) {
            this.objects.push(new a({
                x: e,
                z: r,
                y: t + s / 2,
                w: i / 2,
                l: n / 2,
                h: s / 2,
                score: !0,
                scoreP: o,
                noShoot: !0,
                complexMesh: !0
            }))
        }
        ,
        this.addCheckPoint = function(e, t, r, i, n, s, o, c) {
            this.objects.push(new a({
                x: e,
                z: r,
                y: t + s / 2,
                w: i / 2,
                l: n / 2,
                h: s / 2,
                d: parseInt(c) || 0,
                checkpoint: !0,
                singleUse: o,
                noShoot: !0,
                complexMesh: !0
            }))
        }
        ,
        this.addTeleporter = function(e, t, r, i, n, s, o, c, l) {
            var p = new a({
                uid: this.objects.length,
                x: e,
                z: r,
                y: t + s / 2,
                w: i / 2,
                l: n / 2,
                h: s / 2,
                teleporter: !0,
                channel: o || 0,
                node: c || 0,
                momentum: l,
                noShoot: !0,
                complexMesh: !0
            });
            this.objects.push(p),
            this.teleporters.push(p)
        }
        ,
        this.addGrass = function(t, r, i, s, a, o, c) {
            c = c || {},
            e && !c.noVis && (c.side = n.DoubleSide,
            c.transparent = !0,
            c.alphaTest = .2,
            c.vertexColors = n.VertexColors,
            c.shadowsR = !0,
            c.noGroup = !!c.health,
            e.addGrass(t, r, i, s, a, o, c))
        }
        ,
        this.addLadder = function(r, i, c, l, p, h, u, d) {
            var f = s.ladderScale
              , m = s.ladderScale;
            if (0 == p || p == Math.PI ? m = s.ladderWidth : f = s.ladderWidth,
            o = new a({
                ladder: !0,
                complexMesh: !0,
                noShoot: !0,
                d: p,
                x: r + s.ladderScale * Math.cos(p),
                z: c + s.ladderScale * Math.sin(p),
                y: i,
                w: f,
                l: m,
                h: l
            }),
            this.objects.push(o),
            e && !h) {
                var g = {
                    src: u || "floor_0",
                    vertexColors: n.VertexColors,
                    colr: d,
                    scale: .02,
                    amb: s.ambientVal,
                    shadows: !0
                };
                e.addCube(o.x + s.ladderWidth * Math.sin(p), o.y, o.z + s.ladderWidth * Math.cos(p), 2 * s.ladderScale, l + 2, 2 * s.ladderScale, [1, 1, 1, 1, 1, 1], g),
                e.addCube(o.x - s.ladderWidth * Math.sin(p), o.y, o.z - s.ladderWidth * Math.cos(p), 2 * s.ladderScale, l + 2, 2 * s.ladderScale, [1, 1, 1, 1, 1, 1], g);
                for (var v = Math.floor(l / 6), y = 0; y < v; ++y)
                    g.dark = .6 + y / v * .4,
                    e.addPlane(o.x, i + 6 * (y + 1) + t.randFloat(-1, 1), o.z, s.ladderWidth, s.ladderScale, g, -p + Math.PI / 2, Math.PI / 2, t.randFloat(-.1, .1))
            }
        }
        ,
        this.addRamp = function(t, r, i, o, c, l, p, h, u, d, f, m, g, v, y, b) {
            var w = 0 != p && p != Math.PI
              , x = (w ? l : o) / 2
              , M = Math.sqrt(c * c + l * l)
              , _ = Math.asin(c / M);
            if (this.objects.push(new a({
                x: t,
                z: i,
                y: r + c / 2,
                w: o / 2,
                l: l / 2,
                h: c / 2,
                d: p,
                noShoot: !0,
                complexMesh: !0,
                boostDr: h ? _ : null,
                boost: h || null,
                ramp: {
                    sX: t - x * Math.cos(p),
                    sZ: i - x * Math.sin(p),
                    eX: t + x * Math.cos(p),
                    eZ: i + x * Math.sin(p)
                },
                noAmb: y
            })),
            e && !d) {
                var S = {
                    src: u || "default",
                    vertexColors: n.VertexColors,
                    colr: f,
                    scale: 1,
                    shadowsR: !0,
                    side: n.DoubleSide,
                    movT: g,
                    movD: v,
                    emissive: b
                };
                if (S.transparent = "link_0" == S.src,
                "link_0" == S.src && (S.depthWrite = !0,
                S.alphaTest = S.transparent ? .02 : 0),
                e.addRamp(t, r, i, w ? o : l, c, (w ? l : o) / 2, p, S),
                !y) {
                    r += s.ambOff;
                    var T = (w ? o : l) / 2 - m;
                    w ? o = 2 * m : l = 2 * m;
                    for (var E, A = 0; 2 > A; ++A)
                        E = A ? 1 : -1,
                        e.addRamp(t + T * E * Math.cos(p + Math.PI / 2), r, i + T * E * Math.sin(p + Math.PI / 2), w ? o : l, c, (w ? l : o) / 2, p, {
                            src: "ambient_1",
                            euler: "ZYX",
                            depthWrite: !1,
                            transparent: !0,
                            side: n.DoubleSide
                        }, A ? 0 : Math.PI)
                }
            }
        }
        ,
        this.addGate = function(t, r, i, s, o, c, l) {
            (l = l || {}).src = l.src || "wall_0";
            var p = new a({
                x: t,
                z: i,
                y: r + c / 2,
                w: s / 2,
                l: o / 2,
                h: c / 2,
                uid: this.objects.length,
                src: l.src,
                noVis: l.noVis,
                noAmb: l.noAmb,
                transparent: l.transparent,
                penetrable: l.penetrable,
                isBorder: l.isBorder,
                complexMesh: l.xR || l.yR || l.zR || "link_0" == l.src,
                ter: !0,
                tRadius: 7,
                gate: !0,
                scoreP: l.scoreP,
                noMsg: l.noMsg,
                method: l.method,
                closeable: l.closeable,
                startClosed: l.startClosed && l.closeable,
                interface: l.interface
            });
            if (l.interface && this.interfaces.push(p.uid),
            e && !l.noVis) {
                l.transparent = "link_0" == l.src || 1 != l.opacity,
                "link_0" == l.src && (l.depthWrite = 1 == l.opacity,
                l.alphaTest = l.transparent ? .02 : 0),
                l.vertexColors = n.VertexColors,
                l.scale = null == l.scale ? 1 : l.scale,
                l.shadows = !l.shadowsR && 1 == l.opacity,
                l.noGroup = !0;
                var h = e.addCube(t, r, i, s, c, o, [1, 1, 1, 1, 1, 1], l);
                p.meshRef = h
            }
            this.objects.push(p),
            this.gates.push(p)
        }
        ,
        this.addBank = function(t, r, i, s, o, c, l) {
            (l = l || {}).src = l.src || "wall_0";
            var p = new a({
                x: t,
                z: i,
                y: r + c / 2,
                w: s / 2,
                l: o / 2,
                h: c / 2,
                uid: this.objects.length,
                src: l.src,
                noVis: l.noVis,
                noAmb: l.noAmb,
                transparent: l.transparent,
                penetrable: l.penetrable,
                isBorder: l.isBorder,
                complexMesh: l.xR || l.yR || l.zR || "link_0" == l.src,
                ter: !0,
                tRadius: 7,
                bank: !0,
                interface: l.interface,
                withdraw: Math.abs(l.withdraw),
                deposit: Math.abs(l.deposit)
            });
            l.interface && this.interfaces.push(p.uid),
            e && !l.noVis && (l.transparent = "link_0" == l.src || 1 != l.opacity,
            "link_0" == l.src && (l.depthWrite = 1 == l.opacity,
            l.alphaTest = l.transparent ? .02 : 0),
            l.vertexColors = n.VertexColors,
            l.scale = null == l.scale ? 1 : l.scale,
            l.shadows = !l.shadowsR && 1 == l.opacity,
            e.addCube(t, r, i, s, c, o, [1, 1, 1, 1, 1, 1], l)),
            this.objects.push(p),
            this.banks.push(p)
        }
        ,
        this.addTrigger = function(t, r, i, s, o, c, l) {
            (l = l || {}).src = l.src || "wall_0";
            var p = new a({
                x: t,
                z: i,
                y: r + c / 2,
                w: s / 2,
                l: o / 2,
                h: c / 2,
                uid: this.objects.length,
                src: l.src,
                noVis: l.noVis,
                noAmb: l.noAmb,
                health: l.health,
                respawnT: l.respawnT,
                respawnR: l.respawnR,
                transparent: l.transparent,
                complexMesh: l.xR || l.yR || l.zR || "link_0" == l.src,
                ter: !0,
                constant: l.constant,
                eventN: l.eventN,
                event: l.event,
                action: l.action,
                interface: l.interface,
                interfaceT: l.interfaceT
            });
            if (l.interface && this.interfaces.push(p.uid),
            e && !l.noVis) {
                l.transparent = "link_0" == l.src || 1 != l.opacity,
                "link_0" == l.src && (l.depthWrite = 1 == l.opacity,
                l.alphaTest = l.transparent ? .02 : 0),
                l.vertexColors = n.VertexColors,
                l.scale = null == l.scale ? 1 : l.scale,
                l.shadows = !l.shadowsR && 1 == l.opacity,
                l.noGroup = !!l.health;
                var h = e.addCube(t, r, i, s, c, o, [1, 1, 1, 1, 1, 1], l);
                l.health && !l.noCol && (p.meshRef = h)
            }
            this.objects.push(p)
        }
        ,
        this.addAI = function(e, t, r, i, n) {
            i = i || {};
            var s = new a({
                x: e,
                z: r,
                y: t + h / 2,
                w: 5,
                l: 5,
                h: 10,
                d: n,
                uid: this.objects.length,
                classIndx: i.classIndx,
                respawnT: i.respawnT,
                respawnR: i.respawnR,
                skill: i.skill,
                hpMlt: i.hpMlt
            });
            this.objects.push(s)
        }
        ,
        this.addLightCone = function(t, r, i, s, a, o, c) {
            (c = c || {}).src = "lightcone_0",
            e && !c.noVis && (c.depthWrite = !1,
            c.scale = null == c.scale ? 1 : c.scale,
            c.shadows = !1,
            c.side = n.DoubleSide,
            c.blending = n.AdditiveBlending,
            c.mat = n.MeshBasicMaterial,
            c.vertexColors = n.VertexColors,
            e.addCone(t, r, i, s, o, a, c))
        }
        ,
        this.addBlock = function(t, r, i, s, o, c, l, p) {
            if ((p = p || {}).src = p.src || "wall_0",
            p.noCol || this.objects.push(new a({
                x: t,
                z: i,
                y: r + c / 2,
                w: s / 2,
                l: o / 2,
                h: c / 2,
                uid: this.objects.length,
                s: p.sound,
                src: p.src,
                noVis: p.noVis,
                noAmb: p.noAmb,
                health: p.health,
                respawnT: p.respawnT,
                respawnR: p.respawnR,
                transparent: p.transparent,
                penetrable: p.penetrable,
                isBorder: p.isBorder,
                complexMesh: p.xR || p.yR || p.zR || "link_0" == p.src,
                ter: !0,
                trigger: p.trig,
                interface: p.interface
            })),
            p.interface && !p.noCol && this.interfaces.push(this.objects.length - 1),
            e && !p.noVis) {
                p.transparent = "link_0" == p.src || 1 != p.opacity,
                "link_0" == p.src && (p.depthWrite = 1 == p.opacity,
                p.alphaTest = p.transparent ? .02 : 0),
                p.vertexColors = n.VertexColors,
                p.scale = null == p.scale ? 1 : p.scale,
                p.shadows = !p.shadowsR && 1 == p.opacity,
                p.noGroup = !!p.health;
                var h = e.addCube(t, r, i, s, c, o, l, p);
                p.health && !p.noCol && (this.objects[this.objects.length - 1].meshRef = h)
            }
        }
        ,
        this.addCanvas = function(r, i, s, a, o, c, l, p, h) {
            c = c || {},
            e && (c.canvas = t.createCanvasText(2 * o, 2 * a, c.text || "Hello World", c.fontSize || 10, c.fcolr || "#000", c.bcolr || "#fff", c.noBVis, c.tAlign || 0),
            c.transparent = !0,
            c.depthWrite = !0,
            c.alphaTest = .02,
            c.side = n.DoubleSide,
            e.addPlane(r, i, s, o, a, c, l, (p || 0) + Math.PI / 2, h))
        }
        ,
        this.addSpectateCam = function(e, t, r, i) {
            (i = i || {}).objLink = i.objLink || 0,
            this.spectateCams[i.objLink] || (this.spectateCams[i.objLink] = []),
            this.spectateCams[i.objLink].push(new a({
                x: e,
                z: r,
                y: t + 5,
                xR: i.xR,
                yR: i.yR,
                zR: i.zR
            }))
        }
        ,
        this.addMesh = function(r, o, c, l, p, h, u, d) {
            if (o += h,
            (d = d || {}).noCol || this.objects.push(new a({
                complexMesh: !!i && i[d.src.toUpperCase()].complex,
                aoM: i && i[d.src.toUpperCase()].aoMlt || 0,
                propID: 0 <= s.propsH.indexOf(d.src) ? d.src : null,
                x: r,
                z: c,
                y: o,
                w: p,
                l: u,
                h: h,
                uid: this.objects.length,
                ter: !0,
                noVis: d.noVis,
                noAmb: d.noAmb,
                health: d.health,
                respawnT: d.respawnT,
                respawnR: d.respawnR,
                interface: d.interface
            })),
            d.interface && !d.noCol && this.interfaces.push(this.objects.length - 1),
            i && i[d.src.toUpperCase()].transparent && (o += t.randFloat(-.01, .01)),
            e && !d.noVis) {
                var f = e.loadMesh({
                    src: d.src + "_0",
                    emissive: i[d.src.toUpperCase()].emiss ? 16777215 : null,
                    side: i[d.src.toUpperCase()].doubleSide ? n.DoubleSide : n.FrontSide,
                    transparent: i[d.src.toUpperCase()].transparent,
                    shadows: i[d.src.toUpperCase()].castShadow,
                    shadowsR: i[d.src.toUpperCase()].receiveShadow,
                    vertexColors: n.VertexColors,
                    color: d.colr || 16777215,
                    noGroup: !!d.health
                }, r, o, c, l, s[d.src + "Scale"], e.scene, !d.health);
                d.health && !d.noCol && (this.objects[this.objects.length - 1].meshRef = f)
            }
        }
        ;
        var l = [];
        this.addNoisePlanes = function() {
            for (var t = 0; t < l.length; ++t) {
                l[t][5].objects = this.objects;
                var r = e.addPlane(...l[t]);
                10 == l[t].length && (this.objects[l[t][9]].meshRef = r)
            }
            l.length = 0
        }
        ,
        this.addPlane = function(t, r, i, s, o, c, p, h, u) {
            if ((c = c || {}).noCol || this.objects.push(new a({
                x: t,
                z: i,
                y: r,
                w: o,
                l: s,
                h: 0,
                uid: this.objects.length,
                s: c.sound,
                health: c.health,
                respawnT: c.respawnT,
                respawnR: c.respawnR,
                transparent: c.transparent,
                penetrable: c.penetrable,
                noVis: c.noVis,
                noAmb: c.noAmb,
                interface: c.interface
            })),
            c.interface && !c.noCol && this.interfaces.push(this.objects.length - 1),
            e && !c.noVis) {
                c.transparent = !0,
                c.side = n.DoubleSide,
                c.vertexColors = n.VertexColors,
                c.noGroup = !!c.health,
                c.noise && (c.pinEdges = !0,
                c.margin = 5,
                c.tilesX = Math.round(o / 5),
                c.tilesZ = Math.round(s / 5));
                var d = [t, r, i, o, s, c, p, (h || 0) + Math.PI / 2, u];
                if (c.noise)
                    c.health && !c.noCol && d.push(this.objects.length - 1),
                    l.push(d);
                else {
                    var f = e.addPlane(...d);
                    c.health && !c.noCol && (this.objects[this.objects.length - 1].meshRef = f)
                }
            }
        }
        ,
        this.pointInObjs = function(e, r, i) {
            for (var n = 0; n < this.objects.length; ++n)
                if (!(o = this.objects[n]).noVis && !o.complexMesh && !o.health && 0 > r.indexOf(o.sid) && t.pointInBox3D(e[0], e[1], e[2], o, i || 0))
                    return !0;
            return !1
        }
        ,
        this.setMaxAO = function(e, t, r) {
            e.maxAOS = e.maxAOS || {},
            e.maxAOS[t.sid] = Math.max(r, e.maxAOS[t.sid] || 0),
            t.maxAOS = t.maxAOS || {},
            t.maxAOS[e.sid] = Math.max(r, t.maxAOS[e.sid] || 0)
        }
        ,
        this.aosToAdd = {},
        this.addAmbient = function(e, r, i, n, a, o, c, l, p, h, u) {
            var d = !h;
            if (h)
                for (var f = 0; f < h.length; ++f)
                    if (t.pointInBox3D(e, r, i, h[f], 2 * s.ambOff)) {
                        d = !0;
                        break
                    }
            if (d)
                if (h) {
                    var m = h[0].sid + "-" + h[1].sid;
                    this.aosToAdd[m] || (this.aosToAdd[m] = []),
                    this.aosToAdd[m].push({
                        vals: [e, r, i, n, a, o, c + s.ambOff, l + s.ambOff, p],
                        group: u
                    })
                } else
                    this.addPlane(e, r, i, c, l, {
                        src: "ambient_" + (p || 0),
                        euler: "ZYX",
                        depthWrite: !1,
                        noCol: !0
                    }, n, a, o)
        }
        ;
        var p = [["g6-1-2", "g4-1-2"], ["g5-1-2", "g4-0-1"], ["g6-0-1", "g3-1-2"], ["g5-0-1", "g3-0-1"], ["g6-0-3", "g2-0-3"], ["g5-0-3", "g2-1-1"], ["g6-1-1", "g1-0-3"], ["g5-1-1", "g1-1-1"], ["g6-0-2", "g1-1-0"], ["g5-0-2", "g1-0-2"], ["g6-1-0", "g2-1-0"], ["g5-1-0", "g2-0-2"], ["g4-0-2", "g1-0-0"], ["g3-0-2", "g1-1-3"], ["g4-1-0", "g2-0-0"], ["g3-1-0", "g2-1-3"], ["g4-0-3", "g2-1-2"], ["g3-0-3", "g2-0-1"], ["g4-1-1", "g1-1-2"], ["g3-1-1", "g1-0-1"], ["g6-1-3", "g3-0-0"], ["g5-1-3", "g3-1-3"], ["g6-0-0", "g4-0-0"], ["g5-0-0", "g4-1-3"]];
        this.groupsMatch = function(e, t) {
            for (var r = 0; r < p.length; ++r)
                if (0 <= p[r].indexOf(e) && 0 <= p[r].indexOf(t))
                    return !0;
            return !1
        }
        ,
        this.clearAOGroup = function(e) {
            for (var t = e.length - 1; 0 <= t; --t) {
                o = e[t];
                for (var r = e.length - 1; 0 <= r; --r)
                    if (c = e[r],
                    !o.dontAdd && !c.dontAdd && o != c && this.groupsMatch(o.group, c.group)) {
                        o.vals[6] + o.vals[7] >= c.vals[6] + c.vals[7] ? c.dontAdd = !0 : o.dontAdd = !0;
                        break
                    }
            }
        }
        ,
        this.addPendingAOs = function() {
            for (var e in this.aosToAdd)
                if (this.aosToAdd.hasOwnProperty(e)) {
                    this.clearAOGroup(this.aosToAdd[e]);
                    for (var t = 0; t < this.aosToAdd[e].length; ++t)
                        this.aosToAdd[e][t].dontAdd || this.addAmbient(...this.aosToAdd[e][t].vals)
                }
            this.aosToAdd = {}
        }
        ,
        this.limitAmb = function(e, r, i, n, s, a, o) {
            var c = [t.cdv[n]]
              , l = [t.cdv[s]];
            return e = i == -Math.PI / 2 || i == Math.PI + Math.PI / 2 ? Math.min(e, (r[s] - Math.min(a[s] - a[l], o[s] - o[l])) / 2) : i == Math.PI / 2 ? Math.min(e, (Math.max(a[s] + a[l], o[s] + o[l]) - r[s]) / 2) : 0 == i ? Math.min(e, (Math.max(a[n] + a[c], o[n] + o[c]) - r[n]) / 2) : Math.min(e, (r[n] - Math.min(a[n] - a[c], o[n] - o[c])) / 2)
        }
        ,
        this.resetAll = function() {
            this.aosToAdd = {};
            for (var t = 0; t < this.objects.length; ++t)
                this.objects[t].active = !this.objects[t].startClosed,
                this.objects[t].startHealth && (this.objects[t].health = this.objects[t].startHealth),
                this.objects[t].meshRef && (this.objects[t].meshRef.visible = !this.objects[t].startClosed);
            e && e.updateShadowMap()
        }
        ,
        this.removeAll = function() {
            this.objects.length = 0,
            this.objectives.length = 0,
            this.flags.length = 0,
            this.pickups.length = 0,
            this.teleporters.length = 0,
            this.spectateCams = {}
        }
    }
}
, function(e, t) {
    e.exports.wheels = [{
        name: "Starter",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 50,
        rarities: [75, 22, 3, 0, 0, 0]
    }, {
        name: "Elite",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 100,
        rarities: [50, 30, 15, 5, 0, 0]
    }, {
        name: "Heroic",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 500,
        rarities: [0, 48, 35, 14, 2.5, .5]
    }, {
        name: "Hunter",
        lab: {
            nm: "Snipers Only!",
            col: "#fab640"
        },
        itemTypes: [0],
        weaponType: 1,
        price: 600,
        rarities: [43, 33, 17, 6, 1, 0]
    }, {
        name: "Attire",
        lab: {
            nm: "Outfits Only!",
            col: "#ed4242"
        },
        itemTypes: [1, 2],
        price: 750,
        rarities: [43, 33, 16, 6, 2, 0]
    }, {
        name: "Free",
        free: !0,
        openURL: !0,
        minLvl: 5,
        price: 0,
        priceT: "Follow for a free Spin",
        rarities: [43, 33, 17, 6, 1, 0]
    }],
    e.exports.types = ["weapons/weapon_", "hats/hat_", "body/body_", "melee/melee_"],
    e.exports.purchases = [{
        val: 300,
        price: .99
    }, {
        val: 600,
        price: 1.79
    }, {
        val: 2600,
        price: 7.49
    }, {
        val: 7e3,
        price: 15.99
    }, {
        val: 2e4,
        price: 34.99,
        tag: "Popular!",
        tagCol: "#ed4242"
    }, {
        val: 6e4,
        tag: "Best Value!",
        tagCol: "#E040FB",
        price: 99.99
    }],
    e.exports.rarities = [{
        name: "Uncommon",
        rar: 60,
        color: "#b2f252"
    }, {
        name: "Rare",
        rar: 40,
        color: "#2196F3"
    }, {
        name: "Epic",
        rar: 25,
        color: "#E040FB"
    }, {
        name: "Legendary",
        rar: 10,
        color: "#FBC02D"
    }, {
        name: "Relic",
        rar: 2.5,
        color: "#ed4242"
    }, {
        name: "Contraband",
        rar: .5,
        color: "#292929"
    }, {
        name: "Unobtainable",
        noSpin: !0,
        rar: 0,
        color: "#fff53d"
    }],
    e.exports.previews = {
        1: {
            xOff: -2,
            yOff: -2.6,
            zRota: .2,
            scl: .001376794727638135
        },
        2: {
            xOff: -1.4,
            yOff: -.8,
            scl: .001148941748743716
        },
        3: {
            xOff: 0,
            yOff: 1,
            scl: .000676917226130652
        },
        4: {
            xOff: -1.5,
            yOff: .5,
            scl: .000940741507537686
        },
        5: {
            xOff: -.8,
            yOff: .5,
            scl: .00079312502512562
        },
        6: {
            xOff: -1,
            scl: .00099521137688442
        },
        7: {
            xOff: -1,
            yOff: -.9,
            scl: .001221518472361808
        },
        8: {
            xOff: -1,
            yOff: -.6,
            scl: .0012179208743718641
        },
        9: {
            xOff: -1.2,
            yOff: -1,
            scl: .0010676876984924638
        },
        10: {
            scl: 1.6
        },
        15: {
            scl: .00098426884422111
        }
    },
    e.exports.skins = items
}
, function(e, t, r) {
    var i;
    try {
        window && (i = r(4))
    } catch (e) {}
    var n = function(e, t, r, i, n, s) {
        var a;
        this.id = e,
        this.sentTo = [],
        this.inputs = [],
        this.spins = [],
        this.stateHistory = [],
        this.weaponMeshes = [],
        this.weaponGeos = {},
        this.legMeshes = [],
        this.armMeshes = [],
        this.lastInput = [],
        this.lastDeltas = [],
        this.reloads = [],
        this.ammos = [],
        this.ping = 0,
        this.pings = [],
        this.avgSpn = 0,
        this.score = 0,
        this.scoreObjs = {},
        this.checkPoint = null,
        this.checkPointList = [],
        this.lstDrs = [],
        this.convs = 0,
        this.timer = null,
        this.gameTimer = null,
        this.classScores = {},
        this.kills = 0,
        this.deaths = 0,
        this.assists = 0,
        this.melees = 0,
        this.setbacks = 0,
        this.caps = 0,
        this.deathStreak = 0,
        this.level = 0,
        this.lives = s.waitTimers && s.config && (s.config.lives || s.mode.lives) || 0,
        this.deltaAdd = 0,
        this.deltaDiv = 1,
        this.sprayIndex = 0,
        this.hatIndex = -1,
        this.backIndex = -1,
        this.meleeIndex = -1,
        this.skinColIndex = -1,
        this.attachIndex = 0,
        this.lastSpray = 0,
        this.lastInteract = 0,
        this.lastPicked = [],
        this.playTime = 0,
        this.sCount = 0,
        this.streaks = {},
        this.deathInfo = {},
        this.ELO = 0,
        this.weaponTier = 0,
        this.inputLock = !1,
        this.init = function(e, t, r, i, s, a) {
            this.x = e,
            this.y = t,
            this.z = r,
            this.stepSrc = null,
            this.name = i || "unknown",
            this.xVel = 0,
            this.yVel = 0,
            this.zVel = 0,
            this.lastInObj = 0,
            this.renderMinimal = !1,
            this.spins.length = 0,
            this.noMovTimer = 0,
            this.noMovT = 0,
            this.xDire = 0,
            this.yDire = 0,
            this.hitTimer = 0,
            this.ticker = 0,
            this.spread = 0,
            this.spreadPlus = 0,
            this.aimVal = 1,
            this.aimDir = 0,
            this.aimTime = 0,
            this.streak = 0,
            this.killStreak = 0,
            this.realKillStreak = 0,
            this.lastKill = 0,
            this.stateHistory.length = 0,
            this.lastInput.length = 0,
            this.swapTweenA = 0,
            this.dmgReceived = {},
            this.landBobY = 0,
            this.landBobYR = 0,
            this.jumpBobY = 0,
            this.slideTimer = 0,
            this.canSlide = !0,
            this.leanAnimX = 0,
            this.leanAnimY = 0,
            this.leanAnimZ = 0,
            this.bobAnimZ = 0,
            this.bobAnimY = 0,
            this.idleAnim = 0,
            this.inspecting = !1,
            this.inspectX = !1,
            this.stepVal = 0,
            this.stepChase = 0,
            this.stepDir = 1,
            this.stepDirR = 1,
            this.reward = 0,
            this.recoilAnim = 0,
            this.recoilAnimY = 0,
            this.recoilForce = 0,
            this.recoilTweenY = 0,
            this.recoilTweenYM = 0,
            this.recoilTweenZ = 0,
            this.burstCount = 0,
            this.jumpRot = 0,
            this.jumpRotM = 0,
            this.slideLegV = 0,
            this.recoilX = 0,
            this.recoilZ = 0,
            this.crouchVal = 0,
            this.onGround = !0,
            this.onLadder = !1,
            this.terrainSlipping = !1,
            this.rampFix = null,
            this.didJump = !1,
            this.jumpCooldown = 0,
            this.didShoot = !1,
            this.lodActive = !1,
            this.locked = !1,
            this.latestData = !1,
            this.airTime = 0,
            this.height = n.fvcbEmTb,
            this.headScale = n.cameraHeight,
            this.scale = n.FtNDoOPu,
            this.active = !0,
            this.interpolate = !1,
            this.isYou = s,
            this.sentTo.length = 0,
            this.inputSN = 0,
            this.inputs.length = 0,
            this.weaponIndex = 0,
            this.swapTime = 0,
            this.recon = !1,
            this.cnBSeen = !1,
            this.meleeAnim = {},
            this.isHacker = a,
            this.customLoadout = null,
            this.isHidden = !1,
            this.godMode = !1,
            this.lastPicked.length = 0,
            this.propID = 0,
            this.weaponTier = 0,
            this.inObject = null,
            this.inputFreq = 0
        }
        ,
        this.setClass = function(e, t, i, s) {
            s || (e.config && 0 > e.config.classes.indexOf(t) && (t != e.config.classes[0] && (this.skins = [-1, -1]),
            t = e.config.classes[0]),
            e.mode && (e.mode.noWeap && (t = 9),
            e.mode.teamClass && e.mode.teamClass[this.team] && (t = e.mode.teamClass[this.team],
            this.skins = [-1, -1]))),
            (null == t || null == t) && (t = e.classes.length - 1),
            this.classIndex = t,
            this.reloads.length = 0,
            this.ammos.length = 0,
            this.loadout = [e.classes[t].loadout[0]],
            !!e.config && e.config.noSecondary || (e.classes[t].secondary ? r.isNumber(i) && this.loadout.push(i) : this.secIndex = null),
            0 > this.loadout.indexOf(12) && this.loadout.push(12),
            this.speed = e.classes[t].speed || 1;
            for (var a = 0; a < this.loadout.length; ++a)
                this.reloads.push(0),
                this.ammos.push(e.weapons[this.loadout[a]].ammo);
            this.reloadTimer = 0,
            this.regenDelay = e.classes[t].regenDelay || n.regenDelay,
            this.maxHealth = e.classes[t].health * (e.config && e.config.healthMlt || 1),
            this.health = this.maxHealth,
            this.hpChase = 1,
            this.regen = e.mode && e.mode.noRegen || !e.config || !e.config.hpRegen ? 0 : e.classes[t].regen || n.regenVal
        }
        ,
        this.updateLoadout = function(e, i, n=!0, s, a) {
            this.weaponIndex = i,
            this.reloads.length = 0,
            this.ammos.length = 0,
            this.loadout = [s],
            this.skins = [-1, -1],
            r.isNumber(a) && this.loadout.push(a),
            r.isNumber(a) && (this.secIndex = a),
            0 > this.loadout.indexOf(12) && this.loadout.push(12);
            for (var o = 0; o < this.loadout.length; ++o)
                this.reloads.push(0),
                this.ammos.push(e.weapons[this.loadout[o]].ammo);
            this.customLoadout = [...this.loadout],
            n && this.active && t.regenMeshes(this)
        }
        ,
        this.resetInputs = function() {
            this.inputs.length = 0
        }
        ,
        this.procInputs = function(e, s, o, c) {
            this.recon = o;
            var l = Math.max(0, Math.min(e[1], n.dltMx)) / this.deltaDiv;
            this.inputSN = e[0];
            var p = r.getAngleDst(e[2], this.xDire);
            t.saveSpin(this, p);
            var h = !o && this.isYou;
            if (h && (this.leanAnimX -= p * n.leanSens,
            this.leanAnimX = r.limit(this.leanAnimX, n.leanMax),
            this.leanAnimY -= r.getAngleDst(e[3], this.yDire) * n.leanSens,
            this.leanAnimY = r.limit(this.leanAnimY, n.leanMax),
            this.leanAnimX && (this.leanAnimX *= Math.pow(n.leanPull, l)),
            this.leanAnimY && (this.leanAnimY *= Math.pow(n.leanPull, l)),
            this.leanAnimZ && (this.leanAnimZ *= Math.pow(n.leanPullZ, l)),
            this.bobAnimZ && (this.bobAnimZ *= Math.pow(n.bobPullZ, l)),
            this.bobAnimY && (this.bobAnimY *= Math.pow(n.bobPullY, l)),
            this.recoilX && (this.recoilX *= Math.pow(n.leanPull, l)),
            this.recoilZ && (this.recoilZ *= Math.pow(n.leanPull, l)),
            this.inspecting && this.inspectX < Math.PI / 2.8 && (this.inspectX += .1 * (Math.PI / 2.8 - this.inspectX))),
            this.xDire = s.map.config.camRot ? (e[2] || 0).round(3) : 0,
            this.yDire = s.map.config.camRot ? (e[3] || 0).round(3) : 0,
            this.yDire > Math.PI / 2 ? this.yDire = Math.PI / 2 : this.yDire < -Math.PI / 2 && (this.yDire = -Math.PI / 2),
            !c) {
                if (2 == e[11] ? t.swapMelee(this, o) : 1 == e[11] ? t.swapSecondary(this, o) : 3 == e[11] ? t.swapWeapon(this, null, null, void 0, 0, o) : e[10] && t.swapWeapon(this, e[10], !1, void 0, void 0, o),
                o || (this.recoilForce && (this.recoilAnim += this.recoilForce * l,
                this.recoilAnimY += this.recoilForce * (this.weapon.recoilY || 1) * (1 - .3 * this.crouchVal) * l,
                this.recoilForce *= Math.pow(this.weapon.recoverF, l)),
                this.recoilAnim && (this.recoilAnim *= Math.pow(this.weapon.recover, l)),
                this.recoilAnimY && (this.recoilAnimY *= Math.pow(this.weapon.recoverY || this.weapon.recover, l))),
                this.oldX = this.x,
                this.oldY = this.y,
                this.oldZ = this.z,
                this.weapon.zoom && "prop" != this.team && (!this.weapon.noAim || 0 < this.swapTime)) {
                    var u = 0 >= this.reloadTimer && 0 >= this.swapTime;
                    e[6] && 0 < this.aimVal && u ? (t.cancelInspect(this),
                    this.aimDir = 0,
                    this.aimVal -= 1 / (this.weapon.aimSpeed / l),
                    0 >= this.aimVal && (this.aimVal = 0,
                    this.isYou && !o && t.toggleAim(this, 1)),
                    this.isYou && !o && !this.weapon.scope && t.updateAim(this, 1 - this.aimVal)) : (!u || !e[6] && 1 > this.aimVal) && (this.aimDir = 1,
                    !this.aimVal && this.isYou && !o && t.toggleAim(this, 0),
                    this.aimVal += 1 / (this.weapon.aimSpeed / l),
                    1 <= this.aimVal && (this.aimVal = 1),
                    this.isYou && !o && !this.weapon.scope && t.updateAim(this, 1 - this.aimVal)),
                    0 == this.aimVal ? this.aimTime += l : this.aimTime = 0
                }
                e[8] && 1 > this.crouchVal && !this.onLadder ? (this.crouchVal += n.crouchSpeed * l,
                1 <= this.crouchVal && (this.crouchVal = 1),
                this.onGround ? h && (this.bobAnimY -= 1.4 * n.crouchAnim * l) : this.y += n.crouchSpeed * l) : !e[8] && 0 < this.crouchVal && (this.crouchVal -= n.crouchSpeed * l,
                0 >= this.crouchVal && (this.crouchVal = 0),
                this.onGround ? h && (this.bobAnimY += n.crouchAnim * l) : this.y -= n.crouchSpeed * l),
                this.crouchVal && (this.crouchVal = this.crouchVal.round(3)),
                t.updateHeight(this);
                var d, f = this.onGround || this.onLadder;
                d = f ? (this.terrainSlipping ? n.slippingSpeed : n.playerSpeed) * this.speed : n.airSpeed,
                d *= this.aimVal ? 1 : n.aimSlow,
                d *= s.mode.spdMlt && s.mode.spdMlt[this.team] || 1,
                d *= this.crouchVal ? n.crouchSlow : 1,
                d *= this.weapon.spdMlt * l;
                var m = 0;
                if (m = this.onLadder ? n.ladderDecel : this.terrainSlipping ? n.terrainSlipDecel : this.onTerrain ? n.terrainDecel : this.onGround ? n.groundDecel : n.airDecel,
                .5 >= this.crouchVal && (this.canSlide = !0),
                this.onGround && this.crouchVal || (this.slideTimer = 0),
                this.slideTimer)
                    if (this.slideTimer -= l,
                    0 >= this.slideTimer)
                        this.slideTimer = 0;
                    else {
                        d *= .25,
                        m = this.onTerrain ? n.terrainSlideDecel : n.slideDecel;
                        var g = r.getDistance(this.xVel, this.zVel, 0, 0)
                          , v = r.getDir(0, 0, this.xVel, this.zVel)
                          , y = r.getDir(Math.sin(this.xDire), Math.cos(this.xDire), 0, 0)
                          , b = .03 * r.getAngleDst(y, v);
                        this.xVel = g * Math.cos(v + Math.PI - b),
                        this.zVel = g * Math.sin(v + Math.PI - b)
                    }
                this.jumpCooldown = Math.max(this.jumpCooldown - l, 0),
                this.onGround && 0 >= this.jumpCooldown && t.tryJump(this, e[7]),
                f || (this.yVel -= l * (n.gravity * (s.config ? s.config.gravMlt : 1)));
                var w = n.movDirs[e[4]];
                if (w != Math.PI && 0 != w && w != Math.PI / 2 && w != -Math.PI / 2 && (d *= s.config ? s.config.strafeSpd : 1),
                void 0 !== w && (this.xVel += d * Math.cos(w - this.xDire),
                this.zVel += d * Math.sin(w - this.xDire)),
                this.xVel && (this.x += this.xVel * s.map.config.speedX * l,
                this.xVel *= Math.pow(m, l),
                this.xVel = r.cropVal(this.xVel, n.decelMin)),
                this.yVel && (this.y += this.yVel * s.map.config.speedY * l,
                this.yVel *= Math.pow(m, l)),
                this.zVel && (this.z += this.zVel * s.map.config.speedZ * l,
                this.zVel *= Math.pow(m, l),
                this.zVel = r.cropVal(this.zVel, n.decelMin)),
                !o) {
                    this.xVel || this.yVel || this.zVel ? this.noMovT = 0 : this.noMovT += l;
                    var x = "stalk" == this.team && 300 <= this.noMovT;
                    this.isHidden != x && (this.isHidden = x,
                    this.isYou && (hiddenMsg.style.display = this.isHidden ? "block" : "none"))
                }
                "prop" == this.team && e[5] && t.pickProp(this);
                var M = this.onGround && !this.didJump
                  , _ = !1;
                this.onGround = !1,
                this.onLadder = !1;
                for (var S = !1, T = "Pickup", E = !1, A = 0; A < s.map.manager.objects.length; ++A)
                    if (((a = s.map.manager.objects[A]).active || !a.active && a.closeable) && a.tRadius && this.collides(a, a.tRadius) && (a.gate ? !a.noMsg && (E = !1,
                    S = !0,
                    T = (!a.active && a.closeable ? "Close" : "Open") + " gate" + (0 == a.scoreP ? "" : " <span style='color:" + (this.score >= a.scoreP ? i.interactPopup.enough : i.interactPopup.notEnough) + "'>[" + (a.scoreP || 0) + "]</span>")) : a.bank && (S = !0,
                    T = "<span style='color:" + i.interactPopup.notEnough + "'>[" + r.commaFormatNum(a.deposited || 0) + "]</span>",
                    E = [a.depositAmnt, a.withdrawAmnt])),
                    a.active && this.collides(a))
                        if (a.onEnter && this.inObject != a.sid)
                            s.onTrigger(this, a),
                            this.inObject = a.sid;
                        else if (a.score)
                            this.scoreObjs[a.sid] || (this.scoreObjs[a.sid] = 1,
                            t.score(this, a.scoreP));
                        else if (a.teleporter)
                            s.checkTeleport(this, a);
                        else if (a.checkpoint)
                            s.setCheckPoint(this, a);
                        else if (r.isNumber(a.pickup) && "inf" != this.team)
                            a.noMsg || (S = !0,
                            E = !1,
                            T = "Pickup weapon" + (0 == a.scoreP ? "" : " <span style='color:" + (this.score >= a.scoreP ? i.interactPopup.enough : i.interactPopup.notEnough) + "'>[" + (a.scoreP || 0) + "]</span>"));
                        else if (a.flag)
                            s.pickupFlag(this, a);
                        else if (a.trigger)
                            this.flag && a.team == this.team && a.flagObj && !a.flagObj.carrier && a.flagObj.x == a.flagObj.orgX && a.flagObj.y == a.flagObj.orgY && a.flagObj.z == a.flagObj.orgZ && s.capFlag(this, this.flag);
                        else if (a.kill)
                            this.flag && (s.resetFlag(this.flag),
                            this.flag = null),
                            t.hasServer && t.kill(this);
                        else if (a.ladder) {
                            if (this.y < a.y + a.height && 0 == this.crouchVal && (this.yVel = 0,
                            this.onLadder = !0,
                            this.onTerrain = !1,
                            this.stepSrc = null,
                            void 0 !== w)) {
                                var P = (Math.abs(r.getAngleDst(a.dir, w - this.xDire)) - Math.PI / 2) / (Math.PI / 2);
                                0 < P && (this.y += n.ladderSpeed * this.weapon.spdMlt * l * P,
                                this.y <= a.y - a.height ? this.y = a.y - a.height : this.y >= a.y + a.height && (this.y = a.y + a.height))
                            }
                        } else if (a.ramp) {
                            if (this.y < a.y + a.height) {
                                var O = Math.max(0, Math.min(1, r.progressOnLine(a.ramp.sX, a.ramp.sZ, a.ramp.eX, a.ramp.eZ, this.x + this.scale * Math.cos(a.dir), this.z + this.scale * Math.sin(a.dir))))
                                  , R = a.y - a.height + 2 * a.height * O;
                                if (this.y <= R || M)
                                    if (a.boost) {
                                        this.y = R;
                                        var C = a.boost * n.boosterSpd * l;
                                        this.xVel += C * Math.sin(-a.dir + Math.PI / 2) * Math.cos(a.boostDr),
                                        this.zVel += C * Math.cos(-a.dir + Math.PI / 2) * Math.cos(a.boostDr),
                                        this.yVel += C * Math.sin(a.boostDr)
                                    } else
                                        this.oldY > this.y && t.resetStep(this, o),
                                        this.y = R,
                                        this.yVel = 0,
                                        this.onGround = !0,
                                        this.onTerrain = !1,
                                        _ = !0,
                                        this.rampFix = a.y - a.height + 2 * a.height * Math.round(O)
                            }
                        } else
                            !a.isBorder && this.y < a.y + a.height && a.y + a.height - this.y <= n.climbHeight && this.oldY < a.y + a.height && M ? (this.y += .3 * (a.y + a.height - this.y),
                            this.onGround = !0,
                            this.onTerrain = !1) : this.oldY >= a.y + a.height + (a.isBorder ? n.borderH : 0) ? (this.stepSrc = a.stepSrc,
                            this.oldY > this.y && t.resetStep(this, o),
                            this.y = a.y + a.height + (a.isBorder ? n.borderH : 0),
                            this.yVel = 0,
                            this.onGround = !0,
                            this.onTerrain = !1) : this.oldX - this.scale >= a.x + a.width - 1e-5 ? (this.x = a.x + a.width + this.scale,
                            this.xVel = 0) : this.oldX + this.scale <= a.x - a.width + 1e-5 ? (this.x = a.x - a.width - this.scale,
                            this.xVel = 0) : this.oldZ - this.scale >= a.z + a.length - 1e-5 ? (this.z = a.z + a.length + this.scale,
                            this.zVel = 0) : this.oldZ + this.scale <= a.z - a.length + 1e-5 ? (this.z = a.z - a.length - this.scale,
                            this.zVel = 0) : this.oldY + this.height <= a.y - a.height && (this.y = a.y - a.height - this.height,
                            this.yVel = 0);
                    else
                        a.sid == this.inObject && (this.inObject = null);
                !this.didJump && null != this.rampFix && Math.abs(this.y - this.rampFix) <= n.climbHeight ? !_ && (this.y = this.rampFix,
                this.onGround = !0,
                this.yVel = 0,
                this.rampFix = null) : this.rampFix = null;
                var L = s.map.terrain;
                if (L) {
                    var I = L.raycast(this.x, -this.z, 1e4, 0, 0, -2e4, !0);
                    if (I) {
                        var k = I.z;
                        if (this.y <= k && (this.oldY > this.y && t.resetStep(this, o),
                        this.onTerrain = !0),
                        this.onTerrain) {
                            this.onGround = !0;
                            var D = L._raycastNormal;
                            D.set(D.x, D.z, -D.y),
                            this.y = k;
                            var z = D.x
                              , B = -1 + D.y
                              , N = D.z
                              , j = Math.sqrt(z * z + B * B + N * N);
                            if (this.terrainSlipping = j > n.terrainSlideThreshold,
                            this.terrainSlipping = !1,
                            this.terrainSlipping)
                                j *= n.gravity * (s.config ? s.config.gravMlt : 1) * n.terrainGravityMlt * l,
                                this.xVel += z * j,
                                this.yVel += B * j,
                                this.zVel += N * j;
                            else
                                this.yVel = 0,
                                this.jumpCooldown = 0
                        }
                    }
                    this.onTerrain || (this.terrainSlipping = !1)
                }
                if (this.onGround ? this.airTime = 0 : this.airTime += l,
                !o && "prop" != this.team) {
                    var F = r.getD3D(this.oldX, this.oldY, this.oldZ, this.x, this.y, this.z);
                    if (this.isYou && (this.onLadder && (F *= 1.4),
                    r.getDir(this.oldX, this.oldZ, this.x, this.z),
                    this.bobAnimZ += r.getDistance(this.oldX, this.oldZ, this.x, this.z) * n.bobMltZ,
                    this.bobAnimY -= (this.oldY - this.y) * n.bobMltY,
                    f && void 0 !== w ? (t.playerStep(this, F),
                    this.leanAnimZ -= F * n.leanMltZ * (this.weapon.zLnM || 1) * Math.cos(w)) : this.stepVal *= Math.pow(n.stepPull, l),
                    this.stepChase != this.stepVal && (this.stepChase += .15 * (this.stepVal - this.stepChase))),
                    this.spreadPlus += F * n.spreadMove + Math.abs(this.oldY - this.y) * n.spreadFall,
                    this.spreadPlus *= Math.pow(n.spreadRecover, l),
                    this.spread = Math.max(this.weapon.minSpread || 0, (this.weapon.spread - this.weapon.spread * n.crouchSpread * this.crouchVal + this.recoilAnim * (this.weapon.spreadInc || 1) * n.spreadMlt + this.spreadPlus) * this.aimVal),
                    e[9] && t.reload(this),
                    0 < this.reloadTimer) {
                        var U = this.reloadTimer;
                        this.reloadTimer -= l,
                        this.isYou && U >= this.weapon.reload / 2 && this.reloadTimer < this.weapon.reload / 2 && t.endReload(this.weapon),
                        0 >= this.reloadTimer && (this.reloadTimer = 0,
                        this.didShoot = !1,
                        this.ammos[this.weaponIndex] = this.weapon.ammo,
                        t.updatePlayerAmmo(this))
                    }
                    0 < this.swapTime && (this.swapTime -= l,
                    0 > this.swapTime && (this.swapTime = 0));
                    for (A = 0; A < this.reloads.length; ++A)
                        0 < this.reloads[A] && (this.reloads[A] -= l,
                        0 > this.reloads[A] && (this.reloads[A] = 0));
                    if (this.weapon) {
                        var G = this.burstCount || !this.weapon.nAuto && e[5];
                        this.didShoot && !e[5] && (this.didShoot = !1),
                        !this.didShoot && e[5] && (G = !0),
                        G && 0 >= this.reloads[this.weaponIndex] && 0 >= this.swapTime && 0 >= this.reloadTimer && (this.noMovTimer = 0,
                        this.weapon.melee ? t.melee(this) : 0 < this.ammos[this.weaponIndex] ? t.shoot(this, e) : t.reload(this))
                    }
                }
                o && e.velObj && (this.xVel -= e.velObj.x,
                this.zVel -= e.velObj.y,
                this.yVel -= e.velObj.z,
                this.onGround = !1),
                t.playerCollisions(this),
                t.updateInteract(this, S, T, E)
            }
        }
        ,
        this.collides = function(e, t) {
            return this.x - this.scale < e.x + (e.width + (t || 0)) && this.x + this.scale > e.x - (e.width + (t || 0)) && this.z - this.scale < e.z + (e.length + (t || 0)) && this.z + this.scale > e.z - (e.length + (t || 0)) && this.y <= e.y + e.height + (e.isBorder ? n.borderH : 0) && this.y + this.height >= e.y - e.height
        }
        ,
        this.getStateConst = function() {
            return this.ping * (this.lagComp || 1)
        }
        ,
        this.update = function(e, i) {
            if (this.active) {
                if (this.inputs.length) {
                    for (var s = 0; s < this.inputs.length; ++s)
                        this.procInputs(this.inputs[s], e);
                    this.resetInputs()
                }
                if (this.idleAnim += n.idleAnimS * i,
                this.hpChase > this.health / this.maxHealth ? (this.hpChase -= 2e-4 * i,
                0 >= this.hpChase && (this.hpChase = 0)) : this.hpChase = this.health / this.maxHealth,
                this.interpolate) {
                    this.dt += i;
                    var a = Math.min(1.6, this.dt / (n.serverSendRate * n.interpolation));
                    a /= e.config ? e.config.deltaMlt : 1,
                    this.oldX = this.x,
                    this.oldY = this.y,
                    this.oldZ = this.z,
                    this.x = this.x1 + (this.x2 - this.x1) * a,
                    this.y = this.y1 + (this.y2 - this.y1) * a,
                    this.z = this.z1 + (this.z2 - this.z1) * a,
                    this.onGround && t.playerStep(this, r.getDistance(this.oldX, this.oldZ, this.x, this.z)),
                    this.xDire = Math.lerpAngle(this.xDir2, this.xDir1, Math.min(1, a)),
                    this.yDire = Math.lerpAngle(this.yDir2, this.yDir1, Math.min(1, a))
                }
            }
        }
        ,
        this.resetMeleeAnim = function() {
            this.meleeAnim.armT = 0,
            this.meleeAnim.armM = 0,
            this.meleeAnim.armE = 0,
            this.meleeAnim.weaR = 0,
            this.meleeAnim.weaM = 0,
            this.meleeAnim.armY = 0,
            this.meleeAnim.armR = 0,
            this.meleeAnim.lArm = 0,
            this.meleeAnim.flipW = 0
        }
        ,
        this.reset = function() {
            this.checkPoint = null,
            this.checkPointList.length = 0,
            this.weaponTier = 0,
            this.customLoadout = null,
            this.lastPicked.length = 0,
            this.inObject = null
        }
    };
    e.exports.Player = n,
    e.exports.manager = function(e, t, s, a, o, c, l, p) {
        this.list = [];
        var h, u, d, f = r(78);
        this.hasServer = p ? 1 : 0,
        this.setTeam = function(t) {
            if (!e.waitTimers && e.mode.convTeam)
                t.team = e.mode.convTeam;
            else if (e.mode.startTeam)
                t.team = e.mode.startTeam;
            else if (e.mode.friendly)
                t.team = 1;
            else if (e.mode.clanWar)
                t.team = t.account && t.account.clan ? t.account.clan : 1;
            else if (!t.team && e.mode.teams && !t.spectating) {
                for (var r = 0, i = 0, n = 0; n < this.list.length; ++n)
                    this.list[n].spectating || (this.list[n].team == (e.mode.teamNs ? e.mode.teamNs[0] : 1) && r++,
                    this.list[n].team == (e.mode.teamNs ? e.mode.teamNs[1] : 2) && i++);
                t.team = r >= i ? 2 : 1,
                e.mode.teamNs && (t.team = e.mode.teamNs[t.team - 1])
            }
        }
        ,
        this.update = function(r) {
            for (var i = 0; i < this.list.length; ++i)
                this.list[i].active ? (this.list[i].update(e, r),
                p && (this.tickPlayer(this.list[i], r),
                this.storeState(this.list[i]),
                this.list[i].y <= e.map.deathY && (this.list[i].flag && (e.resetFlag(this.list[i].flag),
                this.list[i].flag = null),
                this.kill(this.list[i]))),
                t && (this.updateMsh(this.list[i]),
                this.updateHeight(this.list[i]))) : this.list[i].deathInfo && this.list[i].deathInfo.tillNext && (this.list[i].deathInfo.tillNext -= r,
                0 >= this.list[i].deathInfo.tillNext && (this.list[i].deathInfo.tillNext = null,
                p.send(this.list[i].id, "frs")))
        }
        ,
        this.playerCollisions = function(t) {
            if (p && e.mode.convTeam && !e.waitTimers)
                for (var r = 0; r < this.list.length; ++r)
                    if (t.active && this.list[r].active && t.team == e.mode.convTeam && t.team != this.list[r].team) {
                        var i = l.fvcbEmTb / 2;
                        o.getD3D(t.x, t.y + i, t.z, this.list[r].x, this.list[r].y + i, this.list[r].z) <= 2.4 * i && (p.broadcast("game" + e.sid, "ac", t.sid, this.list[r].sid, e.mode.convWord),
                        this.score(t, 100),
                        t.convs++,
                        e.updateTeam(this.list[r], t.team),
                        e.mode.killConv && this.kill(this.list[r], null, null, !0),
                        e.gameTimer && (e.gameTimer += 1e4))
                    }
        }
        ,
        this.activeCount = function() {
            for (var e = 0, t = 0; t < this.list.length; ++t)
                this.list[t].active && e++;
            return e
        }
        ,
        this.forcePos = function() {
            for (var e = 0; e < this.list.length; ++e)
                this.list[e].forcePos = !0,
                this.list[e].objInstances && (this.list[e].objInstances.visible = !1,
                this.list[e].cnBSeen = !1)
        }
        ,
        this.saveSpin = function(e, t) {
            p && (e.spins.unshift(t),
            e.spins.length > l.spinTimer / l.serverTickRate && (e.spins.length = Math.round(l.spinTimer / l.serverTickRate)))
        }
        ,
        this.getSpin = function(e) {
            for (var t = 0, r = 0; r < e.spins.length; ++r)
                t += e.spins[r];
            return Math.abs(t * (180 / Math.PI))
        }
        ,
        this.storeState = function(t) {
            t.stateHistory.unshift({
                time: e.now,
                x: t.x,
                y: t.y,
                z: t.z
            });
            for (var r = t.stateHistory.length - 1; 0 <= r; --r)
                e.now - t.stateHistory[r].time >= l.stateHistory && t.stateHistory.splice(r, 1)
        }
        ,
        this.fetchState = function(t, r) {
            for (var i = e.now - (r + l.serverSendRate * l.interpolation), n = 0; n < t.stateHistory.length; ++n)
                if (t.stateHistory[n].time <= i)
                    return t.stateHistory[n];
            return t.stateHistory[t.stateHistory.length - 1]
        }
        ,
        this.updateMsh = function(r, i) {
            if (r.objInstances) {
                var n = e.config.thirdPerson || e.map.config && (e.map.config.camOffX || e.map.config.camOffY || e.map.config.camOffZ)
                  , s = r.weapon.animWhileAim ? 1 : r.aimVal
                  , a = (1 - (1 - l.aimAnimMlt) * (1 - r.aimVal)) * l.animMult * t.weaponBob
                  , o = 1 - .8 * r.crouchVal
                  , c = (1 - (1 - r.aimVal)) * l.animMult
                  , p = (1 - (1 - r.aimVal) * (r.weapon.recoilYMA || 1)) * l.animMult;
                r.isYou || (c = 0);
                var h = 1 - (r.weapon.recoilZM || .5) * (1 - s)
                  , u = (1 - (r.weapon.zRot || .3) * (1 - s)) * (r.weapon.zRM || 1) * t.weaponBob
                  , d = 1 - (r.weapon.jYMlt || 1) * (1 - s)
                  , f = 1 - .45 * (1 - s)
                  , m = .9 * r.bobAnimY * d * t.weaponBob * c
                  , g = r.landBobY * (r.weapon.landBob || 1) * .6 * (1 - .75 * (1 - s)) * t.weaponBob;
                r.landBobYR != g && (r.landBobYR += .1 * (g - r.landBobYR));
                var v = r.landBobY * (r.weapon.landBob || 1) * .1
                  , y = 1 - .5 * r.crouchVal
                  , b = (r.crouchVal,
                r.jumpRot * y * c * t.weaponBob);
                r.jumpRotM != b && (r.jumpRotM += .08 * (b - r.jumpRotM));
                var w = r.jumpBobY * (r.weapon.jumpYM || 1) * c * y * t.weaponBob
                  , x = 1 - .89 * (1 - s)
                  , M = 1 - (r.weapon.aimRecMlt || 1) * (1 - s)
                  , _ = i ? .05 : l.stepAnim
                  , S = Math.sin(r.stepVal) * _
                  , T = Math.cos(2 * r.stepVal) / 2 * _
                  , E = -Math.sin(r.stepChase) * _
                  , A = -Math.cos(2 * r.stepChase) / 2 * _
                  , P = n ? 0 : 1 - r.aimVal
                  , O = .5 * (.5 >= P ? P : .5 - (P - .5))
                  , R = r.swapTime / r.weapon.swapTime
                  , C = r.weapon.xOff * (r.isYou ? t.weaponOffX : 1)
                  , L = r.weapon.yOff * (r.isYou ? t.weaponOffY : 1)
                  , I = r.weapon.zOff * (r.isYou ? t.weaponOffZ : 1)
                  , k = 0;
                0 < r.reloadTimer && (k = .5 < (k = 1 - r.reloadTimer / r.weapon.reload) ? .5 - (k - .5) : k);
                var D = 1.75 * (1 - .88 * (1 - r.aimVal)) * t.weaponBob;
                t.moveMesh(r.objInstances, r.x, r.y + (r.isYou && !n ? 0 : Math.abs(3.5 * S)), r.z),
                "prop" != r.team && t.rotateMesh(r.objInstances, r.xDire + (r.isYou ? n ? .5 * -S : 0 : 2 * -S)),
                T -= T * (r.crouchVal * l.crouchAnimMlt),
                S -= S * (r.crouchVal * l.crouchAnimMlt);
                for (var z = 0; z < r.legMeshes.length; ++z)
                    t.lowSpec ? r.legMeshes[z].visible = !1 : r.legMeshes[z].rotation.x = S * (1 == z || 3 == z ? 1 : -1) * 7 + (1 < z ? -.6 : 0);
                for (z = 0; z < r.armMeshes.length; ++z)
                    -(r[(0 == z ? "l" : "r") + "HndTweenA"] || 0),
                    r.armMeshes[z].position.z = S * (z ? -1 : 1),
                    r.armMeshes[z].rotation.x = r.armMeshes[z].xR || 0,
                    r.armMeshes[z].rotation.y = r.armMeshes[z].yR || 0,
                    r.armMeshes[z].position.x = r.armMeshes[z].xP || 0,
                    r.armMeshes[z].position.y = r.armMeshes[z].yP || 0,
                    1 == z ? (r.armMeshes[1].rotation.z = r.armMeshes[z].zR + .12 * r.crouchVal + -1 * A + .2 * r.jumpBobY,
                    r.meleeAnim && r.weaponGeos[r.weaponIndex] && (r.armMeshes[1].rotation.z += (r.meleeAnim.armR || 0) * c,
                    r.armMeshes[1].rotation.y += (r.meleeAnim.armT || 0) * c,
                    r.armMeshes[1].position.x += (r.meleeAnim.armM || 0) * c,
                    r.armMeshes[1].position.z += (r.meleeAnim.armE || 0) * c,
                    r.armMeshes[1].position.y += (r.meleeAnim.armY || 0) * c,
                    r.weaponGeos[r.weaponIndex] && (r.weaponGeos[r.weaponIndex].rotation.z = r.weaponGeos[r.weaponIndex].zR + (r.meleeAnim.weaR || 0),
                    r.weaponGeos[r.weaponIndex].position.x = r.weaponGeos[r.weaponIndex].xP + (r.meleeAnim.weaM || 0),
                    r.weaponGeos[r.weaponIndex].rotation.y = r.weaponGeos[r.weaponIndex].yR + (r.meleeAnim.flipW || 0)))) : r.meleeAnim && r.weaponGeos[r.weaponIndex] && (r.armMeshes[0].position.z += r.meleeAnim.lArm || 0,
                    r.armMeshes[0].rotation.y += .1 * (r.meleeAnim.lArm || 0),
                    r.armMeshes[0].position.x -= .3 * (r.meleeAnim.lArm || 0));
                var B = null != r.weapon.attach && e.attach[r.attachIndex] ? e.attach[r.attachIndex] : null
                  , N = B && B.aimOffY || 0;
                r.weaponMeshes[r.weaponIndex] && r.weaponMeshes[r.weaponIndex].flapMesh && r.weapon.flap && (fRot = 3 * A + 2.8 * r.recoilAnim - r.leanAnimZ - 3 * r.leanAnimX - 1.8 * r.landBobYR + m + .1 * r.crouchVal,
                t.rotateMesh(r.weaponMeshes[r.weaponIndex].flapMesh, r.weapon.flap.rot * r.swapTweenA + fRot, null, null));
                var j = n ? .4 : 1;
                t.rotateMesh(r.upperBody, k * (-1 * j), -.2 * m + +v + k * (-2.8 * j) + r.yDire * (r.isYou && !n ? 1 : .5) + (-Math.PI / 4 * R + r.recoilAnimY * l.recoilMlt) + (r.weapon.yRot || 0)),
                t.moveMesh(r.upperBody, 0, r.recoilAnimY * ((r.weapon.recoilYM || .3) * p) + (r.height - l.cameraHeight - l.legHeight), 0),
                t.rotateMesh(r.weaponMeshes[r.weaponIndex], r.inspectX + .2 * r.jumpRotM + r.recoilX * x + r.leanAnimX * f * t.weaponLean * (r.weapon.leanMlt || 1) + (.16 * -E * c * o + .2 * r.leanAnimZ) * a, -Math.cos(r.idleAnim) * y * .01 * D + (r.weapon.rotOff || 0) * c - .25 * (r.swapTweenR || 0) * c + .6 * -r.landBobYR + r.recoilTweenY * M + r.leanAnimY * f * t.weaponLean * (r.weapon.leanMlt || 1) + -.9 * A * a, b + O + r.recoilX * x + (r.swapTweenR || 0) * c * .1 + r.leanAnimZ * u + -r.inspectX * (r.weapon.inspectR || 0) + ((r.weapon.cLean || 0) * r.crouchVal * c + 0 * -E) * a),
                t.moveMesh(r.weaponMeshes[r.weaponIndex], -r.jumpRotM * c * 1.3 + -r.inspectX * (r.weapon.inspectM || 0) + (.35 * r.leanAnimZ - (r.weapon.cRot || 0) * r.crouchVal * c + .5 * S * o * c) * r.aimVal * a + C - (C - r.weapon.xOrg) * P, .02 * Math.sin(r.idleAnim) * D + r.recoilTweenYM * M + w + .7 * g - 1.5 * m + (.85 * T - (r.weapon.cDrop || 0) * r.crouchVal * c) * a + L - (L - r.weapon.yOrg + N) * P, I - (I - r.weapon.zOrg) * P + r.bobAnimZ * a + r.recoilAnim * (r.weapon.recoilZ || 0) * h)
            }
        }
        ,
        this.updateHeight = function(r) {
            var i = e.config.thirdPerson || e.map.config && (e.map.config.camOffX || e.map.config.camOffY || e.map.config.camOffZ)
              , n = l.crouchDst * r.crouchVal;
            if (!t || r.isYou && !i)
                r.height = l.fvcbEmTb - n;
            else {
                var s = l.crouchLean * r.crouchVal;
                t.rotateMesh(r.lowerBody, 0, s + .5 * r.yDire, 0),
                r.upperBody && (r.upperBody.rotation.x -= s),
                t.moveMesh(r.lowerBody, 0, l.legHeight - n, 0);
                for (var a = 0; 4 > a; ++a)
                    r.legMeshes[a] && !t.lowSpec && (r.legMeshes[a].visible = 1 >= a ? !r.crouchVal : !!r.crouchVal)
            }
        }
        ,
        this.generateMeshes = function(r, n, s=!1, o) {
            var p = e.classes[r.classIndex].colors
              , h = p[0];
            l.skinColors[r.skinColIndex] && (h = l.skinColors[r.skinColIndex]);
            var u = e.config.thirdPerson || e.map.config && (e.map.config.camOffX || e.map.config.camOffY || e.map.config.camOffZ) || !n
              , d = t.genObj3D(0, 0, 0);
            if (r.objInstances = t.genObj3D(r.x, r.y, r.z),
            r.objInstances.add(d),
            "inf" == r.team ? (h = c.modeSpecific.infected.skin,
            r.hatIndex = 122) : "stalk" == r.team && (r.backIndex = -1,
            r.hatIndex = -1,
            r.meleeIndex = -1,
            h = c.modeSpecific.stalker.skin,
            p = c.modeSpecific.stalker.body),
            "prop" == r.team) {
                var f = l.propsH[r.propID];
                t.loadMesh({
                    src: f + "_0"
                }, 0, l[f + "Scale"] + (l.propsCPY[f] || 0), 0, 0, l[f + "Scale"], r.objInstances, !1)
            } else {
                var m;
                if (r.lowerBody = t.genObj3D(0, l.legHeight, 0),
                u && r.lowerBody.add(t.genBody(p[1], p[2], p[4], h, r.isYou)),
                r.upperBody = t.genObj3D(0, 0, 0),
                r.lowerBody.add(r.upperBody),
                0 <= r.backIndex && u) {
                    if (o && o[2])
                        for (var g in m = {
                            ...e.store.skins[r.backIndex]
                        })
                            null != o[2][g] && (m[g] = o[2][g]);
                    else
                        m = e.store.skins[r.backIndex];
                    r.backMesh = t.genObj3D(0, (l.fvcbEmTb - l.legHeight - l.headScale) / 2 - (m.sitOff || 0), -(m.sitOffZ || 0)),
                    r.lowerBody.add(r.backMesh),
                    t.loadMesh({
                        src: "body/body_" + m.id,
                        texSrc: m.tex ? "body/body_" + m.id + "_" + m.tex : null,
                        frames: m.frames,
                        frameT: m.frameT,
                        glowText: m.glow,
                        emissive: m.glow ? 16777215 : null,
                        noGreen: !0
                    }, 0, 0, 0, Math.PI / 2, 2.1 * (m.sclMlt || 1), r.backMesh)
                }
                if (0 <= r.hatIndex && u) {
                    if (o && o[1])
                        for (var g in m = {
                            ...e.store.skins[r.hatIndex]
                        })
                            null != o[1][g] && (m[g] = o[1][g]);
                    else
                        m = e.store.skins[r.hatIndex];
                    r.hatMesh = t.genObj3D(0, l.fvcbEmTb - l.legHeight - (m.sitOff || 0), -(m.sitOffZ || 0)),
                    r.lowerBody.add(r.hatMesh),
                    t.loadMesh({
                        src: "hats/hat_" + m.id,
                        texSrc: m.tex ? "hats/hat_" + m.id + "_" + m.tex : null,
                        frames: m.frames,
                        frameT: m.frameT,
                        glowText: m.glow,
                        emissive: m.glow ? 16777215 : null,
                        noGreen: !0
                    }, 0, 0, 0, Math.PI / 2, 2.1 * (m.sclMlt || 1), r.hatMesh)
                }
                if (u)
                    for (var v = 0; 4 > v; ++v)
                        r.legMeshes.push(t.genLeg(1 == v || 3 == v, p[2], p[3], 1 < v)),
                        2 <= v && t.rotateMesh(r.legMeshes[v], 2 == v ? -Math.PI / 6 : Math.PI / 8, 0, 0),
                        r.legMeshes[v].visible = 1 >= v,
                        d.add(r.legMeshes[v]);
                for (v = 0; v < r.ammos.length; ++v) {
                    var y = t.genObj3D(0, 0, 0)
                      , b = e.weapons[r.loadout[v]]
                      , w = null != b.attach && e.attach[r.attachIndex] ? e.attach[r.attachIndex] : null;
                    if (n && b.ammo) {
                        y.muzzles = [],
                        y.casings = [];
                        for (var x = 0; 2 > x; ++x)
                            (!x || b.akimbo) && (y.muzzles.push(new i.Sprite),
                            y.muzzles[x].visible = !1,
                            y.muzzles[x].static = !0,
                            a.particles.push(y.muzzles[x]),
                            y.add(y.muzzles[x]),
                            y.casings.push(t.genObj3D(x ? 2 * -b.xOff : 0, b.caseYOff || 0, b.caseZOff || 0)),
                            y.add(y.casings[x]));
                        y.muzzleFlash = t.genObj3D(0, .4, 0),
                        y.muzzles[0].add(y.muzzleFlash)
                    }
                    if (b.src || !r.isYou)
                        y.add(t.genArms(b, p[1], p[5], h, null, !u));
                    else {
                        var M;
                        for (x = 0; 2 > x; ++x)
                            M = t.genArms(b, p[1], p[5], h, x + 1, !u),
                            y.add(M),
                            r.armMeshes.push(M)
                    }
                    if (r.weaponMeshes.push(y),
                    r.weaponMeshes[v].visible = !1,
                    r.upperBody.add(r.weaponMeshes[v]),
                    b.melee && (r.isYou || "inf" != r.team)) {
                        var _ = e.store.skins[r.meleeIndex] || {};
                        r.weaponGeos[v] = t.loadMesh({
                            src: "melee/melee_" + (_.id || 0),
                            texSrc: "stalk" == r.team ? "melee/melee_0_5" : _.tex ? "melee/melee_" + (_.id || 0) + "_" + _.tex : "",
                            glowText: _.glow,
                            emissive: _.glow ? 16777215 : null,
                            pulsT: _.pulsT,
                            frames: _.frames,
                            frameT: _.frameT,
                            tFilter: i.LinearFilter,
                            mat: s || r.isYou ? i.MeshPhongMaterial : null,
                            noGreen: !0,
                            uv2: !0,
                            specular: 2697513,
                            shininess: 100
                        }, (r.isYou ? .9 : 1.7) + (r.isYou && _.sxOff || 0), r.isYou ? -.95 : -.4, r.isYou ? .72 : 1.2, [-Math.PI / 3.5, r.isYou ? .3 : Math.PI / 2, -.9 * Math.PI + (r.isYou && _.sxRot || 0)], _.sclMlt || .9, r.armMeshes[1] ? r.armMeshes[1] : r.weaponMeshes[v]),
                        r.armMeshes[1] && (r.armMeshes[1].yR = r.armMeshes[1].rotation.y,
                        r.isYou ? (r.armMeshes[1].zR = r.armMeshes[1].rotation.z = -.3,
                        r.armMeshes[1].xR = r.armMeshes[1].rotation.x = -.4,
                        r.armMeshes[1].xP = r.armMeshes[1].position.x = .4,
                        r.armMeshes[1].yP = r.armMeshes[1].position.y = .3) : (r.armMeshes[1].zR = r.armMeshes[1].rotation.z = .3,
                        r.armMeshes[1].yP = r.armMeshes[1].position.y = -.4,
                        r.armMeshes[1].xR = r.armMeshes[1].rotation.x,
                        r.armMeshes[1].xP = r.armMeshes[1].position.x = -.2),
                        r.armMeshes[0].xP = r.armMeshes[0].position.x = .3,
                        r.armMeshes[0].yP = r.armMeshes[0].position.y = -.5,
                        r.armMeshes[0].zR = r.armMeshes[0].rotation.z = -.4,
                        r.armMeshes[0].yR = r.armMeshes[0].rotation.y)
                    }
                    if (b.src) {
                        var S = e.store.skins[r.skins[v]] || {}
                          , T = 0 <= r.skins[v] && (S.glow || S.sameGlow);
                        for (x = 0; 2 > x; ++x)
                            (!x || b.akimbo) && t.loadMesh({
                                src: "weapons/" + b.src + (null == S.mid ? "" : "_" + S.mid),
                                texSrc: null == S.mid ? S.tex ? S.tex : 0 <= r.skins[v] ? "weapons/skins/" + b.src + "_" + S.id : null : S.midT,
                                tFilter: i.LinearFilter,
                                mat: s || r.isYou ? i.MeshPhongMaterial : null,
                                movT: S.movT,
                                movD: S.movD,
                                pulsT: S.pulsT,
                                frames: S.frames,
                                frameT: S.frameT,
                                sameGlow: S.sameGlow,
                                glowText: T,
                                noGreen: !0,
                                uv2: !0,
                                ao: n && !b.noAo,
                                shininess: S.shine || b.shine || 60,
                                specular: 2697513,
                                transparent: b.seeThrough,
                                emissive: b.transp || T ? 16777215 : null
                            }, 1 == x ? -2 * b.xOff : 0, S.yOff || 0, S.zOff || 0, Math.PI / 2, S.mScl || b.scale, r.weaponMeshes[v])
                    }
                    n && b.flap && t.sniperFlap && (r.weaponMeshes[v].flapMesh = t.loadMesh({
                        src: "attach/" + b.flap.src,
                        tFilter: i.LinearFilter,
                        noGreen: !0,
                        mat: i.MeshPhongMaterial,
                        shininess: 60,
                        transparent: !0
                    }, b.flap.xOff, b.flap.yOff, b.flap.zOff, Math.PI / 2, b.flap.scl, r.weaponMeshes[v])),
                    w && (n || s) && t.loadMesh({
                        src: "attach/" + w.src,
                        tFilter: i.LinearFilter,
                        noGreen: !0,
                        mat: r.isYou ? i.MeshPhongMaterial : null,
                        specular: 2697513,
                        shininess: 60,
                        transparent: !0
                    }, 0, -(b.yOrg || 0) + (b.attachYOff || 0), -(b.attachZOff || 0), Math.PI / 2, w.scale, r.weaponMeshes[v])
                }
                d.add(r.lowerBody),
                n && r.objInstances.traverse(function(e) {
                    e.layers.set(1)
                })
            }
            return r.objInstances
        }
        ,
        this.pickProp = function(t) {
            if (p && t && t.active && (!t.lastPropPick || 200 <= e.now - t.lastPropPick)) {
                t.lastPropPick = e.now;
                var r = t.xDire
                  , i = t.yDire;
                g.length = 0;
                for (var n, s = 0, a = 1 / (25 * Math.sin(r + Math.PI) * Math.cos(i)), c = 1 / (25 * Math.cos(r + Math.PI) * Math.cos(i)), h = 1 / (25 * Math.sin(i)), u = t.y + t.height - l.cameraHeight, d = 0; d < e.map.manager.objects.length; ++d)
                    (n = e.map.manager.objects[d]).active && n.propID && !n.noShoot && ((s = o.lineInRect(t.x, t.z, u, a, c, h, n.x - n.width, n.z - n.length, n.y - n.height, n.x + n.width, n.z + n.length, n.y + n.height)) && 1 >= s && g.push({
                        obj: n,
                        dst: s
                    }));
                g.length && (g.sort(o.orderByDst),
                g[0] && g[0].obj && this.updateProp(t, l.propsH.indexOf(g[0].obj.propID)))
            }
        }
        ,
        this.updateProp = function(t, r, i) {
            if (t && t.active) {
                null != r && (t.propID = r);
                var n = l[l.propsH[r] + "Scale"]
                  , s = l.propsCP[l.propsH[r]] || 0;
                t.height = n + s,
                t.scale = n + s,
                i && this.regenMeshes(t),
                p && p.broadcast("game" + e.sid, "up", t.sid, r)
            }
        }
        ,
        this.regenMeshes = function(e) {
            e.objInstances && this.disposeMesh(e, !0),
            t && t.add(this.generateMeshes(e, e.isYou)),
            this.swapWeapon(e, 0, !0)
        }
        ,
        this.hideAll = function() {
            for (var e = 0; e < this.list.length; ++e)
                this.list[e].active && this.list[e].objInstances && (this.list[e].forcePos = !this.list[e].latestData,
                this.list[e].latestData = !1,
                this.list[e].isYou || (this.list[e].objInstances.visible = !1))
        }
        ,
        this.clear = function() {
            if (t)
                for (var e = 0; e < this.list.length; ++e)
                    this.disposeMesh(this.list[e]);
            this.list.length = 0
        }
        ,
        this.toggleLOD = function(e, t) {
            e.latestData && (e.objInstances && (e.objInstances.visible = t),
            e.lodActive = !t)
        }
        ,
        this.disposeMesh = function(e) {
            t.remove(e.objInstances),
            e.objInstances = null,
            e.hatMesh = null,
            e.backMesh = null,
            e.weaponMeshes.length = 0,
            e.weaponGeos = {},
            e.armMeshes.length = 0,
            e.legMeshes.length = 0
        }
        ,
        this.add = function(r, i, s, a, h, u, d, f, m, g, v, y, b, w, x, M, _, S, T) {
            for (var E, A = 0; A < this.list.length; ++A)
                if (this.list[A].id == r) {
                    E = this.list[A];
                    break
                }
            return E ? (E.weaponMeshes.length = 0,
            E.weaponGeos = {},
            E.legMeshes.length = 0,
            E.armMeshes.length = 0) : ((E = new n(r,this,o,c,l,e)).sid = i || o.generateSID(this.list),
            this.list.push(E)),
            u || (u = "Guest_" + E.sid),
            E.init(s, a, h, u, _, S),
            p && null != e.mode && this.setTeam(E),
            M && (E.team = M),
            E.skins = f || [-1, -1],
            E.hatIndex = m,
            E.backIndex = g,
            E.meleeIndex = v,
            E.skinColIndex = y,
            E.attachIndex = b,
            E.secIndex = w,
            E.setClass(e, d, w, !!t),
            !T && e.mode.startingLoadout && (T = e.mode.startingLoadout),
            T && E.updateLoadout(e, E.weaponIndex, !1, ...T),
            t && t.add(this.generateMeshes(E, _)),
            "prop" == E.team && this.updateProp(E, x || 0, !0),
            this.swapWeapon(E, 0, !0),
            "undefined" != typeof window && "updateWindow"in window && window.updateWindow(23),
            E
        }
        ,
        this.remove = function(t) {
            var r = this.indexBySid(t);
            if (0 <= r) {
                p && this.list[r] && (e.dropFlag(this.list[r].flag),
                this.dropWeapon(this.list[r], !0));
                var i = this.list[r].id;
                if (this.list[r].objInstances && this.disposeMesh(this.list[r]),
                this.list.splice(r, 1),
                p) {
                    for (var n = this.list.length - 1; 0 <= n; --n)
                        0 <= (r = this.list[n].sentTo.indexOf(i)) && this.list[n].sentTo.splice(r, 1);
                    p.broadcast("game" + e.sid, "2", t),
                    this.syncLeaders()
                }
                "undefined" != typeof window && "updateWindow"in window && window.updateWindow(23)
            }
        }
        ;
        var m = [0, 1, 2];
        this.getStepSound = function() {
            var e = o.randInt(0, m.length - 1)
              , t = m[e];
            return m.splice(e, 1),
            0 >= m.length && m.push(0, 1, 2),
            t
        }
        ,
        this.playerStep = function(t, r, i) {
            if (r && (!t.isYou && t.crouchVal && (r *= 1.6),
            t.stepVal += r * l.stepMlt * t.stepDir,
            t.stepVal >= Math.PI / 2 && 1 == t.stepDir || t.stepVal <= -Math.PI / 2 && -1 == t.stepDir)) {
                if (s && !i && "stalk" != t.team) {
                    var n = o.randFloat(.15, .25) * (1 > t.crouchVal ? 1 : t.isYou ? .5 : 0)
                      , a = (1 > t.crouchVal ? 1 : .8) * o.randFloat(.8, 1.2)
                      , c = t.stepSrc ? "_" + t.stepSrc : "";
                    t.isYou ? s.play("step_" + this.getStepSound() + c, n, !1, a) : n && e.playerSound("step_" + o.randInt(0, 2) + c, 0, n, t, a, 180)
                }
                t.stepDir *= -1
            }
        }
        ,
        this.resetStep = function(t, r) {
            if (!r && t.isYou && t.yVel && (t.jumpTween && t.jumpTween.stop(),
            t.landTween && t.landTween.stop(),
            t.landTween = new TWEEN.Tween(t).to({
                landBobY: 6 * t.yVel,
                jumpBobY: 0
            }, 100).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                t.landTween = new TWEEN.Tween(t).to({
                    landBobY: 0
                }, 1100).easing(TWEEN.Easing.Elastic.Out).start()
            }).start()),
            s && !r && t.yVel && "stalk" != t.team && (t.stepSrc && t.stepSrc,
            s.play("step_" + this.getStepSound(), .7, !1, o.randFloat(.9, 1.2)),
            t.isYou && t.crouchVal && e.config.canSlide && t.canSlide && s.play("slide_0", .35, !1, o.randFloat(.9, 1.1))),
            e.config.canSlide && t.crouchVal && t.canSlide) {
                t.canSlide = !1,
                t.slideTimer = l.slideTime * t.crouchVal;
                var i = this.onTerrain ? l.playerTerrainSlideVelMlt : l.playerSlideVelMlt;
                t.xVel *= i,
                t.zVel *= i
            }
        }
        ,
        this.tryJump = function(t, r) {
            e.config && e.config.autoJump && r ? this.jump(t) : (t.didJump && !r && (t.didJump = !1),
            !t.didJump && r && this.jump(t))
        }
        ,
        this.jump = function(t) {
            t.jumpCooldown = t.terrainSlipping ? l.playerSlippingJumpCooldown : 0,
            t.didJump = !0,
            t.onTerrain = !1;
            var r = l.jumpVel * (e.config ? e.config.jumpMlt : 1)
              , i = l.jumpPush * (e.config ? e.config.jumpMlt : 1);
            t.yVel += (r - r * (l.crouchJump * t.crouchVal)) * t.weapon.spdMlt * (t.aimVal ? 1 : l.aimJumpSlow);
            var n = o.getDistance(0, 0, t.xVel, t.zVel);
            if (t.xVel -= i * n * Math.sin(t.xDire),
            t.zVel -= i * n * Math.cos(t.xDire),
            s && !t.recon && t.isYou) {
                t.landTween && t.landTween.stop(),
                t.landTween = new TWEEN.Tween(t).to({
                    landBobY: 0
                }, 100).easing(TWEEN.Easing.Linear.None).start(),
                t.jumpTween && t.jumpTween.stop(),
                t.jumpTween = new TWEEN.Tween(t).to({
                    jumpBobY: .22
                }, 500).easing(TWEEN.Easing.Back.Out).start();
                var a = o.randFloat(.12, .15);
                new TWEEN.Tween(t).to({
                    jumpRot: [a, 0]
                }, 900).easing(TWEEN.Easing.Back.Out).start();
                s.play("jump_" + o.randInt(0, 1), .04, !1, o.randFloat(.9, 1))
            }
        }
        ,
        this.updateAim = function(e, r) {
            t.zoom(1 + (e.weapon.zoom - 1) * r)
        }
        ,
        this.toggleAim = function(r, i) {
            if (s && !r.recon && s.play("aim_" + i, .1),
            i && "prop" != r.team || this.resetAim(),
            r.weapon.scope && r.weaponMeshes && r.weaponMeshes[r.weaponIndex] && (t.zoom(i ? r.weapon.zoom : 1),
            r.weaponMeshes[r.weaponIndex].visible = !this.isWeaponHidden(r, r.weaponIndex) && !i,
            aimRecticle.style.opacity = i ? 1 : 0),
            null != r.weapon.attach && e.attach[r.attachIndex] ? e.attach[r.attachIndex] : null) {
                aimDot.style.opacity = i ? 1 : 0;
                var n = e.store.skins[r.skins[r.weaponIndex]]
                  , a = o.assetsUrl("/textures/dots/" + (n && n.dot || "dot_0") + ".png");
                aimDot.src == a || t.customADS.length || (aimDot.src = a)
            }
            t.hideADS && (r.weaponMeshes[r.weaponIndex].visible = !i && !this.isWeaponHidden(r, r.weaponIndex))
        }
        ,
        this.resetAim = function() {
            t.zoom(1),
            aimRecticle.style.opacity = 0,
            aimDot.style.opacity = 0
        }
        ,
        this.isWeaponHidden = function(t, r) {
            var i = t.loadout[r];
            return !(!e.weapons[i].melee || !e.hideWeapon[2]) || (!(!e.weapons[i].secondary || !e.hideWeapon[1]) || !(e.weapons[i].melee || e.weapons[i].secondary || !e.hideWeapon[0]))
        }
        ,
        this.reload = function(e) {
            !e.reloadTimer && e.ammos[e.weaponIndex] < e.weapon.ammo && (s && s.play("reload_1", .25),
            e.reloadTimer = e.weapon.reload,
            e.burstCount = 0,
            e.isYou && this.cancelInspect(e))
        }
        ,
        this.endReload = function(e) {
            s && s.play("reload_2" + (e.custReload || ""), .25)
        }
        ,
        this.updatePlayerAmmo = function(e) {
            e.isYou && (ammoDisplay.style.display = "inline-block",
            ammoVal.innerHTML = (e.ammos[e.weaponIndex] || (e.weapon.melee ? "-" : 0)) + " <span id='ammoMax'> | " + (e.weapon.ammo || "-") + "</span>",
            0 >= e.ammos[e.weaponIndex] ? (reloadMsg.innerHTML = "[R] Reload",
            reloadMsg.style.display = "block") : reloadMsg.style.display = "none")
        }
        ,
        this.cancelInspect = function(e) {
            e.inspecting = !1,
            e.inspectX = 0
        }
        ,
        this.wInspect = function(e) {
            e.inspecting ? this.cancelInspect(e) : !e.weapon.nInsp && !e.inspecting && 1 == e.aimVal && !e.reloadTimer && (e.inspecting = !0)
        }
        ,
        this.melee = function(t) {
            if (t.reloads[t.weaponIndex] = t.weapon.rate,
            t.didShoot = !0,
            t.isYou) {
                if (e.controls && e.controls.vibration && e.controls.gamepad._connected && e.controls.gamepad.rumble(t.weapon.rumbleDur || 200, t.weapon.rumble || .5),
                t.weapon.anim) {
                    var r = e.store.skins[t.meleeIndex] || {};
                    t.weapon.anim(t, TWEEN, r.animInd || 1)
                }
                t.weapon.sounds && s.play(t.weapon.sounds[o.randInt(0, t.weapon.sounds.length - 1)], .1, !1, o.randFloat(.9, 1.1))
            }
            var i = t.xDire
              , n = t.yDire;
            g.length = 0;
            for (var a = 0, c = 1 / (t.weapon.range * Math.sin(i + Math.PI) * Math.cos(n)), h = 1 / (t.weapon.range * Math.cos(i + Math.PI) * Math.cos(n)), d = 1 / (t.weapon.range * Math.sin(n)), f = t.y + t.height - l.cameraHeight, m = 0; m < e.map.manager.objects.length; ++m)
                (u = e.map.manager.objects[m]).active && !u.noShoot && ((a = o.lineInRect(t.x, t.z, f, c, h, d, u.x - u.width, u.z - u.length, u.y - u.height, u.x + u.width, u.z + u.length, u.y + u.height)) && 1 >= a && g.push({
                    obj: u,
                    dst: a
                }));
            if (p)
                for (m = 0; m < this.list.length; ++m)
                    this.list[m].active && t != this.list[m] && (!t.team || t.team != this.list[m].team) && ((u = this.fetchState(this.list[m], t.getStateConst())) && ((a = o.lineInRect(t.x, t.z, f, c, h, d, u.x - this.list[m].scale - e.config.hitBoxPad, u.z - this.list[m].scale - e.config.hitBoxPad, u.y, u.x + this.list[m].scale + e.config.hitBoxPad, u.z + this.list[m].scale + e.config.hitBoxPad, u.y + this.list[m].height + e.config.hitBoxPad)) && 1 >= a && g.push({
                        player: !0,
                        obj: this.list[m],
                        dst: a
                    })));
            t.weapon.range;
            if (g.length) {
                g.sort(o.orderByDst);
                var v = t.weapon.dmg;
                for (m = 0; m < g.length && (u = g[m],
                t.weapon.range * u.dst,
                p) && (p && !e.waitTimers && u.obj && u.obj.health && !u.player && (p.send(t.id, "4"),
                u.obj.health -= v,
                0 >= u.obj.health && (u.obj.active = !1,
                u.obj.health = 0,
                u.obj.destroyedBy = t,
                e.destObjs.push(u.obj.uid),
                p.broadcast("game" + e.sid, "do", u.obj.uid),
                u.obj && u.obj.onDestroy && e.onTrigger(t, u.obj))),
                p && "seek" == t.team && !u.player && u.obj && u.obj.propID && this.changeHealth(t, null, 10) && this.kill(t, null, {}),
                u.obj && (u.obj.onMelee || u.obj.onDamage) && e.onTrigger(t, u.obj),
                u.player || u.obj && u.obj.dummy) && (e.mode && e.mode.onMelee && e.mode.onMelee(e, t, u.obj) && (v = u.obj.health || v),
                this.changeHealth(u.obj, t, v) && (t && (t.melees++,
                p && e.incStat("mk", t)),
                this.kill(u.obj, t, {
                    weaponId: e.weapons.findIndexBySrc(t.weapon.src),
                    weapon: t.weapon
                })),
                !(0 >= (v -= null == t.weapon.pierce ? v : t.weapon.dmg * l.materialDens.flesh * t.weapon.pierce))); ++m)
                    ;
            }
        }
        ;
        var g = [];
        this.shoot = function(r, i) {
            var n = !1;
            if (p && e.incStat("s", r),
            e.config.noReload || r.ammos[r.weaponIndex]--,
            r.didShoot = !0,
            r.burstCount ? r.burstCount-- : r.burstCount = r.weapon.burst ? r.weapon.burst.c - 1 : 0,
            r.reloads[r.weaponIndex] = r.burstCount && r.weapon.burst ? r.weapon.burst.r : r.weapon.rate,
            this.updatePlayerAmmo(r),
            e.playSound) {
                var c = r.ammos[r.weaponIndex] / e.weapons[r.loadout[r.weaponIndex]].ammo
                  , h = e.store.skins[r.skins[r.weaponIndex]]
                  , d = r.weapon.sound + (h && null != h.mid ? "_" + h.mid : "");
                r.isYou && .25 >= c && !r.weapon.nRing ? e.playSound(d, .85, r, !1, o.randFloat(.9, 1) + .15 * (1 - c / .25)) : e.playSound(d, .85, r, !1, o.randFloat(.9, 1))
            }
            if (r.recoilForce += r.weapon.recoil,
            r.isYou) {
                e.controls && e.controls.vibration && e.controls.gamepad._connected && e.controls.gamepad.rumble(r.weapon.rumbleDur || 200, r.weapon.rumble || .5);
                var f = o.randInt(0, 1) ? -r.weapon.recoilR : r.weapon.recoilR;
                r.recoilX += f,
                r.recoilZ += f,
                r.recoilTween && r.recoilTween.stop();
                var m = r.weapon.recoilAnim && r.weapon.recoilAnim.time || r.weapon.rate;
                0 == r.aimVal && r.weapon.recoilAnim && r.weapon.recoilAnim.aimTime && (m = r.weapon.recoilAnim.aimTime),
                r.recoilTween = new TWEEN.Tween(r).to(r.weapon.recoilAnim || {}, .15 * m).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                    r.recoilTween = new TWEEN.Tween(r).to({
                        recoilTweenY: 0,
                        recoilTweenYM: 0,
                        recoilTweenZ: 0
                    }, .95 * m).easing(TWEEN.Easing.Back.Out).start()
                }).start(),
                this.cancelInspect(r)
            }
            if (r.isYou && !this.isWeaponHidden(r, r.weaponIndex)) {
                var v = r.weaponMeshes[r.weaponIndex]
                  , y = 0 == r.aimVal && r.weapon.scope;
                if (a.showMuzzle && !r.weapon.nMuz && (0 == t.useDepthMap || "0" == t.useDepthMap) && !e.controls.camOffset) {
                    for (var b = 0; b < v.muzzles.length; ++b)
                        v.muzzles[b].visible = !0,
                        a.setMaterial(v.muzzles[b], r.weapon.muzID || 2, 1, !0),
                        v.muzzles[b].init(b ? -2 * r.weapon.xOff : 0, r.weapon.muzOffY || 0, -r.weapon.muzOff, 0, 0, 0, 4 * (r.weapon.muzMlt || 1), 1);
                    if (!y)
                        (re = r.weaponMeshes[r.weaponIndex].muzzles[0].getWorldPosition().clone()).project(t.camera),
                        re.x = (re.x + 1) / 2,
                        re.y = (re.y + 1) / 2,
                        t.flash(re.x, re.y)
                }
                if (!r.weapon.nCase && a.active)
                    for (b = 0; b < r.weaponMeshes[r.weaponIndex].casings.length; ++b)
                        if (re = r.weaponMeshes[r.weaponIndex].casings[b].getWorldPosition(),
                        s && 400 < e.now - (r.lastShell || 0) && (r.lastShell = e.now,
                        s.play3D("case_" + o.randInt(0, 1), re.x, re.y, re.z, .65, o.randFloat(.8, 1.3))),
                        !y) {
                            var w = o.randInt(0, 1) ? 1.4 : .8;
                            a.physObj(re.x, re.y, re.z, r.xDire - Math.PI / 2 * (b ? -1 : 1), Math.PI / 5 * o.randFloat(.75, 1.2) * w, 25, !1, r.weapon.caseInd || 1, r)
                        }
            }
            if (null != r.weapon.projectile && p) {
                var x = (r.spread + (r.weapon.innac || 0)) * l.spreadAdj
                  , M = r.xDire + o.randFloat(-x, x)
                  , _ = r.yDire + r.recoilAnimY * l.recoilMlt + o.randFloat(-x, x);
                e.projectiles.init(r.x, r.y + r.height - l.cameraHeight, r.z, M, _, r.weapon.projectile, r, {
                    weaponId: e.weapons.findIndexBySrc(r.weapon.src),
                    weapon: r.weapon
                })
            }
            if (null == r.weapon.projectile || r.weapon.physPow)
                for (var S = 0, T = r.weapon.physPow ? -1 : 0; T < (null == r.weapon.shots ? 1 : r.weapon.shots); ++T) {
                    M = 0,
                    _ = 0;
                    if (r.weapon.cSpread && 0 <= T) {
                        var E = o.randFloat(.14, .19);
                        M = r.xDire + r.weapon.cSpread[S] * E,
                        _ = r.yDire + r.weapon.cSpread[S + 1] * E,
                        S += 2
                    } else {
                        x = 0 <= T ? (r.spread + (r.weapon.innac || 0)) * l.spreadAdj : 0;
                        M = r.xDire + o.randFloat(-x, x),
                        _ = r.yDire + o.randFloat(-x, x)
                    }
                    _ += r.recoilAnimY * l.recoilMlt;
                    var A = r.weapon.range;
                    0 > T && (A = r.weapon.physRang),
                    g.length = 0;
                    for (var P = 0, O = 1 / (A * Math.sin(M + Math.PI) * Math.cos(_)), R = 1 / (A * Math.cos(M + Math.PI) * Math.cos(_)), C = 1 / (A * Math.sin(_)), L = r.y + r.height - l.cameraHeight, I = 0; I < e.map.manager.objects.length; ++I)
                        (u = e.map.manager.objects[I]).active && !u.noShoot && ((P = o.lineInRect(r.x, r.z, L, O, R, C, u.x - u.width, u.z - u.length, u.y - u.height, u.x + u.width, u.z + u.length, u.y + u.height)) && 1 >= P && g.push({
                            obj: u,
                            dst: P
                        }));
                    if (p && 0 <= T)
                        for (I = 0; I < this.list.length; ++I)
                            this.list[I].active && r != this.list[I] && (!r.team || r.team != this.list[I].team) && ((u = this.fetchState(this.list[I], r.getStateConst())) && ((P = o.lineInRect(r.x, r.z, L, O, R, C, u.x - this.list[I].scale - e.config.hitBoxPad, u.z - this.list[I].scale - e.config.hitBoxPad, u.y, u.x + this.list[I].scale + e.config.hitBoxPad, u.z + this.list[I].scale + e.config.hitBoxPad, u.y + this.list[I].height + e.config.hitBoxPad)) && 1 >= P && g.push({
                                player: !0,
                                obj: this.list[I],
                                dst: P
                            })));
                    var k = e.map.terrain;
                    if (k) {
                        var D = k.raycast(r.x, -r.z, L, 1 / O, -1 / R, 1 / C);
                        if (D) {
                            let e = o.getD3D(r.x, L, r.z, D.x, D.z, -D.y);
                            g.push({
                                terrain: !0,
                                dst: e / A
                            })
                        }
                    }
                    var z = A;
                    if (g.length) {
                        g.sort(o.orderByDst);
                        var B = r.weapon.dmg
                          , N = !1;
                        for (I = 0; I < g.length; ++I) {
                            if (z = A * (u = g[I]).dst,
                            0 > T) {
                                var j = (1 - u.dst) * (r.weapon.physPow * (e.config ? e.config.impulseMlt : 1))
                                  , F = j * Math.sin(M + Math.PI) * Math.cos(_);
                                r.xVel -= F;
                                var U = j * Math.cos(M + Math.PI) * Math.cos(_);
                                r.zVel -= U;
                                var G = j * Math.sin(_);
                                r.yVel -= G,
                                r.onGround = !1,
                                p || (i.velObj = {
                                    x: F,
                                    y: U,
                                    z: G
                                });
                                break
                            }
                            if (!p)
                                break;
                            var H = r.weapon.dropStart || 0
                              , V = Math.min(1, 1 - (1 - u.dst) * A / (A - H))
                              , W = B - r.weapon.dmgDrop * V
                              , Y = !1
                              , Z = !1;
                            if (u.player) {
                                var X = L + z * Math.sin(_);
                                Y = u.obj.y + u.obj.height - X < l.headScale,
                                Z = u.obj.y + l.legHeight > X,
                                W *= Y && !r.weapon.noHeadShot ? 1.5 : 1,
                                W *= Z ? .5 : 1,
                                Y || !e.config || !e.config.headshotOnly || (W = 0)
                            }
                            if (p && !e.waitTimers && u.obj && u.obj.health && !u.player && (u.obj.health -= W,
                            p.send(r.id, "4"),
                            0 >= u.obj.health && (u.obj.active = !1,
                            u.obj.health = 0,
                            u.obj.destroyedBy = r,
                            e.destObjs.push(u.obj.uid),
                            p.broadcast("game" + e.sid, "do", u.obj.uid),
                            u.obj && u.obj.onDestroy && e.onTrigger(r, u.obj))),
                            p && "seek" == r.team && !u.player && u.obj && u.obj.propID && this.changeHealth(r, null, 10) && this.kill(r, null, {}),
                            u.obj && (u.obj.onShoot || u.obj.onDamage) && e.onTrigger(r, u.obj),
                            u.player || u.obj && u.obj.dummy) {
                                if (u.player && (n = !0),
                                this.changeHealth(u.obj, r, W, null, Y)) {
                                    var q = {
                                        dst: u.dst,
                                        headShot: Y,
                                        wallbang: N,
                                        weaponId: e.weapons.findIndexBySrc(r.weapon.src),
                                        weapon: r.weapon
                                    };
                                    this.kill(u.obj, r, q)
                                }
                                B -= null == r.weapon.pierce ? B : r.weapon.dmg * l.materialDens.flesh * r.weapon.pierce
                            } else {
                                if (!u.obj || !u.obj.penetrable)
                                    break;
                                N = !0,
                                B -= null == r.weapon.pierce ? B : r.weapon.dmg * l.materialDens.default * r.weapon.pierce
                            }
                            if (0 >= B)
                                break
                        }
                    }
                    if (!(0 > T)) {
                        z -= .12;
                        var J = r.x + z * Math.sin(M + Math.PI) * Math.cos(_)
                          , K = (X = L + z * Math.sin(_),
                        r.z + z * Math.cos(M + Math.PI) * Math.cos(_))
                          , Q = 0
                          , $ = 0;
                        if (g.length && (u.terrain ? $ = Math.PI / 2 : X >= u.obj.y + u.obj.height ? $ = Math.PI / 2 : X <= u.obj.y - u.obj.height ? $ = -Math.PI / 2 : J <= u.obj.x - u.obj.width ? Q = -Math.PI / 2 : J >= u.obj.x + u.obj.width ? Q = Math.PI / 2 : K <= u.obj.z - u.obj.length && (Q = Math.PI),
                        !p && a.effect(J, X, K, Q, $, 0)),
                        p) {
                            var ee = r.weapon && r.weapon.trail ? 1 : 0;
                            for (I = 0; I < this.list.length; ++I)
                                (this.list[I].active || this.list[I].spectating) && this.list[I] != r && (g.length && !u.player ? p.send(this.list[I].id, "9", r.sid, Math.round(J), Math.round(X), Math.round(K), Q.round(1), $.round(1), ee) : p.send(this.list[I].id, "9", r.sid, Math.round(J), Math.round(X), Math.round(K), void 0, void 0, ee))
                        }
                        if (r.isYou && z >= l.tracerMinDst) {
                            var te = o.randInt(0, r.weaponMeshes[r.weaponIndex].muzzles.length - 1)
                              , re = r.weaponMeshes[r.weaponIndex].muzzles[te].getWorldPosition()
                              , ie = r.weapon && r.weapon.scope && 0 == r.aimVal ? 7 : 0
                              , ne = re.x - ie * Math.sin(M + Math.PI) * Math.cos(_)
                              , se = re.y - ie * Math.sin(_)
                              , ae = re.z - ie * Math.cos(M + Math.PI) * Math.cos(_);
                            o.getD3D(ne, se, ae, J, X, K),
                            Q = o.getDir(ae, ne, K, J),
                            $ = o.getDir(o.getDistance(ne, ae, J, K), X, 0, se);
                            a.physObj(ne, se, ae, Q, $, Math.min(z + ie, l.tracerMaxDst), r.weapon && r.weapon.trail, 0, r)
                        }
                    }
                }
            n && p && e.incStat("h", r)
        }
        ,
        this.spray = function(t) {
            if (e.now - t.lastSpray >= l.sprayTimer) {
                g.length = 0;
                for (var r = 0, i = 1 / (l.sprayRange * Math.sin(t.xDire + Math.PI) * Math.cos(t.yDire)), n = 1 / (l.sprayRange * Math.cos(t.xDire + Math.PI) * Math.cos(t.yDire)), s = 1 / (l.sprayRange * Math.sin(t.yDire)), a = 0; a < e.map.manager.objects.length; ++a)
                    (u = e.map.manager.objects[a]).noShoot || u.noVis || (r = o.lineInRect(t.x, t.z, t.y + t.height - l.cameraHeight, i, n, s, u.x - u.width, u.z - u.length, u.y - u.height, u.x + u.width, u.z + u.length, u.y + u.height)) && 1 >= r && g.push({
                        obj: u,
                        dst: r
                    });
                if (g.length && (g.sort(o.orderByDst),
                u = g[0].obj)) {
                    var c = l.sprayRange * g[0].dst - .1
                      , h = t.y + t.height - l.cameraHeight + c * Math.sin(t.yDire)
                      , d = t.x + c * Math.sin(t.xDire + Math.PI) * Math.cos(t.yDire)
                      , f = t.z + c * Math.cos(t.xDire + Math.PI) * Math.cos(t.yDire)
                      , m = 0
                      , v = 0;
                    h >= u.y + u.height ? v = -90 : h <= u.y - u.height ? v = 90 : d <= u.x - u.width ? m = -90 : d >= u.x + u.width ? m = 90 : f <= u.z - u.length && (m = 180);
                    var y = l.sprayScale / 2;
                    if (v) {
                        if (u.width < y || u.length < y)
                            return;
                        f - y < u.z - u.length ? f = u.z - u.length + y : f + y > u.z + u.length && (f = u.z + u.length - y),
                        d - y < u.x - u.width ? d = u.x - u.width + y : d + y > u.x + u.width && (d = u.x + u.width - y)
                    } else {
                        if (u.height < y)
                            return;
                        if (90 == m || -90 == m) {
                            if (u.length < y)
                                return;
                            f - y < u.z - u.length ? f = u.z - u.length + y : f + y > u.z + u.length && (f = u.z + u.length - y)
                        } else {
                            if (u.width < y)
                                return;
                            d - y < u.x - u.width ? d = u.x - u.width + y : d + y > u.x + u.width && (d = u.x + u.width - y)
                        }
                        h + y > u.y + u.height && (h = u.y + u.height - y)
                    }
                    t.lastSpray = e.now,
                    e.playSound && e.playSound("spray", .4, t, !0),
                    p.broadcast("game" + e.sid, "sp", t.sid, t.sprayIndex, d.round(2), h.round(2), f.round(2), m, v)
                }
            }
        }
        ,
        this.interact = function(t, r) {
            if (e.now - t.lastInteract >= l.interactTimer) {
                if (t.lastInteract = e.now,
                !r) {
                    if ("inf" != t.team)
                        for (var i = 0; i < e.map.manager.pickups.length; ++i)
                            if (null != (h = e.map.manager.pickups[i]).pickup && t.collides(h) && -1 == t.loadout.indexOf(h.pickup) && t.score >= h.scoreP) {
                                if (e.weapons[t.loadout[0]] && e.weapons[t.loadout[0]].melee && 1 == t.loadout.length)
                                    u = void 0,
                                    t.loadout[0] = h.pickup,
                                    t.weaponIndex = 0,
                                    h.pickupRep && null == u && this.addPicked(t, h.pickup);
                                else if (e.weapons[h.pickup].type)
                                    e.weapons[t.loadout[0]].type ? (u = t.loadout[0],
                                    t.loadout[0] = h.pickup,
                                    t.weaponIndex = 0) : !e.weapons[t.loadout[0]].type && (u = e.weapons[t.loadout[1]] && e.weapons[t.loadout[1]].melee ? void 0 : t.loadout[1],
                                    t.loadout[1] = h.pickup,
                                    t.weaponIndex = 1),
                                    this.removePicked(t, u),
                                    h.pickupRep && null == u && this.addPicked(t, h.pickup);
                                else if (!e.weapons[h.pickup].type) {
                                    u = e.weapons[t.loadout[0]] && e.weapons[t.loadout[0]].melee ? void 0 : t.loadout[0];
                                    var n = !1;
                                    e.weapons[t.loadout[0]].type ? (t.loadout.splice(0, 0, h.pickup),
                                    e.weapons[t.loadout[1]] && e.weapons[t.loadout[1]].melee && (t.loadout.length = 1),
                                    u = void 0) : !e.weapons[t.loadout[0]].type && (!(e.weapons[t.loadout[0]] && e.weapons[t.loadout[0]].melee) && (n = this.removePicked(t, t.loadout[0])),
                                    t.loadout[0] = h.pickup),
                                    h.pickupRep && (null == u || n) && this.addPicked(t, h.pickup),
                                    t.weaponIndex = 0
                                }
                                h.pickupRep && (h.pickup = u),
                                p.broadcast("game" + e.sid, "inat", t.sid, t.loadout, t.weaponIndex, h.uid, h.pickupRep ? u : h.pickup),
                                t.updateLoadout(e, t.weaponIndex, !0, ...t.loadout),
                                0 == h.scoreP || h.method || (p.send(t.id, "am", ["Purchased", null]),
                                this.score(t, -h.scoreP));
                                break
                            }
                    for (i = 0; i < e.map.manager.gates.length; ++i)
                        if (((h = e.map.manager.gates[i]).active || !h.active && h.closeable) && t.collides(h, h.tRadius) && t.score >= h.scoreP) {
                            0 != h.scoreP && (p.send(t.id, "am", [h.method ? "Unlocked" : "Purchased", null]),
                            !h.method && this.score(t, -h.scoreP)),
                            p.broadcast("game" + e.sid, "gte", h.uid, !h.active && h.closeable),
                            h.active = !h.active;
                            break
                        }
                }
                for (i = 0; i < e.map.manager.banks.length; ++i)
                    if ((h = e.map.manager.banks[i]).active && t.collides(h, h.tRadius)) {
                        0 != h.deposited && r ? h.withdrawAmnt && h.deposited > h.withdrawAmnt ? (h.deposited -= h.withdrawAmnt,
                        this.score(t, h.withdrawAmnt)) : (this.score(t, h.deposited),
                        h.deposited = 0) : 0 != t.score && !r && (h.depositAmnt && t.score > h.depositAmnt ? (h.deposited += h.depositAmnt,
                        this.score(t, -h.depositAmnt)) : (h.deposited += t.score,
                        this.score(t, -t.score))),
                        p.broadcast("game" + e.sid, "bnk", h.uid, h.deposited);
                        break
                    }
            }
        }
        ,
        this.findEmptyPickup = function() {
            for (var t, r = 0; r < e.map.manager.pickups.length; ++r)
                if ((t = e.map.manager.pickups[r]).pickupRep && null == t.pickup)
                    return t.uid;
            return null
        }
        ,
        this.addPicked = function(e, t) {
            -1 == e.lastPicked.indexOf(t) && e.lastPicked.push(t)
        }
        ,
        this.removePicked = function(e, t) {
            var r = e.lastPicked.indexOf(t);
            return -1 < r && e.lastPicked.splice(r, 1),
            -1 < r
        }
        ,
        this.dropWeapon = function(t, r) {
            if (e.map.manager.pickups.length) {
                var i, n = t.weaponIndex, s = t.loadout[n], a = [t.x + o.randInt(-5, 5), t.y + 1, t.z + o.randInt(-5, 5)];
                if (r) {
                    for (var c = 0; c < t.loadout.length; c++)
                        s = t.loadout[c],
                        (i = this.findEmptyPickup()) && -1 < t.lastPicked.indexOf(s) && !e.weapons[s].melee && (a = [t.x + o.randInt(-5, 5), t.y + 1, t.z + o.randInt(-5, 5)],
                        e.updatePickup(i, s, null, a),
                        p.broadcast("game" + e.sid, "inat", -1, null, null, i, s, !0, a));
                    t.lastPicked.length = 0
                } else if (!e.weapons[s].melee) {
                    var l = (i = this.findEmptyPickup()) && -1 < t.lastPicked.indexOf(s);
                    l && (this.removePicked(t, s),
                    e.updatePickup(i, s, null, a)),
                    t.loadout = 1 == t.loadout.length ? [] : [t.loadout[n ? 0 : 1]],
                    t.weaponIndex = 0,
                    p.broadcast("game" + e.sid, "inat", t.sid, t.loadout, t.weaponIndex, i, s, l, a),
                    t.updateLoadout(e, t.weaponIndex, !0, ...t.loadout)
                }
            }
        }
        ,
        this.updateInteract = function(t, r, i="Pickup weapon", n) {
            if ((e.map.manager.pickups.length || e.map.manager.gates.length || e.map.manager.banks.length) && t.isYou) {
                inner = n ? i + "<div style='color: #fff;margin-top:-30px;'>Press <span style='color:" + c.interactPopup.key + "'>[" + o.getKeyName(e.controls.interactKey) + "]</span> to Deposit - " + (n[0] || "All") + "</div><div style='color: #fff;margin-top:-30px;'>Press <span style='color:" + c.interactPopup.key + "'>[" + o.getKeyName(e.controls.interactSecKey) + "]</span> to Withdraw - " + (n[1] || "All") + "</div>" : 'Press <span style="color:' + c.interactPopup.key + '">[' + o.getKeyName(e.controls.interactKey) + "]</span> to " + i;
                var s = r ? "block" : "none";
                interactMsg.innerHTML != inner && (interactMsg.innerHTML = inner),
                interactMsg.style.display != s && (interactMsg.style.display = s)
            }
        }
        ;
        var v = [];
        this.syncLeaders = function() {
            var t = e.mode.leaderStat || "score";
            d = e.mode.killSort ? this.list.slice().sort(o.orderByKills) : this.list.slice().sort(o.orderByScore),
            v.length = 0;
            for (var r = 0, i = 0, n = 0; n < d.length; ++n)
                d[n].spectating ? d[n].account && d[n].account.moderator || i++ : 10 > r && (r++,
                v.push(d[n].sid, d[n].account ? d[n].account.name : d[n].name, d[n].team, e.mode.killSort ? d[n].kills : l.endForm[t] ? l.endForm[t](d[n][t], e, d[n]) : d[n][t], d[n].account ? d[n].account.clan : 0, d[n].account ? d[n].account.featured : 0));
            p.broadcast("game" + e.sid, "7", v, i)
        }
        ,
        this.saveClassScores = function(t) {
            if (t.classScores)
                for (var r = 0; r < e.config.classes.length; ++r)
                    t.classScores[r] && (t.account.stats["c" + r] || (t.account.stats["c" + r] = 0),
                    t.account.stats["c" + r] += t.classScores[r])
        }
        ,
        this.score = function(t, r, i) {
            p && (t.score += r,
            null == e.host && 13e3 < t.score && (t.score = 13e3,
            r = 0),
            p.send(t.id, "5", r),
            this.syncLeaders(),
            null == e.host && (!t.classScores[t.classIndex] && (t.classScores[t.classIndex] = 0),
            t.classScores[t.classIndex] += r),
            e.mode.teams && t.team && e.teams && !e.mode.noScoreC && (!i || !e.mode.objective) && (e.teams[t.team] ? e.teams[t.team] += r : e.teams[t.team] = r,
            p.broadcast("game" + e.sid, "ts", t.team, e.teams[t.team])))
        }
        ,
        this.tickPlayer = function(e, t) {
            e.playTime += t,
            0 < e.hitTimer && (e.hitTimer -= t),
            e.ticker -= t,
            0 >= e.ticker && (e.ticker = 500,
            0 >= e.hitTimer && !e.challMode && this.changeHealth(e, null, -e.maxHealth * (e.regen || 0)))
        }
        ,
        this.changeHealth = function(t, r, i, n, s) {
            if ((!e.waitTimers || e.waitTimers[0].canDMG) && !(0 > i && t.health == t.maxHealth) && (r && r.account && r.account.hack && i && (i *= .2),
            r && .1 <= r.avgSpn && (i *= .2),
            r && r.isHacker && (i *= .1),
            r && r.lastHack && 400 >= e.now - r.lastHack && (i *= .2),
            !(!n && t.team && r && t.team == r.team && 0 < i))) {
                if (r && r != t && 0 < i && p.send(r.id, "4", t.sid, Math.round(i), s),
                t.dummy)
                    return !0;
                0 < i && (t.hitTimer = t.regenDelay || 0),
                t.health -= i,
                t.health = Math.max(Math.min(t.maxHealth, t.health), 0),
                t.godMode && (t.health = t.maxHealth),
                r ? (p.send(t.id, "h", Math.ceil(t.health), null, Math.round(r.x), Math.round(r.z)),
                r != t && (t.dmgReceived[r.id] ? (t.dmgReceived[r.id].val += i,
                t.dmgReceived[r.id].time = e.now) : t.dmgReceived[r.id] = {
                    time: e.now,
                    val: i
                })) : p.send(t.id, "h", Math.ceil(t.health));
                for (var a = 0; a < this.list.length; ++a)
                    this.list[a] != t && p.send(this.list[a].id, "h", Math.ceil(t.health), t.sid);
                return 0 >= t.health
            }
        }
        ,
        this.changePosition = function(e, t, r, i, n) {
            e.x = e.oldX = t,
            e.y = e.oldY = r,
            e.z = e.oldZ = i,
            n && (e.lastX = t,
            e.lastY = r,
            e.lastZ = i,
            e.stepVal = 0,
            e.xVel = 0,
            e.yVel = 0,
            e.zVel = 0)
        }
        ,
        this.swapMelee = function(e, t) {
            1 >= e.ammos.length || (e.weaponIndex == e.ammos.length - 1 ? this.swapWeapon(e, 1, !1, void 0, void 0, t) : this.swapWeapon(e, null, null, void 0, e.ammos.length - 1, t))
        }
        ,
        this.swapSecondary = function(t, r) {
            if (!(1 >= t.ammos.length))
                for (var i, n = 0; n < t.ammos.length; ++n)
                    i = t.loadout[n],
                    e.weapons[i] && e.weapons[i].secondary && (t.weaponIndex == n ? this.swapWeapon(t, null, null, void 0, 0, r) : this.swapWeapon(t, null, null, void 0, n, r))
        }
        ,
        this.swapWeapon = function(r, i, n, s, a, c) {
            if (!(1 >= r.ammos.length && i || s > r.ammos.length)) {
                var l = r.weaponIndex;
                if (i && (1 != i && -1 != i && (i = 0),
                r.weaponIndex += i,
                1 == i ? r.weaponIndex > r.ammos.length - 2 && (r.weaponIndex = 0) : 0 > r.weaponIndex ? r.weaponIndex = Math.min(r.ammos.length - 1, 2) : r.weaponIndex = 0),
                null != s && (r.weaponIndex = s),
                null != a && (r.weaponIndex = a),
                (null != i || null != a) && (l != r.weaponIndex || n) && (r.reloadTimer = 0,
                r.didShoot = !1,
                r.burstCount = 0),
                r.weapon = e.weapons[r.loadout[r.weaponIndex]],
                r.weapon || (r.weapon = e.weapons[r.loadout[0]],
                r.weapon && (r.weaponIndex = 0)),
                t && (l != r.weaponIndex || n)) {
                    this.cancelInspect(r);
                    for (var p = 0; p < r.weaponMeshes.length; ++p)
                        r.weaponMeshes[p].visible = !1;
                    r.weaponMeshes[r.weaponIndex] && (r.weaponMeshes[r.weaponIndex].visible = !this.isWeaponHidden(r, r.weaponIndex) || !r.isYou)
                }
                if (null == s && r.weapon && (!t || r.isYou) && (r.isYou && l == r.weaponIndex || c || (r.swapTime = r.weapon.swapTime),
                r.isYou && (l != r.weaponIndex || n))) {
                    var h, u = "";
                    for (p = 0; p < r.ammos.length; ++p)
                        h = p == r.weaponIndex,
                        e.weapons[r.loadout[p]].icon && (u += "<div class='weaponItem'>" + (0 < p ? "<div class='weapKey'>" + (e.weapons[r.loadout[p]].melee ? "[" + o.getKeyName(e.controls.meleeKey) + "]" : "[" + o.getKeyName(e.controls.swapKey) + "]") + "</div>" : "") + "<img style='opacity:" + (h ? 1 : .7) + (p ? ";margin-right:25px" : "") + "' class='weaponIcon' src='" + o.assetsUrl((e.weapons[r.loadout[p]].melee ? "/textures/melee/icon_" + (e.store.skins[r.meleeIndex] && e.store.skins[r.meleeIndex].id || 0) : "https://hoodgail.github.io/krunker_assets/weapons/" + e.weapons[r.loadout[p]].icon) + ".png") + "' /></div>");
                    c || (r.swapTween && r.swapTween.stop(),
                    r.swapTweenA = .5,
                    r.swapTween = new TWEEN.Tween(r).to({
                        swapTweenA: 1
                    }, 1200).easing(TWEEN.Easing.Elastic.Out).start(),
                    l != r.weaponIndex && 1 == r.aimVal && (r.swapTweenAnim && r.swapTweenAnim.stop(),
                    r.swapTweenR = r.weapon.swapWiggle || .6,
                    r.swapTweenAnim = new TWEEN.Tween(r).to({
                        swapTweenR: 0
                    }, r.weapon.swapTime + 220).easing(TWEEN.Easing.Back.InOut).start()),
                    l != r.weaponIndex && 1 == r.aimVal && (r.meleeAnim.anim && r.meleeAnim.anim.stop(),
                    r.resetMeleeAnim(),
                    r.meleeAnim.armR = .15,
                    r.weapon.melee && (r.meleeAnim.anim = new TWEEN.Tween(r.meleeAnim).to({
                        armR: 0
                    }, 700).easing(TWEEN.Easing.Back.InOut).start()))),
                    weaponDisplay.innerHTML = u,
                    this.updatePlayerAmmo(r)
                }
            }
        }
        ,
        this.taunt = function(t, r) {
            t && t.active && l.taunts[r] && (!t.lastTaunt || 0 <= e.now - t.lastTaunt) && (t.lastTaunt = e.now + l.taunts[r].tm,
            e.playSound(l.taunts[r].id, .3, t, !0, o.randFloat(.9, 1)))
        }
        ,
        this.checkStreak = function(t) {
            for (var r = 0; r < e.streaks.length; ++r)
                t.realKillStreak == e.streaks[r].kills && this.addStreak(t, r);
            t.realKillStreak >= e.maxStreak && (t.realKillStreak = 0)
        }
        ,
        this.useStreak = function(t, r) {
            t.streaks[r] && t.streaks[r].streak.activate(e, t) && (1 < t.streaks[r].cnt ? t.streaks[r].cnt-- : t.streaks[r] = null,
            p.send(t.id, "st", r, t.streaks[r] && t.streaks[r].cnt || 0))
        }
        ,
        this.addStreak = function(t, r) {
            t.streaks[r] ? t.streaks[r].cnt++ : t.streaks[r] = {
                cnt: 1,
                streak: e.streaks[r]
            },
            p.send(t.id, "st", r, t.streaks[r].cnt)
        }
        ,
        this.kill = function(t, r, i, n, s) {
            if (t.dummy || t.active) {
                var a = !1;
                if (t.dummy || (t.active = !1,
                t.isYou && this.toggleAim(t, 0),
                t.objInstances && this.disposeMesh(t)),
                p) {
                    var o, c = 0;
                    if (t.deaths++,
                    t.deathInfo.doer = r,
                    t.deathInfo.time = e.now,
                    t.deathInfo.tillNext = e.forceSpawn ? 1e3 * e.forceSpawn + l.deathDelay : null,
                    e.mode.noStreaks || e.config.noStreaks || t.deathStreak++,
                    t.lives && !e.waitTimers && (t.lives--,
                    p.send(t.id, "lv", t.lives)),
                    e.kills++,
                    r && r != t && (!t.dummy && r.kills++,
                    !(e.mode.noStreaks || e.config.noStreaks) && (r.streak++,
                    r.killStreak++,
                    r.realKillStreak++,
                    r.deathStreak = 0,
                    this.checkStreak(r),
                    0 == r.killStreak % 5 && (c = r.killStreak),
                    e.now - r.lastKill >= l.feedTimer && (r.streak = 0)),
                    r.lastKill = e.now,
                    !s && e.config.killRewards && !e.mode.noKillRewards && ((o = f.reward(this, r, t, i, e)) && p.send(r.id, "6", o, i.headShot ? 1 : 0, r.kills),
                    this.score(r, f.getScore(o), !0),
                    a = !0),
                    e.players.dropWeapon(t, !0)),
                    i && i.weapon && delete i.weapon,
                    !t.dummy)
                        for (var h = 0; h < this.list.length; ++h)
                            !e.mode.noAssists && t.dmgReceived[this.list[h].id] && r != this.list[h] && t.dmgReceived[this.list[h].id].val >= l.assistMin && e.now - t.dmgReceived[this.list[h].id].time <= l.assistTime && (this.list[h].assists++,
                            this.score(this.list[h], l.assistScore, !0),
                            p.send(this.list[h].id, "10"),
                            a = !0),
                            this.list[h] == t ? p.send(t.id, "3", t.sid, t.deaths, r ? r.sid : 0, [r ? null == i.weaponId ? r.loadout[r.weaponIndex] : i.weaponId : -1, o ? f.getScore(o) : 0, r && r.account && r.account.stats["c" + r.classIndex] ? r.account.stats["c" + r.classIndex] : 0], i, n) : p.send(this.list[h].id, "3", t.sid, t.deaths, r ? r.sid : 0, null, i, n);
                    e.mode.onKill && e.mode.onKill(e, p, t, r, i),
                    c && p.broadcast("game" + e.sid, "kst", r.sid, c)
                }
                p && !a && this.syncLeaders()
            }
        }
        ,
        this.indexBySid = function(e) {
            for (var t = 0; t < this.list.length; ++t)
                if (this.list[t].sid == e)
                    return t;
            return -1
        }
        ,
        this.findBySid = function(e) {
            for (var t = 0; t < this.list.length; ++t)
                if (this.list[t].sid === e)
                    return this.list[t];
            return null
        }
    }
}
, function(e, t, r) {
    "use strict";
    r.r(t);
    var i = {};
    r.r(i),
    r.d(i, "FunctionToString", function() {
        return A
    }),
    r.d(i, "InboundFilters", function() {
        return z
    });
    var n = {};
    r.r(n),
    r.d(n, "GlobalHandlers", function() {
        return ke
    }),
    r.d(n, "TryCatch", function() {
        return Pe
    }),
    r.d(n, "Breadcrumbs", function() {
        return Le
    }),
    r.d(n, "LinkedErrors", function() {
        return Be
    }),
    r.d(n, "UserAgent", function() {
        return je
    });
    var s = {};
    r.r(s),
    r.d(s, "BaseTransport", function() {
        return he
    }),
    r.d(s, "FetchTransport", function() {
        return de
    }),
    r.d(s, "XHRTransport", function() {
        return fe
    });
    var a, o, c, l = r(0);
    (o = a || (a = {})).Fatal = "fatal",
    o.Error = "error",
    o.Warning = "warning",
    o.Log = "log",
    o.Info = "info",
    o.Debug = "debug",
    o.Critical = "critical",
    function(e) {
        e.fromString = function(t) {
            switch (t) {
            case "debug":
                return e.Debug;
            case "info":
                return e.Info;
            case "warn":
            case "warning":
                return e.Warning;
            case "error":
                return e.Error;
            case "fatal":
                return e.Fatal;
            case "critical":
                return e.Critical;
            case "log":
            default:
                return e.Log
            }
        }
    }(a || (a = {})),
    function(e) {
        e.Unknown = "unknown",
        e.Skipped = "skipped",
        e.Success = "success",
        e.RateLimit = "rate_limit",
        e.Invalid = "invalid",
        e.Failed = "failed"
    }(c || (c = {})),
    function(e) {
        e.fromHttpCode = function(t) {
            return 200 <= t && 300 > t ? e.Success : 429 === t ? e.RateLimit : 400 <= t && 500 > t ? e.Invalid : 500 <= t ? e.Failed : e.Unknown
        }
    }(c || (c = {}));
    var p = r(9);
    function h(e) {
        for (var t = [], r = 1; r < arguments.length; r++)
            t[r - 1] = arguments[r];
        var i = Object(p.b)();
        if (i && i[e])
            return i[e].apply(i, l.d(t));
        throw new Error("No hub defined or " + e + " was not found on the hub, please open a bug report.")
    }
    function u(e) {
        var t;
        try {
            throw new Error("Sentry syntheticException")
        } catch (e) {
            t = e
        }
        return h("captureException", e, {
            originalException: e,
            syntheticException: t
        })
    }
    function d(e, t) {
        var r;
        try {
            throw new Error(e)
        } catch (e) {
            r = e
        }
        return h("captureMessage", e, t, {
            originalException: e,
            syntheticException: r
        })
    }
    function f(e) {
        return h("captureEvent", e)
    }
    function m(e) {
        h("configureScope", e)
    }
    function g(e) {
        h("addBreadcrumb", e)
    }
    function v(e, t) {
        h("setContext", e, t)
    }
    function y(e) {
        h("setExtras", e)
    }
    function b(e) {
        h("setTags", e)
    }
    function w(e, t) {
        h("setExtra", e, t)
    }
    function x(e, t) {
        h("setTag", e, t)
    }
    function M(e) {
        h("setUser", e)
    }
    function _(e) {
        h("withScope", e)
    }
    var S, T = r(10), E = r(13), A = function() {
        function e() {
            this.name = e.id
        }
        return e.prototype.setupOnce = function() {
            S = Function.prototype.toString,
            Function.prototype.toString = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                var r = this.__sentry__ ? this.__sentry_original__ : this;
                return S.apply(r, e)
            }
        }
        ,
        e.id = "FunctionToString",
        e
    }(), P = r(25), O = r(2), R = r(5);
    function C(e, t) {
        return void 0 === t && (t = 0),
        "string" != typeof e || 0 === t ? e : e.length <= t ? e : e.substr(0, t) + "..."
    }
    function L(e, t) {
        if (!Array.isArray(e))
            return "";
        for (var r, i = [], n = 0; n < e.length; n++) {
            r = e[n];
            try {
                i.push(r + "")
            } catch (e) {
                i.push("[value cannot be serialized]")
            }
        }
        return i.join(t)
    }
    function I(e, t) {
        if (void 0 === t && (t = 40),
        !e.length)
            return "[object has no keys]";
        if (e[0].length >= t)
            return C(e[0], t);
        for (var r, i = e.length; 0 < i; i--)
            if (!((r = e.slice(0, i).join(", ")).length > t))
                return i === e.length ? r : C(r, t);
        return ""
    }
    function k(e, t) {
        return Object(R.g)(t) ? t.test(e) : !("string" != typeof t) && e.includes(t)
    }
    var D = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/]
      , z = function() {
        function e(t) {
            void 0 === t && (t = {}),
            this._options = t,
            this.name = e.id
        }
        return e.prototype.setupOnce = function() {
            Object(T.b)(function(t) {
                var r = Object(p.b)();
                if (!r)
                    return t;
                var i = r.getIntegration(e);
                if (i) {
                    var n = r.getClient()
                      , s = n ? n.getOptions() : {}
                      , a = i._mergeOptions(s);
                    if (i._shouldDropEvent(t, a))
                        return null
                }
                return t
            })
        }
        ,
        e.prototype._shouldDropEvent = function(e, t) {
            return this._isSentryError(e, t) ? (P.a.warn("Event dropped due to being internal Sentry Error.\nEvent: " + Object(O.d)(e)),
            !0) : this._isIgnoredError(e, t) ? (P.a.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + Object(O.d)(e)),
            !0) : this._isBlacklistedUrl(e, t) ? (P.a.warn("Event dropped due to being matched by `blacklistUrls` option.\nEvent: " + Object(O.d)(e) + ".\nUrl: " + this._getEventFilterUrl(e)),
            !0) : !this._isWhitelistedUrl(e, t) && (P.a.warn("Event dropped due to not being matched by `whitelistUrls` option.\nEvent: " + Object(O.d)(e) + ".\nUrl: " + this._getEventFilterUrl(e)),
            !0)
        }
        ,
        e.prototype._isSentryError = function(e, t) {
            if (void 0 === t && (t = {}),
            !t.ignoreInternal)
                return !1;
            try {
                return "SentryError" === e.exception.values[0].type
            } catch (e) {
                return !1
            }
        }
        ,
        e.prototype._isIgnoredError = function(e, t) {
            return void 0 === t && (t = {}),
            !(!t.ignoreErrors || !t.ignoreErrors.length) && this._getPossibleEventMessages(e).some(function(e) {
                return t.ignoreErrors.some(function(t) {
                    return k(e, t)
                })
            })
        }
        ,
        e.prototype._isBlacklistedUrl = function(e, t) {
            if (void 0 === t && (t = {}),
            !t.blacklistUrls || !t.blacklistUrls.length)
                return !1;
            var r = this._getEventFilterUrl(e);
            return !!r && t.blacklistUrls.some(function(e) {
                return k(r, e)
            })
        }
        ,
        e.prototype._isWhitelistedUrl = function(e, t) {
            if (void 0 === t && (t = {}),
            !t.whitelistUrls || !t.whitelistUrls.length)
                return !0;
            var r = this._getEventFilterUrl(e);
            return !r || t.whitelistUrls.some(function(e) {
                return k(r, e)
            })
        }
        ,
        e.prototype._mergeOptions = function(e) {
            return void 0 === e && (e = {}),
            {
                blacklistUrls: l.d(this._options.blacklistUrls || [], e.blacklistUrls || []),
                ignoreErrors: l.d(this._options.ignoreErrors || [], e.ignoreErrors || [], D),
                ignoreInternal: void 0 === this._options.ignoreInternal || this._options.ignoreInternal,
                whitelistUrls: l.d(this._options.whitelistUrls || [], e.whitelistUrls || [])
            }
        }
        ,
        e.prototype._getPossibleEventMessages = function(e) {
            if (e.message)
                return [e.message];
            if (e.exception)
                try {
                    var t = e.exception.values[0]
                      , r = t.type
                      , i = t.value;
                    return ["" + i, r + ": " + i]
                } catch (t) {
                    return P.a.error("Cannot extract message for event " + Object(O.d)(e)),
                    []
                }
            return []
        }
        ,
        e.prototype._getEventFilterUrl = function(e) {
            try {
                if (e.stacktrace) {
                    var t = e.stacktrace.frames;
                    return t[t.length - 1].filename
                }
                if (e.exception) {
                    var r = e.exception.values[0].stacktrace.frames;
                    return r[r.length - 1].filename
                }
                return null
            } catch (t) {
                return P.a.error("Cannot extract url for event " + Object(O.d)(e)),
                null
            }
        }
        ,
        e.id = "InboundFilters",
        e
    }()
      , B = r(6)
      , N = function(e) {
        function t(t) {
            var r = this.constructor
              , i = e.call(this, t) || this;
            return i.message = t,
            i.name = r.prototype.constructor.name,
            Object.setPrototypeOf(i, r.prototype),
            i
        }
        return l.b(t, e),
        t
    }(Error)
      , j = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w\.-]+)(?::(\d+))?\/(.+)/
      , F = function() {
        function e(e) {
            "string" == typeof e ? this._fromString(e) : this._fromComponents(e),
            this._validate()
        }
        return e.prototype.toString = function(e) {
            void 0 === e && (e = !1);
            var t = this
              , r = t.host
              , i = t.path
              , n = t.pass
              , s = t.port
              , a = t.projectId;
            return t.protocol + "://" + t.user + (e && n ? ":" + n : "") + "@" + r + (s ? ":" + s : "") + "/" + (i ? i + "/" : i) + a
        }
        ,
        e.prototype._fromString = function(e) {
            var t = j.exec(e);
            if (!t)
                throw new N("Invalid Dsn");
            var r = l.c(t.slice(1), 6)
              , i = r[0]
              , n = r[1]
              , s = r[2]
              , a = void 0 === s ? "" : s
              , o = r[3]
              , c = r[4]
              , p = void 0 === c ? "" : c
              , h = ""
              , u = r[5]
              , d = u.split("/");
            1 < d.length && (h = d.slice(0, -1).join("/"),
            u = d.pop()),
            Object.assign(this, {
                host: o,
                pass: a,
                path: h,
                projectId: u,
                port: p,
                protocol: i,
                user: n
            })
        }
        ,
        e.prototype._fromComponents = function(e) {
            this.protocol = e.protocol,
            this.user = e.user,
            this.pass = e.pass || "",
            this.host = e.host,
            this.port = e.port || "",
            this.path = e.path || "",
            this.projectId = e.projectId
        }
        ,
        e.prototype._validate = function() {
            var e = this;
            if (["protocol", "user", "host", "projectId"].forEach(function(t) {
                if (!e[t])
                    throw new N("Invalid Dsn")
            }),
            "http" !== this.protocol && "https" !== this.protocol)
                throw new N("Invalid Dsn");
            if (this.port && Number.isNaN(parseInt(this.port, 10)))
                throw new N("Invalid Dsn")
        }
        ,
        e
    }()
      , U = function() {
        function e(e) {
            this.dsn = e,
            this._dsnObject = new F(e)
        }
        return e.prototype.getDsn = function() {
            return this._dsnObject
        }
        ,
        e.prototype.getStoreEndpoint = function() {
            return "" + this._getBaseUrl() + this.getStoreEndpointPath()
        }
        ,
        e.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
            var e = {
                sentry_key: this._dsnObject.user,
                sentry_version: "7"
            };
            return this.getStoreEndpoint() + "?" + Object(B.d)(e)
        }
        ,
        e.prototype._getBaseUrl = function() {
            var e = this._dsnObject
              , t = e.protocol ? e.protocol + ":" : ""
              , r = e.port ? ":" + e.port : "";
            return t + "//" + e.host + r
        }
        ,
        e.prototype.getStoreEndpointPath = function() {
            var e = this._dsnObject;
            return (e.path ? "/" + e.path : "") + "/api/" + e.projectId + "/store/"
        }
        ,
        e.prototype.getRequestHeaders = function(e, t) {
            var r = this._dsnObject
              , i = ["Sentry sentry_version=7"];
            return i.push("sentry_timestamp=" + (new Date).getTime()),
            i.push("sentry_client=" + e + "/" + t),
            i.push("sentry_key=" + r.user),
            r.pass && i.push("sentry_secret=" + r.pass),
            {
                "Content-Type": "application/json",
                "X-Sentry-Auth": i.join(", ")
            }
        }
        ,
        e.prototype.getReportDialogEndpoint = function(e) {
            void 0 === e && (e = {});
            var t = this._dsnObject
              , r = this._getBaseUrl() + (t.path ? "/" + t.path : "") + "/api/embed/error-page/"
              , i = [];
            for (var n in i.push("dsn=" + t.toString()),
            e)
                if ("user" == n) {
                    if (!e.user)
                        continue;
                    e.user.name && i.push("name=" + encodeURIComponent(e.user.name)),
                    e.user.email && i.push("email=" + encodeURIComponent(e.user.email))
                } else
                    i.push(encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
            return i.length ? r + "?" + i.join("&") : r
        }
        ,
        e
    }()
      , G = r(72)
      , H = [];
    function V(e) {
        var t = {};
        return function(e) {
            var t = e.defaultIntegrations && l.d(e.defaultIntegrations) || []
              , r = e.integrations
              , i = [];
            if (Array.isArray(r)) {
                var n = r.map(function(e) {
                    return e.name
                })
                  , s = [];
                t.forEach(function(e) {
                    -1 === n.indexOf(e.name) && -1 === s.indexOf(e.name) && (i.push(e),
                    s.push(e.name))
                }),
                r.forEach(function(e) {
                    -1 === s.indexOf(e.name) && (i.push(e),
                    s.push(e.name))
                })
            } else {
                if ("function" != typeof r)
                    return l.d(t);
                i = r(t),
                i = Array.isArray(i) ? i : [i]
            }
            return i
        }(e).forEach(function(e) {
            t[e.name] = e,
            function(e) {
                -1 !== H.indexOf(e.name) || (e.setupOnce(T.b, p.b),
                H.push(e.name),
                P.a.log("Integration installed: " + e.name))
            }(e)
        }),
        t
    }
    var W = function() {
        function e(e, t) {
            this._processing = !1,
            this._backend = new e(t),
            this._options = t,
            t.dsn && (this._dsn = new F(t.dsn)),
            this._integrations = V(this._options)
        }
        return e.prototype.captureException = function(e, t, r) {
            var i = this
              , n = t && t.event_id;
            return this._processing = !0,
            this._getBackend().eventFromException(e, t).then(function(e) {
                return i._processEvent(e, t, r)
            }).then(function(e) {
                n = e && e.event_id,
                i._processing = !1
            }).catch(function(e) {
                P.a.error(e),
                i._processing = !1
            }),
            n
        }
        ,
        e.prototype.captureMessage = function(e, t, r, i) {
            var n = this
              , s = r && r.event_id;
            return this._processing = !0,
            (Object(R.f)(e) ? this._getBackend().eventFromMessage("" + e, t, r) : this._getBackend().eventFromException(e, r)).then(function(e) {
                return n._processEvent(e, r, i)
            }).then(function(e) {
                s = e && e.event_id,
                n._processing = !1
            }).catch(function(e) {
                P.a.error(e),
                n._processing = !1
            }),
            s
        }
        ,
        e.prototype.captureEvent = function(e, t, r) {
            var i = this
              , n = t && t.event_id;
            return this._processing = !0,
            this._processEvent(e, t, r).then(function(e) {
                n = e && e.event_id,
                i._processing = !1
            }).catch(function(e) {
                P.a.error(e),
                i._processing = !1
            }),
            n
        }
        ,
        e.prototype.getDsn = function() {
            return this._dsn
        }
        ,
        e.prototype.getOptions = function() {
            return this._options
        }
        ,
        e.prototype.flush = function(e) {
            var t = this;
            return this._isClientProcessing(e).then(function(r) {
                return t._processingInterval && clearInterval(t._processingInterval),
                t._getBackend().getTransport().close(e).then(function(e) {
                    return r && e
                })
            })
        }
        ,
        e.prototype.close = function(e) {
            var t = this;
            return this.flush(e).then(function(e) {
                return t.getOptions().enabled = !1,
                e
            })
        }
        ,
        e.prototype.getIntegrations = function() {
            return this._integrations || {}
        }
        ,
        e.prototype.getIntegration = function(e) {
            try {
                return this._integrations[e.id] || null
            } catch (t) {
                return P.a.warn("Cannot retrieve integration " + e.id + " from the current Client"),
                null
            }
        }
        ,
        e.prototype._isClientProcessing = function(e) {
            var t = this;
            return new Promise(function(r) {
                var i = 0;
                t._processingInterval && clearInterval(t._processingInterval),
                t._processingInterval = setInterval(function() {
                    t._processing ? (i += 1,
                    e && i >= e && r(!1)) : r(!0)
                }, 1)
            }
            )
        }
        ,
        e.prototype._getBackend = function() {
            return this._backend
        }
        ,
        e.prototype._isEnabled = function() {
            return !1 !== this.getOptions().enabled && void 0 !== this._dsn
        }
        ,
        e.prototype._prepareEvent = function(e, t, r) {
            var i = this.getOptions()
              , n = i.environment
              , s = i.release
              , a = i.dist
              , o = i.maxValueLength
              , c = void 0 === o ? 250 : o
              , p = l.a({}, e);
            void 0 === p.environment && void 0 !== n && (p.environment = n),
            void 0 === p.release && void 0 !== s && (p.release = s),
            void 0 === p.dist && void 0 !== a && (p.dist = a),
            p.message && (p.message = C(p.message, c));
            var h = p.exception && p.exception.values && p.exception.values[0];
            h && h.value && (h.value = C(h.value, c));
            var u = p.request;
            u && u.url && (u.url = C(u.url, c)),
            void 0 === p.event_id && (p.event_id = Object(O.g)()),
            this._addIntegrations(p.sdk);
            var d = G.a.resolve(p);
            return t && (d = t.applyToEvent(p, r)),
            d
        }
        ,
        e.prototype._addIntegrations = function(e) {
            var t = Object.keys(this._integrations);
            e && 0 < t.length && (e.integrations = t)
        }
        ,
        e.prototype._processEvent = function(e, t, r) {
            var i = this
              , n = this.getOptions()
              , s = n.beforeSend
              , a = n.sampleRate;
            return this._isEnabled() ? "number" == typeof a && Math.random() > a ? G.a.reject("This event has been sampled, will not send event.") : new G.a(function(n, a) {
                i._prepareEvent(e, r, t).then(function(e) {
                    if (null !== e) {
                        var r = e;
                        try {
                            if (t && t.data && !0 === t.data.__sentry__ || !s)
                                return i._getBackend().sendEvent(r),
                                void n(r);
                            var o = s(e, t);
                            if (void 0 === o)
                                P.a.error("`beforeSend` method has to return `null` or a valid event.");
                            else if (Object(R.j)(o))
                                i._handleAsyncBeforeSend(o, n, a);
                            else {
                                if (null === (r = o))
                                    return P.a.log("`beforeSend` returned `null`, will not send event."),
                                    void n(null);
                                i._getBackend().sendEvent(r),
                                n(r)
                            }
                        } catch (e) {
                            i.captureException(e, {
                                data: {
                                    __sentry__: !0
                                },
                                originalException: e
                            }),
                            a("`beforeSend` throw an error, will not send event.")
                        }
                    } else
                        a("An event processor returned null, will not send event.")
                })
            }
            ) : G.a.reject("SDK not enabled, will not send event.")
        }
        ,
        e.prototype._handleAsyncBeforeSend = function(e, t, r) {
            var i = this;
            e.then(function(e) {
                return null === e ? void r("`beforeSend` returned `null`, will not send event.") : (i._getBackend().sendEvent(e),
                void t(e))
            }).catch(function(e) {
                r("beforeSend rejected with " + e)
            })
        }
        ,
        e
    }()
      , Y = function() {
        function e() {}
        return e.prototype.sendEvent = function() {
            return Promise.resolve({
                reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
                status: c.Skipped
            })
        }
        ,
        e.prototype.close = function() {
            return Promise.resolve(!0)
        }
        ,
        e
    }()
      , Z = function() {
        function e(e) {
            this._options = e,
            this._options.dsn || P.a.warn("No DSN provided, backend will not do anything."),
            this._transport = this._setupTransport()
        }
        return e.prototype._setupTransport = function() {
            return new Y
        }
        ,
        e.prototype.eventFromException = function() {
            throw new N("Backend has to implement `eventFromException` method")
        }
        ,
        e.prototype.eventFromMessage = function() {
            throw new N("Backend has to implement `eventFromMessage` method")
        }
        ,
        e.prototype.sendEvent = function(e) {
            this._transport.sendEvent(e).catch(function(e) {
                P.a.error("Error while sending event: " + e)
            })
        }
        ,
        e.prototype.getTransport = function() {
            return this._transport
        }
        ,
        e
    }();
    function X() {
        if (!("fetch"in Object(O.e)()))
            return !1;
        try {
            return new Headers,
            new Request(""),
            new Response,
            !0
        } catch (e) {
            return !1
        }
    }
    function q() {
        if (!X())
            return !1;
        try {
            return new Request("_",{
                referrerPolicy: "origin"
            }),
            !0
        } catch (e) {
            return !1
        }
    }
    /**
 * TraceKit - Cross brower stack traces
 *
 * This was originally forked from github.com/occ/TraceKit, but has since been
 * largely modified and is now maintained as part of Sentry JS SDK.
 *
 * NOTE: Last merge with upstream repository
 * Jul 11,2018 - #f03357c
 *
 * https://github.com/csnover/TraceKit
 * @license MIT
 * @namespace TraceKit
 */
    var J = Object(O.e)()
      , K = {
        _report: !1,
        _collectWindowErrors: !1,
        _computeStackTrace: !1,
        _linesOfContext: !1
    }
      , Q = "?"
      , $ = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;
    function ee(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    function te() {
        return "undefined" == typeof document || null == document.location ? "" : document.location.href
    }
    K._report = function() {
        function e(e, t, r) {
            var i = null;
            if (!t || K._collectWindowErrors) {
                for (var n in o)
                    if (ee(o, n))
                        try {
                            o[n](e, t, r)
                        } catch (e) {
                            i = e
                        }
                if (i)
                    throw i
            }
        }
        function t(t, r, n, a, o) {
            var c = null;
            if (o = Object(R.d)(o) ? o.error : o,
            t = Object(R.d)(t) ? t.message : t,
            p)
                K._computeStackTrace._augmentStackTraceWithInitialElement(p, r, n, t),
                i();
            else if (o && Object(R.c)(o))
                (c = K._computeStackTrace(o)).mechanism = "onerror",
                e(c, !0, o);
            else {
                var h, u = {
                    url: r,
                    line: n,
                    column: a
                }, d = t;
                if ("[object String]" === {}.toString.call(t)) {
                    var f = t.match($);
                    f && (h = f[1],
                    d = f[2])
                }
                u.func = Q,
                u.context = null,
                e(c = {
                    name: h,
                    message: d,
                    mode: "onerror",
                    mechanism: "onerror",
                    stack: [l.a({}, u, {
                        url: u.url || te()
                    })]
                }, !0, null)
            }
            return !!s && s.apply(this, arguments)
        }
        function r(t) {
            var r = t && (t.detail ? t.detail.reason : t.reason) || t
              , i = K._computeStackTrace(r);
            i.mechanism = "onunhandledrejection",
            i.message || (i.message = JSON.stringify(Object(B.b)(r))),
            e(i, !0, r)
        }
        function i() {
            var t = p
              , r = c;
            p = null,
            c = null,
            e(t, !1, r)
        }
        function n(e) {
            if (p) {
                if (c === e)
                    return;
                i()
            }
            var t = K._computeStackTrace(e);
            throw p = t,
            c = e,
            setTimeout(function() {
                c === e && i()
            }, t.incomplete ? 2e3 : 0),
            e
        }
        var s, a, o = [], c = null, p = null;
        return n._subscribe = function(e) {
            o.push(e)
        }
        ,
        n._installGlobalHandler = function() {
            !0 === a || (s = J.onerror,
            J.onerror = t,
            a = !0)
        }
        ,
        n._installGlobalUnhandledRejectionHandler = function() {
            J.onunhandledrejection = r
        }
        ,
        n
    }(),
    K._computeStackTrace = function() {
        function e(e) {
            if (!e || !e.stack)
                return null;
            for (var t, r, i, n = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, s = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js))(?::(\d+))?(?::(\d+))?\s*$/i, a = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i, o = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, c = /\((\S*)(?::(\d+))(?::(\d+))\)/, l = e.stack.split("\n"), p = [], h = /^(.*) is undefined$/.exec(e.message), u = 0, d = l.length; u < d; ++u) {
                if (r = n.exec(l[u])) {
                    var f = r[2] && 0 === r[2].indexOf("native");
                    r[2] && 0 === r[2].indexOf("eval") && (t = c.exec(r[2])) && (r[2] = t[1],
                    r[3] = t[2],
                    r[4] = t[3]),
                    i = {
                        url: r[2],
                        func: r[1] || Q,
                        args: f ? [r[2]] : [],
                        line: r[3] ? +r[3] : null,
                        column: r[4] ? +r[4] : null
                    }
                } else if (r = a.exec(l[u]))
                    i = {
                        url: r[2],
                        func: r[1] || Q,
                        args: [],
                        line: +r[3],
                        column: r[4] ? +r[4] : null
                    };
                else {
                    if (!(r = s.exec(l[u])))
                        continue;
                    r[3] && -1 < r[3].indexOf(" > eval") && (t = o.exec(r[3])) ? (r[1] = r[1] || "eval",
                    r[3] = t[1],
                    r[4] = t[2],
                    r[5] = "") : 0 == u && !r[5] && void 0 !== e.columnNumber && (p[0].column = e.columnNumber + 1),
                    i = {
                        url: r[3],
                        func: r[1] || Q,
                        args: r[2] ? r[2].split(",") : [],
                        line: r[4] ? +r[4] : null,
                        column: r[5] ? +r[5] : null
                    }
                }
                !i.func && i.line && (i.func = Q),
                i.context = null,
                p.push(i)
            }
            return p.length ? (p[0] && p[0].line && !p[0].column && h && (p[0].column = null),
            {
                mode: "stack",
                name: e.name,
                message: e.message,
                stack: p
            }) : null
        }
        function t(e, t, r, i) {
            var n = {
                url: t,
                line: r
            };
            if (n.url && n.line) {
                if (e.incomplete = !1,
                n.func || (n.func = Q),
                n.context || (n.context = null),
                / '([^']+)' /.exec(i) && (n.column = null),
                0 < e.stack.length && e.stack[0].url === n.url) {
                    if (e.stack[0].line === n.line)
                        return !1;
                    if (!e.stack[0].line && e.stack[0].func === n.func)
                        return e.stack[0].line = n.line,
                        e.stack[0].context = n.context,
                        !1
                }
                return e.stack.unshift(n),
                e.partial = !0,
                !0
            }
            return e.incomplete = !0,
            !1
        }
        function r(e, i) {
            for (var n, s, a = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i, o = [], c = {}, l = !1, p = r.caller; p && !l; p = p.caller)
                if (p !== se && p !== K._report) {
                    if (s = {
                        url: null,
                        func: Q,
                        args: [],
                        line: null,
                        column: null
                    },
                    p.name ? s.func = p.name : (n = a.exec(p.toString())) && (s.func = n[1]),
                    void 0 === s.func)
                        try {
                            s.func = n.input.substring(0, n.input.indexOf("{"))
                        } catch (e) {}
                    c["" + p] ? l = !0 : c["" + p] = !0,
                    o.push(s)
                }
            i && o.splice(0, i);
            var h = {
                mode: "callers",
                name: e.name,
                message: e.message,
                stack: o
            };
            return t(h, e.sourceURL || e.fileName, e.line || e.lineNumber, e.message || e.description),
            h
        }
        function i(t, i) {
            var n = null;
            i = null == i ? 0 : +i;
            try {
                if (n = function(e) {
                    var t = e.stacktrace;
                    if (t) {
                        for (var r, i, n = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i, s = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\))? in (.*):\s*$/i, a = t.split("\n"), o = [], c = 0; c < a.length; c += 2)
                            i = null,
                            (r = n.exec(a[c])) ? i = {
                                url: r[2],
                                line: +r[1],
                                column: null,
                                func: r[3],
                                args: []
                            } : (r = s.exec(a[c])) && (i = {
                                url: r[6],
                                line: +r[1],
                                column: +r[2],
                                func: r[3] || r[4],
                                args: r[5] ? r[5].split(",") : []
                            }),
                            i && (!i.func && i.line && (i.func = Q),
                            i.line && (i.context = null),
                            !i.context && (i.context = [a[c + 1]]),
                            o.push(i));
                        return o.length ? {
                            mode: "stacktrace",
                            name: e.name,
                            message: e.message,
                            stack: o
                        } : null
                    }
                }(t))
                    return n
            } catch (e) {}
            try {
                if (n = e(t))
                    return n
            } catch (e) {}
            try {
                if (n = function(e) {
                    var t = e.message.split("\n");
                    if (4 > t.length)
                        return null;
                    var r, i = /^\s*Line (\d+) of linked script ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i, n = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i, s = /^\s*Line (\d+) of function script\s*$/i, a = [], o = J && J.document && J.document.getElementsByTagName("script"), c = [];
                    for (var l in o)
                        ee(o, l) && !o[l].src && c.push(o[l]);
                    for (var p, h = 2; h < t.length; h += 2)
                        p = null,
                        (r = i.exec(t[h])) ? p = {
                            url: r[2],
                            func: r[3],
                            args: [],
                            line: +r[1],
                            column: null
                        } : (r = n.exec(t[h])) ? p = {
                            url: r[3],
                            func: r[4],
                            args: [],
                            line: +r[1],
                            column: null
                        } : (r = s.exec(t[h])) && (p = {
                            url: te().replace(/#.*$/, ""),
                            func: "",
                            args: [],
                            line: r[1],
                            column: null
                        }),
                        p && (!p.func && (p.func = Q),
                        p.context = [t[h + 1]],
                        a.push(p));
                    return a.length ? {
                        mode: "multiline",
                        name: e.name,
                        message: t[0],
                        stack: a
                    } : null
                }(t))
                    return n
            } catch (e) {}
            try {
                if (n = r(t, i + 1))
                    return n
            } catch (e) {}
            return {
                original: t,
                name: t.name,
                message: t.message,
                mode: "failed"
            }
        }
        return i._augmentStackTraceWithInitialElement = t,
        i._computeStackTraceFromStackProp = e,
        i
    }(),
    K._collectWindowErrors = !0,
    K._linesOfContext = 11;
    var re = K._report._subscribe
      , ie = K._report._installGlobalHandler
      , ne = K._report._installGlobalUnhandledRejectionHandler
      , se = K._computeStackTrace
      , ae = 50;
    function oe(e) {
        var t = le(e.stack)
          , r = {
            type: e.name,
            value: e.message
        };
        return t && t.length && (r.stacktrace = {
            frames: t
        }),
        void 0 === r.type && "" === r.value && (r.value = "Unrecoverable error caught"),
        r
    }
    function ce(e) {
        return {
            exception: {
                values: [oe(e)]
            }
        }
    }
    function le(e) {
        if (!e || !e.length)
            return [];
        var t = e
          , r = t[0].func || ""
          , i = t[t.length - 1].func || "";
        return (r.includes("captureMessage") || r.includes("captureException")) && (t = t.slice(1)),
        i.includes("sentryWrapped") && (t = t.slice(0, -1)),
        t.map(function(e) {
            return {
                colno: e.column,
                filename: e.url || t[0].url,
                function: e.func || "?",
                in_app: !0,
                lineno: e.line
            }
        }).slice(0, ae).reverse()
    }
    var pe = function() {
        function e(e) {
            this._limit = e,
            this._buffer = []
        }
        return e.prototype.isReady = function() {
            return void 0 === this._limit || this.length() < this._limit
        }
        ,
        e.prototype.add = function(e) {
            var t = this;
            return this.isReady() ? (-1 === this._buffer.indexOf(e) && this._buffer.push(e),
            e.then(function() {
                return t.remove(e)
            }).catch(function() {
                return t.remove(e).catch(function() {})
            }),
            e) : Promise.reject(new N("Not adding Promise due to buffer limit reached."))
        }
        ,
        e.prototype.remove = function(e) {
            return this._buffer.splice(this._buffer.indexOf(e), 1)[0]
        }
        ,
        e.prototype.length = function() {
            return this._buffer.length
        }
        ,
        e.prototype.drain = function(e) {
            var t = this;
            return new Promise(function(r) {
                var i = setTimeout(function() {
                    e && 0 < e && r(!1)
                }, e);
                Promise.all(t._buffer).then(function() {
                    clearTimeout(i),
                    r(!0)
                }).catch(function() {
                    r(!0)
                })
            }
            )
        }
        ,
        e
    }()
      , he = function() {
        function e(e) {
            this.options = e,
            this._buffer = new pe(30),
            this.url = new U(this.options.dsn).getStoreEndpointWithUrlEncodedAuth()
        }
        return e.prototype.sendEvent = function() {
            throw new N("Transport Class has to implement `sendEvent` method")
        }
        ,
        e.prototype.close = function(e) {
            return this._buffer.drain(e)
        }
        ,
        e
    }()
      , ue = Object(O.e)()
      , de = function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return l.b(t, e),
        t.prototype.sendEvent = function(e) {
            var t = {
                body: JSON.stringify(e),
                method: "POST",
                referrerPolicy: q() ? "origin" : ""
            };
            return this._buffer.add(ue.fetch(this.url, t).then(function(e) {
                return {
                    status: c.fromHttpCode(e.status)
                }
            }))
        }
        ,
        t
    }(he)
      , fe = function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return l.b(t, e),
        t.prototype.sendEvent = function(e) {
            var t = this;
            return this._buffer.add(new Promise(function(r, i) {
                var n = new XMLHttpRequest;
                n.onreadystatechange = function() {
                    4 !== n.readyState || (200 === n.status && r({
                        status: c.fromHttpCode(n.status)
                    }),
                    i(n))
                }
                ,
                n.open("POST", t.url),
                n.send(JSON.stringify(e))
            }
            ))
        }
        ,
        t
    }(he)
      , me = function(e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }
        return l.b(t, e),
        t.prototype._setupTransport = function() {
            if (!this._options.dsn)
                return e.prototype._setupTransport.call(this);
            var t = this._options.transportOptions ? this._options.transportOptions : {
                dsn: this._options.dsn
            };
            return this._options.transport ? new this._options.transport(t) : X() ? new de(t) : new fe(t)
        }
        ,
        t.prototype.eventFromException = function(e, t) {
            var r, i = this;
            if (Object(R.d)(e) && e.error)
                return e = e.error,
                r = ce(se(e)),
                G.a.resolve(this._buildEvent(r, t));
            if (Object(R.a)(e) || Object(R.b)(e)) {
                var n = e
                  , s = n.name || (Object(R.a)(n) ? "DOMError" : "DOMException")
                  , o = n.message ? s + ": " + n.message : s;
                return this.eventFromMessage(o, a.Error, t).then(function(e) {
                    return Object(O.a)(e, o),
                    G.a.resolve(i._buildEvent(e, t))
                })
            }
            if (Object(R.c)(e))
                return r = ce(se(e)),
                G.a.resolve(this._buildEvent(r, t));
            if (Object(R.e)(e) && t && t.syntheticException)
                return r = function(e, t) {
                    var r = Object.keys(e).sort()
                      , i = {
                        extra: {
                            __serialized__: Object(B.c)(e)
                        },
                        message: "Non-Error exception captured with keys: " + I(r)
                    };
                    if (t) {
                        var n = le(se(t).stack);
                        i.stacktrace = {
                            frames: n
                        }
                    }
                    return i
                }(e, t.syntheticException),
                Object(O.a)(r, "Custom Object", void 0, {
                    handled: !0,
                    synthetic: !0,
                    type: "generic"
                }),
                r.level = a.Error,
                G.a.resolve(this._buildEvent(r, t));
            var c = e;
            return this.eventFromMessage(c, void 0, t).then(function(e) {
                return Object(O.a)(e, "" + c, void 0, {
                    handled: !0,
                    synthetic: !0,
                    type: "generic"
                }),
                e.level = a.Error,
                G.a.resolve(i._buildEvent(e, t))
            })
        }
        ,
        t.prototype._buildEvent = function(e, t) {
            return l.a({}, e, {
                event_id: t && t.event_id
            })
        }
        ,
        t.prototype.eventFromMessage = function(e, t, r) {
            void 0 === t && (t = a.Info);
            var i = {
                event_id: r && r.event_id,
                level: t,
                message: e
            };
            if (this._options.attachStacktrace && r && r.syntheticException) {
                var n = le(se(r.syntheticException).stack);
                i.stacktrace = {
                    frames: n
                }
            }
            return G.a.resolve(i)
        }
        ,
        t
    }(Z)
      , ge = "sentry.javascript.browser"
      , ve = function(e) {
        function t(t) {
            return void 0 === t && (t = {}),
            e.call(this, me, t) || this
        }
        return l.b(t, e),
        t.prototype._prepareEvent = function(t, r, i) {
            return t.platform = t.platform || "javascript",
            t.sdk = l.a({}, t.sdk, {
                name: ge,
                packages: l.d(t.sdk && t.sdk.packages || [], [{
                    name: "npm:@sentry/browser",
                    version: "5.4.3"
                }]),
                version: "5.4.3"
            }),
            e.prototype._prepareEvent.call(this, t, r, i)
        }
        ,
        t.prototype.showReportDialog = function(e) {
            void 0 === e && (e = {});
            var t = Object(O.e)().document;
            if (t) {
                if (!this._isEnabled())
                    return void P.a.error("Trying to call showReportDialog with Sentry Client is disabled");
                var r = e.dsn || this.getDsn();
                if (!e.eventId)
                    return void P.a.error("Missing `eventId` option in showReportDialog call");
                if (!r)
                    return void P.a.error("Missing `Dsn` option in showReportDialog call");
                var i = t.createElement("script");
                i.async = !0,
                i.src = new U(r).getReportDialogEndpoint(e),
                e.onLoad && (i.onload = e.onLoad),
                (t.head || t.body).appendChild(i)
            }
        }
        ,
        t
    }(W);
    var ye, be, we = 1e3, xe = 0;
    function Me(e, t, r) {
        if (void 0 === t && (t = {}),
        "function" != typeof e)
            return e;
        try {
            if (e.__sentry__)
                return e;
            if (e.__sentry_wrapped__)
                return e.__sentry_wrapped__
        } catch (t) {
            return e
        }
        var i = function() {
            r && "function" == typeof r && r.apply(this, arguments);
            var i = Array.prototype.slice.call(arguments);
            try {
                var n = i.map(function(e) {
                    return Me(e, t)
                });
                return e.handleEvent ? e.handleEvent.apply(this, n) : e.apply(this, n)
            } catch (e) {
                throw xe += 1,
                setTimeout(function() {
                    xe -= 1
                }),
                _(function(r) {
                    r.addEventProcessor(function(e) {
                        var r = l.a({}, e);
                        return t.mechanism && Object(O.a)(r, void 0, void 0, t.mechanism),
                        r.extra = l.a({}, r.extra, {
                            arguments: Object(B.b)(i, 3)
                        }),
                        r
                    }),
                    u(e)
                }),
                e
            }
        };
        try {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (i[n] = e[n])
        } catch (e) {}
        e.prototype = e.prototype || {},
        i.prototype = e.prototype,
        Object.defineProperty(e, "__sentry_wrapped__", {
            enumerable: !1,
            value: i
        }),
        Object.defineProperties(i, {
            __sentry__: {
                enumerable: !1,
                value: !0
            },
            __sentry_original__: {
                enumerable: !1,
                value: e
            }
        });
        try {
            Object.getOwnPropertyDescriptor(i, "name").configurable && Object.defineProperty(i, "name", {
                get: function() {
                    return e.name
                }
            })
        } catch (e) {}
        return i
    }
    var _e = 0;
    function Se(e, t) {
        return void 0 === t && (t = !1),
        function(r) {
            if (ye = void 0,
            r && be !== r) {
                be = r;
                var i = function() {
                    var t;
                    try {
                        t = r.target ? Ee(r.target) : Ee(r)
                    } catch (e) {
                        t = "<unknown>"
                    }
                    0 === t.length || Object(p.b)().addBreadcrumb({
                        category: "ui." + e,
                        message: t
                    }, {
                        event: r,
                        name: e
                    })
                };
                _e && clearTimeout(_e),
                t ? _e = setTimeout(i) : i()
            }
        }
    }
    function Te() {
        return function(e) {
            var t;
            try {
                t = e.target
            } catch (e) {
                return
            }
            var r = t && t.tagName;
            r && ("INPUT" === r || "TEXTAREA" === r || t.isContentEditable) && (!ye && Se("input")(e),
            clearTimeout(ye),
            ye = setTimeout(function() {
                ye = void 0
            }, we))
        }
    }
    function Ee(e) {
        for (var t, r = e, i = [], n = 0, s = 0, a = " > ".length; r && n++ < 5 && !("html" === (t = Ae(r)) || 1 < n && s + i.length * a + t.length >= 80); )
            i.push(t),
            s += t.length,
            r = r.parentNode;
        return i.reverse().join(" > ")
    }
    function Ae(e) {
        var t, r, i, n, s, a = [];
        if (!e || !e.tagName)
            return "";
        if (a.push(e.tagName.toLowerCase()),
        e.id && a.push("#" + e.id),
        (t = e.className) && Object(R.h)(t))
            for (r = t.split(/\s+/),
            s = 0; s < r.length; s++)
                a.push("." + r[s]);
        var o = ["type", "name", "title", "alt"];
        for (s = 0; s < o.length; s++)
            i = o[s],
            (n = e.getAttribute(i)) && a.push("[" + i + '="' + n + '"]');
        return a.join("")
    }
    var Pe = function() {
        function e() {
            this._ignoreOnError = 0,
            this.name = e.id
        }
        return e.prototype._wrapTimeFunction = function(e) {
            return function() {
                for (var t = [], r = 0; r < arguments.length; r++)
                    t[r] = arguments[r];
                var i = t[0];
                return t[0] = Me(i, {
                    mechanism: {
                        data: {
                            function: Oe(e)
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }),
                e.apply(this, t)
            }
        }
        ,
        e.prototype._wrapRAF = function(e) {
            return function(t) {
                return e(Me(t, {
                    mechanism: {
                        data: {
                            function: "requestAnimationFrame",
                            handler: Oe(e)
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }))
            }
        }
        ,
        e.prototype._wrapEventTarget = function(e) {
            var t = Object(O.e)()
              , r = t[e] && t[e].prototype;
            r && r.hasOwnProperty && r.hasOwnProperty("addEventListener") && (Object(B.a)(r, "addEventListener", function(t) {
                return function(r, i, n) {
                    try {
                        i.handleEvent = Me(i.handleEvent.bind(i), {
                            mechanism: {
                                data: {
                                    function: "handleEvent",
                                    handler: Oe(i),
                                    target: e
                                },
                                handled: !0,
                                type: "instrument"
                            }
                        })
                    } catch (e) {}
                    return t.call(this, r, Me(i, {
                        mechanism: {
                            data: {
                                function: "addEventListener",
                                handler: Oe(i),
                                target: e
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    }), n)
                }
            }),
            Object(B.a)(r, "removeEventListener", function(e) {
                return function(t, r, i) {
                    var n = r;
                    try {
                        n = n && (n.__sentry_wrapped__ || n)
                    } catch (e) {}
                    return e.call(this, t, n, i)
                }
            }))
        }
        ,
        e.prototype.setupOnce = function() {
            this._ignoreOnError = this._ignoreOnError;
            var e = Object(O.e)();
            Object(B.a)(e, "setTimeout", this._wrapTimeFunction.bind(this)),
            Object(B.a)(e, "setInterval", this._wrapTimeFunction.bind(this)),
            Object(B.a)(e, "requestAnimationFrame", this._wrapRAF.bind(this)),
            ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"].forEach(this._wrapEventTarget.bind(this))
        }
        ,
        e.id = "TryCatch",
        e
    }();
    function Oe(e) {
        try {
            return e && e.name || "<anonymous>"
        } catch (e) {
            return "<anonymous>"
        }
    }
    var Re, Ce = Object(O.e)(), Le = function() {
        function e(t) {
            this.name = e.id,
            this._options = l.a({
                console: !0,
                dom: !0,
                fetch: !0,
                history: !0,
                sentry: !0,
                xhr: !0
            }, t)
        }
        return e.prototype._instrumentConsole = function() {
            "console"in Ce && ["debug", "info", "warn", "error", "log", "assert"].forEach(function(t) {
                t in Ce.console && Object(B.a)(Ce.console, t, function(r) {
                    return function() {
                        for (var i = [], n = 0; n < arguments.length; n++)
                            i[n] = arguments[n];
                        var s = {
                            category: "console",
                            data: {
                                extra: {
                                    arguments: Object(B.b)(i, 3)
                                },
                                logger: "console"
                            },
                            level: a.fromString(t),
                            message: L(i, " ")
                        };
                        "assert" === t && !1 === i[0] && (s.message = "Assertion failed: " + (L(i.slice(1), " ") || "console.assert"),
                        s.data.extra.arguments = Object(B.b)(i.slice(1), 3)),
                        e.addBreadcrumb(s, {
                            input: i,
                            level: t
                        }),
                        r && Function.prototype.apply.call(r, Ce.console, i)
                    }
                })
            })
        }
        ,
        e.prototype._instrumentDOM = function() {
            "document"in Ce && (Ce.document.addEventListener("click", Se("click"), !1),
            Ce.document.addEventListener("keypress", Te(), !1),
            ["EventTarget", "Node"].forEach(function(e) {
                var t = Ce[e] && Ce[e].prototype;
                t && t.hasOwnProperty && t.hasOwnProperty("addEventListener") && (Object(B.a)(t, "addEventListener", function(e) {
                    return function(t, r, i) {
                        return r && r.handleEvent ? ("click" === t && Object(B.a)(r, "handleEvent", function(e) {
                            return function(t) {
                                return Se("click")(t),
                                e.call(this, t)
                            }
                        }),
                        "keypress" === t && Object(B.a)(r, "handleEvent", Te())) : ("click" === t && Se("click", !0)(this),
                        "keypress" === t && Te()(this)),
                        e.call(this, t, r, i)
                    }
                }),
                Object(B.a)(t, "removeEventListener", function(e) {
                    return function(t, r, i) {
                        var n = r;
                        try {
                            n = n && (n.__sentry_wrapped__ || n)
                        } catch (e) {}
                        return e.call(this, t, n, i)
                    }
                }))
            }))
        }
        ,
        e.prototype._instrumentFetch = function() {
            (function() {
                if (!X())
                    return !1;
                var e = function(e) {
                    return -1 !== e.toString().indexOf("native")
                }
                  , t = Object(O.e)()
                  , r = null
                  , i = t.document;
                if (i) {
                    var n = i.createElement("iframe");
                    n.hidden = !0;
                    try {
                        i.head.appendChild(n),
                        n.contentWindow && n.contentWindow.fetch && (r = e(n.contentWindow.fetch)),
                        i.head.removeChild(n)
                    } catch (e) {
                        P.a.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e)
                    }
                }
                return null === r && (r = e(t.fetch)),
                r
            }
            )() && Object(B.a)(Ce, "fetch", function(t) {
                return function() {
                    for (var r = [], i = 0; i < arguments.length; i++)
                        r[i] = arguments[i];
                    var n, s = r[0], o = "GET";
                    "string" == typeof s ? n = s : "Request"in Ce && s instanceof Request ? (n = s.url,
                    s.method && (o = s.method)) : n = s + "",
                    r[1] && r[1].method && (o = r[1].method);
                    var c = Object(p.b)().getClient()
                      , l = c && c.getDsn();
                    if (l) {
                        var h = new U(l).getStoreEndpoint();
                        if (h && n.includes(h))
                            return "POST" === o && r[1] && r[1].body && Ie(r[1].body),
                            t.apply(Ce, r)
                    }
                    var u = {
                        method: o,
                        url: n
                    };
                    return t.apply(Ce, r).then(function(t) {
                        return u.status_code = t.status,
                        e.addBreadcrumb({
                            category: "fetch",
                            data: u,
                            type: "http"
                        }, {
                            input: r,
                            response: t
                        }),
                        t
                    }).catch(function(t) {
                        throw e.addBreadcrumb({
                            category: "fetch",
                            data: u,
                            level: a.Error,
                            type: "http"
                        }, {
                            error: t,
                            input: r
                        }),
                        t
                    })
                }
            })
        }
        ,
        e.prototype._instrumentHistory = function() {
            function t(e) {
                return function() {
                    for (var t = [], r = 0; r < arguments.length; r++)
                        t[r] = arguments[r];
                    var n = 2 < t.length ? t[2] : void 0;
                    return n && i(Re, n + ""),
                    e.apply(this, t)
                }
            }
            var r = this;
            if (function() {
                var e = Object(O.e)()
                  , t = e.chrome
                  , r = t && t.app && t.app.runtime
                  , i = "history"in e && !!e.history.pushState && !!e.history.replaceState;
                return !r && i
            }()) {
                var i = function(t, r) {
                    var i = Object(O.f)(Ce.location.href)
                      , n = Object(O.f)(r)
                      , s = Object(O.f)(t);
                    s.path || (s = i),
                    Re = r,
                    i.protocol === n.protocol && i.host === n.host && (r = n.relative),
                    i.protocol === s.protocol && i.host === s.host && (t = s.relative),
                    e.addBreadcrumb({
                        category: "navigation",
                        data: {
                            from: t,
                            to: r
                        }
                    })
                }
                  , n = Ce.onpopstate;
                Ce.onpopstate = function() {
                    for (var e = [], t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    var s = Ce.location.href;
                    if (i(Re, s),
                    n)
                        return n.apply(r, e)
                }
                ,
                Object(B.a)(Ce.history, "pushState", t),
                Object(B.a)(Ce.history, "replaceState", t)
            }
        }
        ,
        e.prototype._instrumentXHR = function() {
            if ("XMLHttpRequest"in Ce) {
                var t = XMLHttpRequest.prototype;
                Object(B.a)(t, "open", function(e) {
                    return function() {
                        for (var t = [], r = 0; r < arguments.length; r++)
                            t[r] = arguments[r];
                        var i = t[1];
                        this.__sentry_xhr__ = {
                            method: t[0],
                            url: t[1]
                        };
                        var n = Object(p.b)().getClient()
                          , s = n && n.getDsn();
                        if (s) {
                            var a = new U(s).getStoreEndpoint();
                            Object(R.h)(i) && a && i.includes(a) && (this.__sentry_own_request__ = !0)
                        }
                        return e.apply(this, t)
                    }
                }),
                Object(B.a)(t, "send", function(t) {
                    return function() {
                        function r() {
                            if (4 === s.readyState) {
                                if (s.__sentry_own_request__)
                                    return;
                                try {
                                    s.__sentry_xhr__ && (s.__sentry_xhr__.status_code = s.status)
                                } catch (e) {}
                                e.addBreadcrumb({
                                    category: "xhr",
                                    data: s.__sentry_xhr__,
                                    type: "http"
                                }, {
                                    xhr: s
                                })
                            }
                        }
                        for (var i = [], n = 0; n < arguments.length; n++)
                            i[n] = arguments[n];
                        var s = this;
                        return s.__sentry_own_request__ && Ie(i[0]),
                        ["onload", "onerror", "onprogress"].forEach(function(e) {
                            !function(e, t) {
                                e in t && "function" == typeof t[e] && Object(B.a)(t, e, function(t) {
                                    return Me(t, {
                                        mechanism: {
                                            data: {
                                                function: e,
                                                handler: t && t.name || "<anonymous>"
                                            },
                                            handled: !0,
                                            type: "instrument"
                                        }
                                    })
                                })
                            }(e, s)
                        }),
                        "onreadystatechange"in s && "function" == typeof s.onreadystatechange ? Object(B.a)(s, "onreadystatechange", function(e) {
                            return Me(e, {
                                mechanism: {
                                    data: {
                                        function: "onreadystatechange",
                                        handler: e && e.name || "<anonymous>"
                                    },
                                    handled: !0,
                                    type: "instrument"
                                }
                            }, r)
                        }) : s.onreadystatechange = r,
                        t.apply(this, i)
                    }
                })
            }
        }
        ,
        e.addBreadcrumb = function(t, r) {
            Object(p.b)().getIntegration(e) && Object(p.b)().addBreadcrumb(t, r)
        }
        ,
        e.prototype.setupOnce = function() {
            this._options.console && this._instrumentConsole(),
            this._options.dom && this._instrumentDOM(),
            this._options.xhr && this._instrumentXHR(),
            this._options.fetch && this._instrumentFetch(),
            this._options.history && this._instrumentHistory()
        }
        ,
        e.id = "Breadcrumbs",
        e
    }();
    function Ie(e) {
        try {
            var t = JSON.parse(e);
            Le.addBreadcrumb({
                category: "sentry",
                event_id: t.event_id,
                level: t.level || a.fromString("error"),
                message: Object(O.d)(t)
            }, {
                event: t
            })
        } catch (e) {
            P.a.error("Error while adding sentry type breadcrumb")
        }
    }
    var ke = function() {
        function e(t) {
            this.name = e.id,
            this._options = l.a({
                onerror: !0,
                onunhandledrejection: !0
            }, t)
        }
        return e.prototype.setupOnce = function() {
            Error.stackTraceLimit = 50,
            re(function(t, r, i) {
                if (!(0 < xe)) {
                    var n = Object(p.b)().getIntegration(e);
                    n && Object(p.b)().captureEvent(n._eventFromGlobalHandler(t), {
                        data: {
                            stack: t
                        },
                        originalException: i
                    })
                }
            }),
            this._options.onerror && (P.a.log("Global Handler attached: onerror"),
            ie()),
            this._options.onunhandledrejection && (P.a.log("Global Handler attached: onunhandledrejection"),
            ne())
        }
        ,
        e.prototype._eventFromGlobalHandler = function(e) {
            if (!Object(R.h)(e.message) && "onunhandledrejection" !== e.mechanism) {
                var t = e.message;
                e.message = t.error && Object(R.h)(t.error.message) ? t.error.message : "No error message"
            }
            var r = ce(e)
              , i = {
                mode: e.mode
            };
            e.message && (i.message = e.message),
            e.name && (i.name = e.name);
            var n = Object(p.b)().getClient()
              , s = n && n.getOptions().maxValueLength || 250
              , a = e.original ? C(JSON.stringify(Object(B.b)(e.original)), s) : ""
              , o = "onunhandledrejection" === e.mechanism ? "UnhandledRejection" : "Error";
            return Object(O.a)(r, a, o, {
                data: i,
                handled: !1,
                type: e.mechanism
            }),
            r
        }
        ,
        e.id = "GlobalHandlers",
        e
    }()
      , De = "cause"
      , ze = 5
      , Be = function() {
        function e(t) {
            void 0 === t && (t = {}),
            this.name = e.id,
            this._key = t.key || De,
            this._limit = t.limit || ze
        }
        return e.prototype.setupOnce = function() {
            Object(T.b)(function(t, r) {
                var i = Object(p.b)().getIntegration(e);
                return i ? i._handler(t, r) : t
            })
        }
        ,
        e.prototype._handler = function(e, t) {
            if (!(e.exception && e.exception.values && t && t.originalException instanceof Error))
                return e;
            var r = this._walkErrorTree(t.originalException, this._key);
            return e.exception.values = l.d(r, e.exception.values),
            e
        }
        ,
        e.prototype._walkErrorTree = function(e, t, r) {
            if (void 0 === r && (r = []),
            !(e[t]instanceof Error) || r.length + 1 >= this._limit)
                return r;
            var i = oe(se(e[t]));
            return this._walkErrorTree(e[t], t, l.d([i], r))
        }
        ,
        e.id = "LinkedErrors",
        e
    }()
      , Ne = Object(O.e)()
      , je = function() {
        function e() {
            this.name = e.id
        }
        return e.prototype.setupOnce = function() {
            Object(T.b)(function(t) {
                if (Object(p.b)().getIntegration(e)) {
                    if (!Ne.navigator || !Ne.location)
                        return t;
                    var r = t.request || {};
                    return r.url = r.url || Ne.location.href,
                    r.headers = r.headers || {},
                    r.headers["User-Agent"] = Ne.navigator.userAgent,
                    l.a({}, t, {
                        request: r
                    })
                }
                return t
            })
        }
        ,
        e.id = "UserAgent",
        e
    }()
      , Fe = [new i.InboundFilters, new i.FunctionToString, new Pe, new Le, new ke, new Be, new je];
    function Ue(e) {
        void 0 === e && (e = {}),
        void 0 === e.defaultIntegrations && (e.defaultIntegrations = Fe),
        function(e, t) {
            !0 === t.debug && P.a.enable(),
            Object(p.b)().bindClient(new e(t))
        }(ve, e)
    }
    function Ge(e) {
        void 0 === e && (e = {}),
        e.eventId || (e.eventId = Object(p.b)().lastEventId());
        var t = Object(p.b)().getClient();
        t && t.showReportDialog(e)
    }
    function He() {
        return Object(p.b)().lastEventId()
    }
    function Ve() {}
    function We(e) {
        e()
    }
    function Ye(e) {
        var t = Object(p.b)().getClient();
        return t ? t.flush(e) : Promise.reject(!1)
    }
    function Ze(e) {
        var t = Object(p.b)().getClient();
        return t ? t.close(e) : Promise.reject(!1)
    }
    function Xe(e) {
        Me(e)()
    }
    r.d(t, "Integrations", function() {
        return Ke
    }),
    r.d(t, "Severity", function() {
        return a
    }),
    r.d(t, "Status", function() {
        return c
    }),
    r.d(t, "addGlobalEventProcessor", function() {
        return T.b
    }),
    r.d(t, "addBreadcrumb", function() {
        return g
    }),
    r.d(t, "captureException", function() {
        return u
    }),
    r.d(t, "captureEvent", function() {
        return f
    }),
    r.d(t, "captureMessage", function() {
        return d
    }),
    r.d(t, "configureScope", function() {
        return m
    }),
    r.d(t, "getHubFromCarrier", function() {
        return p.c
    }),
    r.d(t, "getCurrentHub", function() {
        return p.b
    }),
    r.d(t, "Hub", function() {
        return p.a
    }),
    r.d(t, "Scope", function() {
        return T.a
    }),
    r.d(t, "setContext", function() {
        return v
    }),
    r.d(t, "setExtra", function() {
        return w
    }),
    r.d(t, "setExtras", function() {
        return y
    }),
    r.d(t, "setTag", function() {
        return x
    }),
    r.d(t, "setTags", function() {
        return b
    }),
    r.d(t, "setUser", function() {
        return M
    }),
    r.d(t, "Span", function() {
        return E.a
    }),
    r.d(t, "withScope", function() {
        return _
    }),
    r.d(t, "BrowserClient", function() {
        return ve
    }),
    r.d(t, "defaultIntegrations", function() {
        return Fe
    }),
    r.d(t, "forceLoad", function() {
        return Ve
    }),
    r.d(t, "init", function() {
        return Ue
    }),
    r.d(t, "lastEventId", function() {
        return He
    }),
    r.d(t, "onLoad", function() {
        return We
    }),
    r.d(t, "showReportDialog", function() {
        return Ge
    }),
    r.d(t, "flush", function() {
        return Ye
    }),
    r.d(t, "close", function() {
        return Ze
    }),
    r.d(t, "wrap", function() {
        return Xe
    }),
    r.d(t, "SDK_NAME", function() {
        return ge
    }),
    r.d(t, "SDK_VERSION", function() {
        return "5.4.3"
    }),
    r.d(t, "Transports", function() {
        return s
    });
    var qe = {}
      , Je = Object(O.e)();
    Je.Sentry && Je.Sentry.Integrations && (qe = Je.Sentry.Integrations);
    var Ke = l.a({}, qe, i, n)
}
, function(e, t, r) {
    "use strict";
    r.d(t, "a", function() {
        return a
    });
    var i, n, s = r(5);
    (n = i || (i = {})).PENDING = "PENDING",
    n.RESOLVED = "RESOLVED",
    n.REJECTED = "REJECTED";
    var a = function() {
        function e(e) {
            var t = this;
            this._state = i.PENDING,
            this._handlers = [],
            this._resolve = function(e) {
                t._setResult(e, i.RESOLVED)
            }
            ,
            this._reject = function(e) {
                t._setResult(e, i.REJECTED)
            }
            ,
            this._setResult = function(e, r) {
                return t._state === i.PENDING ? Object(s.j)(e) ? void e.then(t._resolve, t._reject) : (t._value = e,
                t._state = r,
                void t._executeHandlers()) : void 0
            }
            ,
            this._executeHandlers = function() {
                if (t._state !== i.PENDING)
                    return t._state === i.REJECTED ? t._handlers.forEach(function(e) {
                        return e.onFail && e.onFail(t._value)
                    }) : t._handlers.forEach(function(e) {
                        return e.onSuccess && e.onSuccess(t._value)
                    }),
                    void (t._handlers = [])
            }
            ,
            this._attachHandler = function(e) {
                t._handlers = t._handlers.concat(e),
                t._executeHandlers()
            }
            ;
            try {
                e(this._resolve, this._reject)
            } catch (e) {
                this._reject(e)
            }
        }
        return e.prototype.then = function(t, r) {
            var i = this;
            return new e(function(e, n) {
                i._attachHandler({
                    onFail: function(t) {
                        if (r)
                            try {
                                return void e(r(t))
                            } catch (e) {
                                return void n(e)
                            }
                        else
                            n(t)
                    },
                    onSuccess: function(r) {
                        if (t)
                            try {
                                return void e(t(r))
                            } catch (e) {
                                return void n(e)
                            }
                        else
                            e(r)
                    }
                })
            }
            )
        }
        ,
        e.prototype.catch = function(e) {
            return this.then(function(e) {
                return e
            }, e)
        }
        ,
        e.prototype.toString = function() {
            return "[object SyncPromise]"
        }
        ,
        e.resolve = function(t) {
            return new e(function(e) {
                e(t)
            }
            )
        }
        ,
        e.reject = function(t) {
            return new e(function(e, r) {
                r(t)
            }
            )
        }
        ,
        e
    }()
}
, , function(e, t, r) {
    var i = r(4)
      , n = r(8)
      , s = r(24)
      , a = new i.Vector3
      , o = s.generateCube(null, 1, 1, 1, {})
      , c = function(e) {
        this.mesh = new i.Mesh(o),
        this.init = function(t) {
            this.dst = t.dst,
            this.spd = t.spd,
            this.xS = t.xS,
            this.zS = t.zS,
            this.yS = t.yS,
            this.scale = .45,
            this.len = 0,
            this.mesh.material = e.getMat("default", {
                mat: i.MeshBasicMaterial,
                color: 15592941,
                transparent: !0,
                opacity: .21
            });
            var r = t.mesh.position.x
              , n = t.mesh.position.y
              , s = t.mesh.position.z;
            e.moveMesh(this.mesh, r, n, s),
            this.mesh.lookAt(r + this.xS, n + this.yS, s + this.zS),
            this.mesh.rotateX(Math.PI / 2),
            e.scaleMesh(this.mesh, this.scale, this.len, this.scale),
            this.mesh.visible = !0
        }
        ,
        this.update = function(t) {
            this.mesh.visible && (this.len < this.dst && (this.len += this.spd * t,
            this.len >= this.dst && (this.len = this.dst)),
            this.scale -= 36e-5 * t,
            e.scaleMesh(this.mesh, this.scale, this.len, this.scale),
            0 >= this.scale && (this.scale = 0,
            this.mesh.visible = !1))
        }
    };
    function l() {
        i.Object3D.call(this),
        this.largeSpawnCount = 8,
        this.smallSpawnCount = 15,
        this.emissiveness = .55,
        this.velocityDamping = 3,
        this.lifeSpeedMin = 2.2,
        this.lifeSpeedRange = 3;
        var e = new i.Geometry({
            dynamic: !0
        })
          , t = new i.Color(12303291);
        this.mesh = new i.Mesh(e,new i.StrippedLambertMaterial({
            color: t,
            emissive: t.multiplyScalar(this.emissiveness),
            smoothShading: !0
        })),
        this.mesh.castShadow = !0,
        this.mesh.receiveShadow = !0,
        this.add(this.mesh),
        this.cubeTemplate = new i.BoxGeometry(1,1,1);
        for (var r = 0; r < this.cubeTemplate.faces.length; r++)
            this.cubeTemplate.faces[r].materialIndex = 0;
        this.cubeTemplate.faceVertexUvs = [[]],
        this.entities = []
    }
    l.staticMatrix = new i.Matrix4,
    l.prototype = Object.create(i.Object3D.prototype),
    Object.defineProperty(l, "finished", function() {
        return 0 === this.entities.length
    }),
    l.prototype.explodeAt = function(e, t, r, i) {
        this.sizeMin = .35 * i,
        this.sizeRange = 1.8 * i,
        this.velocityMin = 30 * i,
        this.velocityRange = 17 * i,
        a.set(e, t, r);
        for (var n = 0; n < this.largeSpawnCount; n++)
            this.spawnEntity(.1 * Math.random() + .9, a, !1);
        for (n = 0; n < this.smallSpawnCount; n++)
            this.spawnEntity(.9 * Math.random(), a, !1)
    }
    ,
    l.prototype.spawnEntity = function(e, t) {
        for (var r = Math.pow(e, 2.5), i = r * this.sizeRange + this.sizeMin, n = (1 - r) * this.velocityRange + this.velocityMin, s = this._randomVector().normalize().multiplyScalar(n), a = r * this.lifeSpeedRange + this.lifeSpeedMin, o = 0; ; ) {
            for (var c = !0, p = 0; p < this.entities.length; p++)
                if (this.entities[p].index === o) {
                    c = !1;
                    break
                }
            if (c)
                break;
            o++
        }
        8 * o > this.mesh.geometry.vertices.length - 1 && this.mesh.geometry.merge(this.cubeTemplate, l.emptyMatrix),
        this.entities.push({
            index: o,
            rank: r,
            rankSeed: e,
            life: 0,
            lifeSpeed: a,
            size: i,
            position: t.clone(),
            velocity: s
        })
    }
    ,
    l.prototype.destroyEntity = function(e) {
        this.entities.splice(this.entities.indexOf(e), 1);
        for (var t = 8 * e.index; t < 8 * (e.index + 1); t++)
            this.mesh.geometry.vertices[t].set(0, 0, 0);
        this.mesh.geometry.verticesNeedUpdate = !0,
        this.mesh.geometry.elementsNeedUpdate = !0,
        this._cleanGeometry()
    }
    ,
    l.prototype.update = function(e) {
        e /= 1e3;
        for (var t, r = 0; r < this.entities.length; r++) {
            (t = this.entities[r]).life += e * t.lifeSpeed,
            t.velocity.multiplyScalar(1 - this.velocityDamping * e),
            t.position.add(t.velocity.clone().multiplyScalar(e));
            var i = 2 - Math.pow(t.life / Math.sqrt(2), 2);
            i *= t.size;
            for (var n = 8 * t.index; n < 8 * (t.index + 1); n++) {
                var s = this.mesh.geometry.vertices[n]
                  , a = this.cubeTemplate.vertices[n % 8];
                s.set(t.position.x, t.position.y, t.position.z).addScaledVector(a, i)
            }
            0 >= i && this.destroyEntity(t)
        }
        this.mesh.geometry.verticesNeedUpdate = !0,
        this.mesh.geometry.elementsNeedUpdate = !0,
        this.mesh.geometry.computeBoundingSphere()
    }
    ,
    l.prototype._cleanGeometry = function() {
        for (var e, t = this.mesh.geometry.vertices, r = this.mesh.geometry.faces, i = -1, n = 0; n < this.entities.length; n++)
            (e = this.entities[n]).index > i && (i = e.index);
        var s = i + 1;
        t.splice(8 * s, t.length - 8 * s),
        r.splice(12 * s, r.length - 12 * s)
    }
    ,
    l.prototype._randomVector = function() {
        return new i.Vector3(Math.random() - .5,Math.random() - .5,Math.random() - .5)
    }
    ;
    var p = [{
        mat: i.MeshBasicMaterial,
        snd: {
            rng: 26,
            src: ["whizz_0", "whizz_1"],
            vol: .12
        },
        spd: 1.7,
        scale: 1,
        length: 13,
        color: 16777179
    }, {
        spd: [.03, .031],
        rand: !0,
        carryV: !0,
        grav: 3e-4,
        spn: [.04, .05],
        scale: .15,
        length: .5,
        color: 10124094
    }, {
        spd: [.03, .031],
        rand: !0,
        carryV: !0,
        grav: 3e-4,
        spn: [.03, .05],
        scale: .1,
        length: .4,
        color: 10124094
    }]
      , h = function(e) {
        this.mesh = new i.Mesh(e.cubeGeo),
        this.init = function(t, r, s, a, o, c, l, p) {
            this.dst = c,
            this.scale = l.scale,
            this.spd = l.spd[1] ? n.randFloat(l.spd[0], l.spd[1]) : l.spd;
            var h = l && l.carryV && p;
            a -= Math.PI,
            this.xS = this.spd * Math.sin(a) * Math.cos(o) + (h ? p.xVel : 0),
            this.zS = this.spd * Math.cos(a) * Math.cos(o) + (h ? p.zVel : 0),
            this.yS = this.spd * Math.sin(o) + (h ? p.yVel : 0),
            this.grav = l.grav,
            this.spin = l.spn ? l.spn[1] ? n.randFloat(l.spn[0], l.spn[1]) : l.spn : 0,
            this.mesh.receiveShadow = l.mat != i.MeshBasicMaterial,
            this.mesh.material = e.getMat("default", {
                fog: l.mat != i.MeshBasicMaterial,
                color: l.color,
                emissive: l.emis,
                mat: l.mat
            }),
            this.layer = p && p.isYou ? 1 : 0,
            this.sound = p && p.isYou ? null : l.snd,
            this.soundPlayed = !1,
            this.mesh.layers.set(this.layer),
            e.moveMesh(this.mesh, t, r, s),
            this.mesh.lookAt(t + this.xS, r + this.yS, s + this.zS),
            l && l.rand && this.mesh.rotateX(n.randFloat(-Math.PI, Math.PI)),
            e.scaleMesh(this.mesh, l.scale, l.scale, l.length)
        }
        ,
        this.checkSound = function() {
            if (this.sound && !this.soundPlayed) {
                var e = Howler.pos();
                n.getD3D(e[0], e[1], e[2], this.mesh.position.x, this.mesh.position.y, this.mesh.position.z) <= this.sound.rng && (SOUND.play(this.sound.src[n.randInt(0, this.sound.src.length - 1)], this.sound.vol, !1, n.randFloat(.8, 1.2)),
                this.soundPlayed = !0)
            }
        }
        ,
        this.update = function(e) {
            this.mesh.visible && (this.mesh.position.x += this.xS * e,
            this.mesh.position.z += this.zS * e,
            this.mesh.position.y += this.yS * e,
            this.spin && this.mesh.rotateX(this.spin * e),
            this.yS -= (this.grav || 0) * e,
            this.dst -= this.spd * e,
            this.checkSound(),
            0 >= this.dst && (this.mesh.visible = !1))
        }
    };
    i.Sprite.prototype.init = function(e, t, r, i, n, s, a, o, c, l) {
        this.position.x = e,
        this.position.y = t,
        this.position.z = r,
        this.xVel = i,
        this.yVel = n,
        this.zVel = s,
        this.scale.x = this.scale.y = a,
        this.life = o || 0,
        this.grav = c || 0,
        this.area = l,
        this.updC = 0
    }
    ,
    i.Sprite.prototype.update = function(e, t, r) {
        if (this.area && (this.visible = t && 160 >= n.getD3D(r ? r.x : 0, r ? r.y : 0, r ? r.z : 0, this.position.x, this.position.y, this.position.z)),
        this.visible || this.area) {
            if (this.position.x += this.xVel * e,
            this.position.y += this.yVel * e,
            this.yVel -= this.grav * e,
            this.position.z += this.zVel * e,
            this.area) {
                var i = this.scale.x / 2;
                this.position.x - i >= this.area.x + this.area.w ? this.position.x = this.area.x - this.area.w - i : this.position.x + i <= this.area.x - this.area.w && (this.position.x = this.area.x + this.area.w + i),
                this.position.z - i >= this.area.z + this.area.l ? this.position.z = this.area.z - this.area.l - i : this.position.z + i <= this.area.z - this.area.l && (this.position.z = this.area.z + this.area.l + i),
                this.position.y - i >= this.area.y + this.area.h ? this.position.y = this.area.y - i : this.position.y + i <= this.area.y && (this.position.y = this.area.y + this.area.h + i)
            }
            0 < this.life ? (this.life -= e,
            0 >= this.life && this.updC && (this.visible = !1),
            this.updC++) : 0 >= this.life && this.updC && (this.visible = !1)
        }
    }
    ;
    var u = [Math.PI / 3, -Math.PI / 3]
      , d = [{
        hole: !0,
        count: 2,
        grav: -2e-5,
        scale: [5, 9],
        speed: [0, .025],
        spread: [-.4, .4],
        life: [300, 500]
    }, {}, {
        count: 1,
        blending: 2,
        scale: [5, 7],
        speed: [0, 0],
        spread: [0, 0],
        life: [30, 35]
    }, {
        count: 1,
        blending: 2,
        scale: [2e3, 2e3],
        speed: [0, 0],
        spread: [0, 0]
    }, {
        count: 4,
        src: "0",
        scale: [5, 6],
        speed: [0, .01],
        spread: [-1, 1],
        life: [600, 800]
    }];
    e.exports = function(e) {
        var t, r, s;
        this.particles = [],
        this.trails = [],
        this.physObjs = [],
        this.areas = [],
        this.active = !0,
        this.ExplosionManager = new l,
        this.prefabs = [{
            src: "glow_0",
            blending: 1,
            spd: .008,
            cnt: 2.2,
            grav: [-.015, -.005],
            scl: [.7, 1],
            dir: 0
        }, {
            src: "glow_1",
            blending: 1,
            spd: .003,
            cnt: 8,
            grav: [-.2, -.22],
            scl: [1, 1.5],
            dir: 0
        }, {
            src: "fog_0",
            blending: 1,
            spd: .002,
            cnt: 6,
            grav: [0, 0],
            scl: [25, 30],
            dir: 0
        }],
        this.addTrail = function(t) {
            s = null;
            for (var r = 0; r < this.trails.length; ++r)
                if (!this.trails[r].mesh.visible) {
                    s = this.trails[r];
                    break
                }
            s || (s = new c(e),
            this.trails.push(s),
            e.scene.add(s.mesh)),
            s.init(t)
        }
        ,
        this.area = function(e, t, r, i, s, a, o, c) {
            i /= 2,
            a /= 2,
            this.areas.push({
                f: c,
                x: e,
                y: t,
                z: r,
                w: i,
                h: s,
                l: a
            });
            for (var l = 0; l < o.count; ++l)
                this.add(o.src, e + n.randInt(-i, i), t + n.randInt(0, s), r + n.randInt(-a, a), o.spd * Math.sin(o.dir), o.grav ? n.randFloat(o.grav[0], o.grav[1]) : 0, o.spd * Math.cos(o.dir), n.randFloat(o.scl[0], o.scl[1]), 0, 0, o.blending, this.areas[this.areas.length - 1], null, o.colr)
        }
        ,
        this.effect = function(r, s, a, o, c, l) {
            if (this.active && (0 == e.useDepthMap || "0" == e.useDepthMap)) {
                t = d[l];
                for (var p = 0; p < t.count; ++p) {
                    var h = n.randFloat(t.speed[0], t.speed[1])
                      , u = o + n.randFloat(t.spread[0], t.spread[1])
                      , f = c + n.randFloat(t.spread[0], t.spread[1]);
                    this.add(l, r, s, a, h * Math.sin(u) * Math.cos(f), h * Math.sin(f), h * Math.cos(u) * Math.cos(f), n.randFloat(t.scale[0], t.scale[1]), t.life ? n.randInt(t.life[0], t.life[1]) : 0, t.grav, t.blending, null, t.src)
                }
                t.hole && this.add(1, r, s, a, 0, 0, 0, n.randFloat(.4, 1), 5e3, 0, i.SubtractiveBlending)
            }
        }
        ,
        this.add = function(t, n, s, a, o, c, l, p, h, u, d, f, m, g) {
            r = null;
            for (var v = 0; v < this.particles.length; ++v)
                if (!this.particles[v].visible && !this.particles[v].static) {
                    r = this.particles[v];
                    break
                }
            r || (r = new i.Sprite,
            this.particles.push(r),
            e.scene.add(r)),
            this.setMaterial(r, m || t, d, !0, g),
            r.visible = !0,
            r.init(n, s, a, o, c, l, p, h, u, f)
        }
        ,
        this.setMaterial = function(t, r, s, a, o) {
            t.material = e.getMat("particles/" + r, {
                mat: i.SpriteMaterial,
                color: null == o ? 16777215 : o,
                depthWrite: !1,
                blending: s || i.NormalBlending,
                rotation: a ? u[n.randInt(0, 2)] : 0
            })
        }
        ,
        this.physObj = function(t, i, n, s, a, o, c, l, u, d, f) {
            if (0 == e.useDepthMap || "0" == e.useDepthMap) {
                r = null;
                for (var m = 0; m < this.physObjs.length; ++m)
                    if (!this.physObjs[m].mesh.visible) {
                        r = this.physObjs[m];
                        break
                    }
                r || (r = new h(e),
                this.physObjs.push(r),
                e.scene.add(r.mesh)),
                r.sid = null == f ? null : f,
                r.mesh.visible = !0,
                r.init(t, i, n, s, a, o, d || p[l], u),
                c && this.showTrails && this.addTrail(r)
            }
        }
        ,
        this.disablePhys = function(e) {
            for (var t = 0; t < this.physObjs.length; ++t)
                this.physObjs[t].sid == e && (this.physObjs[t].mesh.visible = !1)
        }
        ,
        this.update = function(e, t) {
            if (t && t.active)
                for (var r = 0; r < this.areas.length; ++r)
                    this.areas[r].f && (this.areas[r].x = t.x,
                    this.areas[r].y = t.y,
                    this.areas[r].z = t.z);
            for (r = 0; r < this.trails.length; ++r)
                this.trails[r].update(e);
            for (r = 0; r < this.particles.length; ++r)
                this.particles[r].update(e, this.active, t);
            for (r = 0; r < this.physObjs.length; ++r)
                this.physObjs[r].update(e);
            this.ExplosionManager.update(e)
        }
        ,
        this.reset = function() {
            this.particles.length = 0,
            this.trails.length = 0,
            this.physObjs.length = 0,
            this.areas.length = 0
        }
    }
}
, function(e, t) {
    e.exports = [{
        name: "Red Dot",
        src: "attach_0",
        dotSrc: "dot_0",
        aimOffY: .16,
        scale: 1.2
    }]
}
, function(e, t) {
    e.exports = [{
        name: "Nuke",
        kills: 25,
        activate: function(e, t) {
            return !e.nukeTimer && (e.incStat("n", t),
            e.startNuke(t),
            !0)
        }
    }]
}
, function(e, t) {
    e.exports = [{
        name: "Krunker",
        opacity: .6
    }, {
        name: "Target",
        opacity: .6
    }, {
        name: "GG",
        opacity: .6
    }, {
        name: "Pumpkin",
        opacity: .6
    }, {
        name: "Spooky",
        opacity: .6
    }, {
        name: "Ded",
        opacity: .6
    }, {
        name: "Sadface",
        opacity: .6
    }, {
        name: "Laugh Cry",
        opacity: .7
    }, {
        name: "Sid",
        opacity: .9
    }, {
        name: "Vince",
        opacity: .9
    }, {
        name: "Kiki",
        opacity: .6
    }, {
        name: "Ladder",
        opacity: 1
    }, {
        name: "Dummy",
        opacity: 1
    }, {
        name: "8 Ball",
        opacity: .6
    }, {
        name: "xD",
        opacity: .6
    }, {
        name: "MMOK",
        opacity: .7
    }, {
        name: "Madman",
        opacity: .6
    }, {
        name: "Terminal",
        opacity: .6
    }, {
        name: "YODO",
        opacity: .6
    }, {
        name: "Crayon",
        opacity: .6
    }, {
        name: "Myth",
        opacity: .85
    }, {
        name: "SpikyJohn",
        opacity: .85
    }, {
        name: "LevelGaming",
        opacity: .9
    }, {
        name: "PolarAce",
        opacity: .9
    }, {
        name: "FrostyWolf",
        opacity: .85
    }, {
        name: "Waspy",
        opacity: .85
    }, {
        name: "Jazzmittens",
        opacity: .85
    }, {
        name: "Wolfmaan",
        opacity: .85
    }, {
        name: "KPL",
        opacity: .9
    }, {
        name: "BV Hype",
        opacity: .85
    }, {
        name: "LandPhil",
        opacity: .85
    }, {
        name: "Deal With It",
        opacity: .9
    }, {
        name: "Rice",
        opacity: .9
    }, {
        name: "Lore",
        opacity: .95
    }, {
        name: "Desu Sid",
        opacity: .85
    }, {
        name: "Anomaly",
        opacity: .85
    }, {
        name: "FaZe",
        opacity: .9
    }, {
        name: "Nudah",
        opacity: .9
    }, {
        name: "Misfits",
        opacity: .9
    }]
}
, function(e, t) {
    var r = ["Double Kill", "Triple Kill", "Quad Kill", "Multi Kill", "Mega Kill", "Ultra Kill", "Super Kill"]
      , i = [];
    e.exports.reward = function(e, t, n, s, a) {
        i.length = 0;
        var o = null == s.weapon ? t.weapon : s.weapon;
        if (a.mode.weaponOrder)
            o.melee ? i.push("Humiliation", null) : i.push("Promotion", 1);
        else {
            1 >= a.kills && i.push("First Blood", 25),
            o.melee ? i.push("Execution", 150) : (o.kill ? i.push(o.kill[0], o.kill[1]) : o.scope && 1 == t.aimVal ? i.push("No Scope", 100) : !o.scope || 0 == t.aimVal && 180 < t.aimTime || 1 == t.aimDir ? i.push("", 50) : i.push("Quick Scope", 75),
            e.getSpin(t),
            s.headShot && i.push("Headshot", 50),
            s.wallbang && i.push("Wallbang", 25),
            !o.scope && 200 < s.dst * o.range && i.push("Longshot", 25)),
            n.flag && i.push("Snatched", 50),
            t.health <= .2 * t.maxHealth && t.active && i.push("Close Call", 20),
            3 <= t.deathStreak && i.push("Comeback", 25),
            10 <= n.killStreak ? i.push("Buzzkill", 25) : 5 <= n.killStreak && i.push("Buzzkill", 10),
            0 < t.slideTimer && i.push("Driftkill", 50),
            400 <= t.airTime && i.push("Mid Air", 25);
            for (var c = r.length - 1; 0 <= c; --c)
                if (t.streak > c) {
                    i.push(r[c], 50 * (c + 1));
                    break
                }
        }
        return i.length ? i : null
    }
    ,
    e.exports.getScore = function(e) {
        var t = null;
        if (e)
            for (var r = 1; r < e.length; r += 2)
                e[r] && (t += e[r]);
        return t
    }
}
, function(e, t) {}
, , , , , , , , , function(e, t, r) {
    (function(t) {
        var i = r(55)
          , n = r(8)
          , s = r(21)
          , a = r(7)
          , o = r(56)
          , c = r(35)
          , l = 0;
        e.exports.validConfig = function(e) {
            if (e.modes)
                for (var t = 0; t < e.modes.length; ++t)
                    if (!i.modes[e.modes[t]])
                        return "Invalid Mode in Config.";
            if (e.classes)
                for (t = 0; t < e.classes.length; ++t)
                    if (!o[e.classes[t]])
                        return "Invalid Class in Config.";
            if (e.settings) {
                var r = 0;
                for (var s in e.settings)
                    if (e.settings.hasOwnProperty(s)) {
                        var c = e.settings[s]
                          , l = -1;
                        for (t = 0; t < a.serverConfig.length; ++t)
                            if (a.serverConfig[t].varN == s) {
                                l = t;
                                break
                            }
                        if (0 > l)
                            return "Invalid Setting in Config.";
                        var p = a.serverConfig[l];
                        if (!p.input && !p.bool) {
                            if (!n.isNumber(c))
                                return "Invalid Config Value.";
                            if (c > (p.maxF || p.max) || c < p.min)
                                return "Config Value out of Range."
                        }
                        if (++r > a.serverConfig.length + 1)
                            return "Settings Mismatch."
                    }
            }
            return null
        }
        ,
        e.exports.validMap = function(e, t) {
            if (!n.isString(e.name) || !e.name.replace(/\s/g, "").length)
                return "Missing map name.";
            if (-1 !== e.name.indexOf("<") || -1 !== e.name.indexOf(">"))
                return "Illegal characters in map name.";
            if (16 < e.name.length)
                return "Map name too long.";
            if (!n.isArray(e.spawns) || !e.spawns.length)
                return "Missing spawn points.";
            if (e.spawns.length > a.spawnLimit)
                return "Too many spawn points.";
            for (var r, i = 0; i < e.spawns.length; ++i) {
                if (r = e.spawns[i],
                !n.isArray(r) || !r.length || 3 > r.length || 6 < r.length)
                    return "Spawn point error.";
                for (var s = 0; s < r.length; ++s) {
                    if (3 > s && !n.isNumber(r[s]))
                        return "Spawn point error.";
                    if (3 == s && null == r[s] && 1 == r[s] && 2 == r[s])
                        return "Spawn team error."
                }
            }
            if (!n.isArray(e.objects) || !e.objects.length)
                return "Missing objects.";
            if (e.objects.length > (t ? a.objectLimitF : a.objectLimit))
                return "Map exceeds object limit.";
            var o, c = 0;
            for (i = 0; i < e.objects.length; ++i) {
                if (30 == (o = e.objects[i]).i) {
                    if (c++,
                    null != o.st && "string" != typeof o.st)
                        return "Object sign text error.";
                    if ((o.st || "").length > a.signTextLimit)
                        return "Object sign text to long.";
                    if (c > a.signLimit)
                        return "Too many signs.";
                    if (o.sf && o.sf > a.signFontMax || o.sf && o.sf < a.signFontMin)
                        return "Object sign font error."
                }
                if (!n.isArray(o.s) || 3 != o.s.length || !n.arrayInts(o.s))
                    return "Object scale error.";
                if (!n.isArray(o.p) || 3 != o.p.length || !n.arrayInts(o.p))
                    return "Object position error.";
                if (n.isArray(o.r)) {
                    if (3 != o.r.length || !n.arrayInts(o.r))
                        return "Object rotation value error."
                } else if (null != o.r)
                    return "Object rotation error.";
                if (null != o.d && !n.isNumber(o.d))
                    return "Object direction error.";
                o.col = !!o.col
            }
            if (e.game) {
                var l = 0;
                for (var p in e.game)
                    if (e.game.hasOwnProperty(p)) {
                        var h = e.game[p]
                          , u = -1;
                        for (i = 0; i < a.gameConfig.length; ++i)
                            if (a.gameConfig[i].varN == p) {
                                u = i;
                                break
                            }
                        if (0 > u)
                            return "Invalid Setting in Config.";
                        var d = a.gameConfig[u];
                        if (!d.input && !d.bool) {
                            if (!n.isNumber(h))
                                return "Invalid Config Value.";
                            if (h > (d.maxF || d.max) || h < d.min)
                                return "Config Value out of Range."
                        }
                        if (++l > a.gameConfig.length + 1)
                            return "Settings Mismatch."
                    }
            }
            return null
        }
        ,
        e.exports.obj = function(p, h, u, d, f, m, g, v, y, b) {
            this.isCustom = p,
            this.isPrimary = 0 == h,
            this.sid = l++,
            this.gameInstance = null,
            this.updatedGameInstance = !1,
            this.connectedClients = 0,
            this.password = void 0,
            this.pendingGameId = null,
            this.gameClosed = !1,
            this.map = new i.manager(d,m,n,a),
            this.store = r(69),
            this.attach = r(75),
            this.weapons = r(23),
            this.classes = o,
            this.streaks = r(76),
            this.maxStreak = this.streaks.sort((e,t)=>e.kills < t.kills ? 1 : t.kills < e.kills ? -1 : 0)[0].kills,
            this.sprays = r(77),
            this.triggers = r(37),
            this.projectiles = new (r(89))(this,g),
            this.controls = null,
            this.players = new (r(70).manager)(this,d,f,m,n,s,a,g),
            this.endData = {
                ed: [],
                vo: null,
                mts: []
            },
            this.endTimer = 0,
            this.endIndex = null,
            this.banList = [],
            this.destObjs = [],
            this.hideWeapon = [!1, !1, !1],
            this.voteToKick = null,
            this.voteInitiators = [];
            var w, x, M, _ = this, S = null;
            this.applyConfig = function(e, t, r, i) {
                e = e || {},
                this.config = {};
                for (var s, o = 0; o < a.serverConfig.length; ++o)
                    if ((s = a.serverConfig[o]).bool)
                        this.config[s.varN] = null == e[s.varN] ? s.def : !!e[s.varN];
                    else if (s.input) {
                        var c = e[s.varN];
                        n.isString(c) || (c = s.def),
                        this.config[s.varN] = n.sanitizeStr(c),
                        16 < c.length && (c = c.substring(0, 16))
                    } else {
                        c = e[s.varN];
                        n.isNumber(c) || (c = s.def),
                        this.config[s.varN] = n.limitMM(c, s.min, t && s.maxF || s.max)
                    }
                if (this.config.maps = e.maps,
                !n.isArray(this.config.maps) || !this.config.maps.length || this.config.maps.length > this.map.maps.length) {
                    this.config.maps = [];
                    for (o = 0; o < this.map.maps.length; o++)
                        this.config.maps.push(o)
                } else
                    for (o = 0; o < this.config.maps.length; o++)
                        if (!this.map.maps[this.config.maps[o]]) {
                            this.config.maps = [0];
                            break
                        }
                if (this.config.modes = e.modes,
                !n.isArray(this.config.modes) || !this.config.modes.length || this.config.modes.length > this.map.modes.length)
                    this.config.modes = null;
                else
                    for (o = 0; o < this.config.modes.length; o++)
                        if (!this.map.modes[this.config.modes[o]]) {
                            this.config.modes = null;
                            break
                        }
                var l = !1;
                if (this.config.classes = e.classes,
                !n.isArray(this.config.classes) || !this.config.classes.length || this.config.classes.length > this.classes.length)
                    l = !0;
                else
                    for (o = 0; o < this.config.classes.length; o++)
                        if (!this.classes[this.config.classes[o]]) {
                            l = !0;
                            break
                        }
                if (l) {
                    this.config.classes = [];
                    for (o = 0; o < this.classes.length; o++)
                        (!this.classes[o].hide || this.isCustom) && this.config.classes.push(o)
                }
                this.config.isFromQueue = e.isFromQueue || i
            }
            ,
            this.applyConfig(),
            this.getInfo = function() {
                return this.mode.alias + "_" + this.map.maps[this.mapIndex].name
            }
            ,
            this.customMap = function(t, r, i, n, s) {
                if (t)
                    try {
                        var o = JSON.parse(t);
                        if (g && (this.customMapData = {
                            data: t,
                            id: r,
                            featured: n,
                            creator: i
                        }),
                        !s) {
                            var c = e.exports.validMap(o, n);
                            if (c)
                                return c
                        }
                        for (var l = 0; l < o.objects.length; ++l) {
                            if (o.objects[l].i = a.prefabIDS[o.objects[l].i || o.objects[l].id || 0],
                            !o.objects[l].i)
                                return "Object ID error.";
                            if (o.objects[l].t = a.textureIDS[o.objects[l].t || 0],
                            !o.objects[l].t)
                                return "Object Texture error."
                        }
                        o.creator = i,
                        this.map.setMaps([o]),
                        this.config.maps = [0]
                    } catch (t) {
                        return "Map error occured."
                    }
            }
            ,
            this.playSound = function(e, t, r, i, n) {
                if (t)
                    if (f)
                        f.play(e, t, !1, n);
                    else
                        for (var s = 0; s < this.players.list.length; ++s)
                            ((w = this.players.list[s]).active || w.spectating) && (r != w || i) && g.send(w.id, "s", e, r.sid, t)
            }
            ,
            this.playerSound = function(e, t, r, i, s, a) {
                var o = i || this.players.findBySid(t)
                  , c = Howler.pos();
                o && !(a && a < n.getD3D(o.x, o.y, o.z, c[0], c[1], c[2])) && f.play3D(e, o.x, o.y, o.z, r || 1, s)
            }
            ,
            this.triggerImgSound = function(e, t, r) {
                g ? g.send(r.id, "is", e, t) : (e && f.play(e, 1),
                t && imgFlash && (imgFlash.style.display = "block",
                imgFlash.style.opacity = 1,
                imgFlash.style.backgroundImage = "url('https://hoodgail.github.io/krunker_assets/" + t + ".png')"))
            }
            ,
            this.moveObj = function(e, t, r, i) {
                e.x = t,
                e.y = r,
                e.z = i,
                e.meshRef && e.meshRef.position.set(t, r, i)
            }
            ,
            this.explosion = function(e, t, r, i, s, a, o) {
                for (var c = 0; c < this.players.list.length; ++c)
                    if (((w = this.players.list[c]).active || w.spectating) && (g.send(w.id, "ex", Math.round(e), Math.round(t), Math.round(r), Math.round(i)),
                    w.active)) {
                        var l = n.getD3D(e, t, r, w.x, w.y, w.z)
                          , p = 1 - l / i;
                        0 < p && this.players.changeHealth(w, a, s * p * (w == a ? .2 : 1), a == w) && this.players.kill(w, a, {
                            dst: l,
                            weaponId: o.weaponId,
                            weapon: o.weapon
                        })
                    }
            }
            ;
            var T = [];
            this.getSpawnPoint = function(e, t, r) {
                if (r)
                    return this.map.spawns[0];
                T.length = 0;
                for (var i, s = 0; s < this.map.spawns.length; ++s) {
                    this.map.spawns[s].dst = 0;
                    for (var o = 0; o < this.players.list.length; ++o)
                        (w = this.players.list[o]) && w.active && w != t && (!e || w.team != e) && !this.canSee(w, this.map.spawns[s].x, this.map.spawns[s].y + a.fvcbEmTb, this.map.spawns[s].z) && (this.map.spawns[s].dst++,
                        0)
                }
                this.map.spawns.sort(n.orderByDst),
                i = this.map.spawns[0].dst;
                for (s = 0; s < this.map.spawns.length; ++s)
                    if (this.map.spawns[s].dst == i) {
                        this.map.spawns[s].dst = 0;
                        for (o = 0; o < this.players.list.length; ++o)
                            (w = this.players.list[o]).active && w != t && (!e || w.team != e) && (this.map.spawns[s].dst += n.getD3D(this.map.spawns[s].x, this.map.spawns[s].y, this.map.spawns[s].z, w.x, w.y, w.z));
                        (e && this.map.spawns[s].team == e || !this.map.spawns[s].team) && T.push(this.map.spawns[s])
                    }
                return T.sort(n.orderByDst),
                T.reverse(),
                T[0] || this.map.spawns[0]
            }
            ,
            this.canSee = function(e, t, r, i, s) {
                if (!e)
                    return !1;
                s = s || 0;
                for (var o, c = n.getD3D(e.x, e.y, e.z, t, r, i), l = n.getDir(e.z, e.x, i, t), p = n.getDir(n.getDistance(e.x, e.z, t, i), r, 0, e.y), h = 1 / (c * Math.sin(l - Math.PI) * Math.cos(p)), u = 1 / (c * Math.cos(l - Math.PI) * Math.cos(p)), d = 1 / (c * Math.sin(p)), f = e.y + e.height - a.cameraHeight, m = 0; m < this.map.manager.objects.length; ++m)
                    if (!(o = this.map.manager.objects[m]).noShoot && o.active && !o.transparent) {
                        var g = n.lineInRect(e.x, e.z, f, h, u, d, o.x - Math.max(0, o.width - s), o.z - Math.max(0, o.length - s), o.y - Math.max(0, o.height - s), o.x + Math.max(0, o.width - s), o.z + Math.max(0, o.length - s), o.y + Math.max(0, o.height - s));
                        if (g && 1 > g)
                            return g
                    }
                var v = this.map.terrain;
                if (v) {
                    var y = v.raycast(e.x, -e.z, f, 1 / h, -1 / u, 1 / d);
                    if (y)
                        return n.getD3D(e.x, e.y, e.z, y.x, y.z, -y.y)
                }
                return null
            }
            ,
            this.updateAccounts = function() {
                for (var e = [], t = 0; t < this.players.list.length; ++t)
                    (w = this.players.list[t]).account && !w.account.hack && (w.account.timePlayed += w.playTime || 0,
                    this.players.saveClassScores(w),
                    null == this.host && !(this.mode && this.mode.noReward) && (w.account.games++,
                    w.account.kills += w.kills,
                    w.account.deaths += w.deaths,
                    w.account.score += w.score,
                    w.didWin && w.account.wins++,
                    e.push(w)),
                    g.send(w.id, "ua", w.account.getData()));
                e.length && this.saveRewards(e)
            }
            ,
            this.updateELO = function() {
                var e = !0;
                for (var t of this.players.list)
                    if (t.account && t.didWin) {
                        e = !1;
                        break
                    }
                var r = {};
                for (var t of this.players.list)
                    if (!(!t.account || t.account.hack || t.account.level < a.minRankedLevel)) {
                        r[i = t.team || t.id] || (r[i] = {
                            eloAvg: 0,
                            playerCount: 0
                        }),
                        r[i].eloAvg += t.account[this.queueConfig.accountKey],
                        r[i].playerCount += 1
                    }
                for (var i in r)
                    r[i].eloAvg /= r[i].playerCount;
                var n = a.eloK;
                for (var t of this.players.list)
                    if (!(!t.account || t.account.hack || t.account.level < a.minRankedLevel)) {
                        i = t.team || t.id;
                        var s = null;
                        for (var o in r)
                            o != i && (s = r[o].eloAvg);
                        if (null != s) {
                            var c = 1 / (1 + Math.pow(10, (s - t.account[this.queueConfig.accountKey]) / 330))
                              , l = t.didWin ? 1 : 0;
                            t.ELO = e ? 0 : n * (l - c),
                            t.account[this.queueConfig.accountKey] += t.ELO || 0,
                            0 > t.account[this.queueConfig.accountKey] && (t.account[this.queueConfig.accountKey] = 0),
                            u.call(54, [t.account.id, t.account[this.queueConfig.accountKey], this.queueConfig.teamSize], function() {})
                        }
                    }
            }
            ,
            this.saveRewards = function(e) {
                for (var t = "", r = 0; r < e.length; ++r)
                    e[r] && e[r].account && e[r].reward && (t += (t.length ? "," : "") + e[r].account.id + "," + e[r].reward);
                t.length && u.call(20, [t], function(t, r) {
                    if (r && r[0] && r[0][0] && (r = r[0][0].result))
                        try {
                            r = r.split(",");
                            for (var i, n = 0; n < r.length; ++n)
                                (i = parseInt(r[n])) && e[n] && (e[n].account.funds = i,
                                g.send(e[n].id, "uf", i))
                        } catch (e) {}
                })
            }
            ,
            this.incStat = function(e, t) {
                t && t.account && null == this.host && (!t.account.stats[e] && (t.account.stats[e] = 0),
                t.account.stats[e]++)
            }
            ,
            this.checkLeave = function(e) {
                !e || e.account && this.mode && this.mode.isRanked && !this.endTimer && (e.account.stats.abR = Date.now(),
                e.account[this.queueConfig.accountKey] -= a.rankedDeduction,
                0 > e.account[this.queueConfig.accountKey] && (e.account[this.queueConfig.accountKey] = 0),
                u.call(54, [e.account.id, e.account[this.queueConfig.accountKey], this.queueConfig.teamSize], function() {}))
            }
            ,
            this.savePlayerData = function(e, t) {
                if (u && e.account) {
                    if (null == this.host) {
                        var r = 0
                          , i = 0
                          , n = 0;
                        for (var s in a.regionIND)
                            if (s == t) {
                                r = a.regionIND[s];
                                break
                            }
                        if (r)
                            for (var o = 1; 5 > o; ++o)
                                r == o && (!e.account.stats["r" + o] && (e.account.stats["r" + o] = 0),
                                e.account.stats["r" + o]++),
                                e.account.stats["r" + o] && e.account.stats["r" + o] >= n && (n = e.account.stats["r" + o],
                                i = o);
                        i && (e.account.regionInd = i)
                    }
                    var c = e.account;
                    c && u.call(2, [c.id, c.kills, c.wins, c.games, c.deaths, c.score, c.clan, c.timePlayed, JSON.stringify(c.stats), c.regionInd])
                }
            }
            ,
            this.lockPlayer = function(e, t) {
                e.locked = t,
                g.send(e.id, "lock", t)
            }
            ,
            this.lockMove = function(e) {
                _.moveLock = !!e,
                g && g.broadcast("game" + _.sid, "lm", e ? 1 : 0)
            }
            ,
            this.updateTeam = function(e, t) {
                e.team = t;
                for (var r = 0; r < e.sentTo.length; ++r)
                    g.send(e.sentTo[r], "tm", e.sid, t);
                this.players.syncLeaders()
            }
            ,
            this.startNuke = function(e) {
                this.nukeTimer = 1e4,
                this.nukePlayer = e,
                g.broadcast("game" + this.sid, "n", 0)
            }
            ;
            var E = [];
            this.infectRandom = function() {
                E.length = 0;
                for (var e = 0; e < this.players.list.length; ++e)
                    this.players.list[e].active && E.push(e);
                var t = 1;
                14 <= E.length ? t = 3 : 8 <= E.length && (t = 2);
                var r;
                for (e = 0; e < t; ++e)
                    r = n.randInt(0, E.length - 1),
                    (w = this.players.list[E[r]]) && (this.updateTeam(w, "inf"),
                    this.players.kill(w, null, null, !0),
                    g.broadcast("game" + this.sid, "ac", w.sid, null, "got infected")),
                    E.splice(r, 1)
            }
            ,
            this.pickSimon = function() {
                E.length = 0;
                for (var e = null, t = 0; t < this.players.list.length; ++t)
                    if (this.players.list[t].active) {
                        if (this.host == this.players.list[t].id) {
                            e = this.players.list[t];
                            break
                        }
                        E.push(t)
                    }
                e || (e = this.players.list[E[n.randInt(0, E.length - 1)]]),
                e && (this.updateTeam(e, "simon"),
                e.maxHealth = 5e3,
                e.health = e.maxHealth,
                g.send(e.id, "h", e.health))
            }
            ,
            this.pickStalker = function() {
                E.length = 0;
                for (var e = 0; e < this.players.list.length; ++e)
                    this.players.list[e].active && E.push(e);
                (w = this.players.list[E[n.randInt(0, E.length - 1)]]) && (this.updateTeam(w, "stalk"),
                w.maxHealth = 400,
                w.health = w.maxHealth,
                w.regen = 0,
                g.send(w.id, "h", w.health),
                w.updateLoadout(this, 0, !0, 12),
                g.broadcast("game" + this.sid, "inat", w.sid, [12], 0, void 0, void 0, !1))
            }
            ,
            this.pickBoss = function() {
                E.length = 0;
                for (var e = 0; e < this.players.list.length; ++e)
                    this.players.list[e].active && E.push(e);
                (w = this.players.list[E[n.randInt(0, E.length - 1)]]) && (this.updateTeam(w, "boss"),
                w.maxHealth = 1e4,
                w.health = w.maxHealth,
                w.regen = 0,
                g.send(w.id, "h", w.health))
            }
            ,
            this.lockSeekers = function() {
                for (var e = 0; e < this.players.list.length; ++e)
                    this.players.list[e].active && "seek" == this.players.list[e].team && this.lockPlayer(this.players.list[e], !0)
            }
            ,
            this.pickSeeker = function() {
                E.length = 0;
                for (var e = 0; e < this.players.list.length; ++e)
                    this.players.list[e].active && E.push(e);
                (w = this.players.list[E[n.randInt(0, E.length - 1)]]) && (this.updateTeam(w, "seek"),
                this.lockPlayer(w, !0))
            }
            ,
            this.releaseSeeker = function() {
                for (var e = 0; e < this.players.list.length; ++e)
                    "seek" == (w = this.players.list[e]).team && this.lockPlayer(w, !1)
            }
            ,
            this.destroyObj = function(e) {
                for (var t = 0; t < _.map.manager.objects.length; ++t)
                    if ((w = _.map.manager.objects[t]).uid == e) {
                        w.active = !1,
                        w.meshRef && (w.meshRef.visible = !1),
                        d && d.updateShadowMap();
                        break
                    }
            }
            ,
            this.respawnObj = function(e) {
                for (var t = 0; t < _.map.manager.objects.length; ++t)
                    if ((w = _.map.manager.objects[t]).uid == e) {
                        _.destObjs.splice(_.destObjs.indexOf(w.uid), 1),
                        w.active = !0,
                        null != w.health && (w.health = w.startHealth),
                        w.meshRef && (w.meshRef.visible = !0),
                        d && d.updateShadowMap();
                        break
                    }
            }
            ,
            this.capFlag = function(e, t) {
                g && (e.caps++,
                e.flag = null,
                this.teams[e.team] ? this.teams[e.team]++ : this.teams[e.team] = 1,
                g.broadcast("game" + this.sid, "ts", e.team, this.teams[e.team]),
                g.broadcast("game" + _.sid, "ac", e.sid, null, "captured the Flag"),
                g.send(e.id, "am", ["Capture", 150]),
                this.players.score(e, 150),
                this.resetFlag(t))
            }
            ,
            this.updateFlagCol = function(e, t) {
                t && t.team && e.teamCol != t.team && e.meshRef && (e.teamCol = t.team,
                e.meshRef.material = d.getMat("crystal_0", _.map.manager.getFlagDat(e.team, t)),
                e.meshRef.zoneMesh.material = d.getMat("zone_r", _.map.manager.getZoneDat(e.team, t)))
            }
            ,
            this.updateFlags = function(e, t) {
                if (_.mode && _.mode.flags) {
                    for (var r = !1, i = !1, n = 0; n < _.map.manager.flags.length; ++n)
                        (w = _.map.manager.flags[n]).meshRef && (e && _.updateFlagCol(w, e),
                        w.carrier ? (e && w.team == e.team && (i = !0),
                        e && w.carrier == e.sid && (r = !0),
                        (x = _.players.findBySid(w.carrier)) && d.moveMesh(w.meshRef, x.x, x.y + a.flagHOff, x.z)) : d.moveMesh(w.meshRef, w.x, w.y, w.z),
                        w.bobAnimY = (w.bobAnimY || 0) + .003 * t,
                        w.meshRef.position.y += Math.cos(w.bobAnimY),
                        w.meshRef.rotation.y += .002 * t);
                    i && r ? gameMessage.innerHTML != a.flagMsgRC && (gameMessage.innerHTML = a.flagMsgRC) : i ? gameMessage.innerHTML != a.flagMsgE && (gameMessage.innerHTML = a.flagMsgE) : r ? gameMessage.innerHTML != a.flagMsg && (gameMessage.innerHTML = a.flagMsg) : "" != gameMessage.innerHTML && (gameMessage.innerHTML = ""),
                    specGMessage.innerHTML = gameMessage.innerHTML
                }
            }
            ,
            this.updateFlag = function(e, t, r, i, n) {
                for (var s = 0; s < _.map.manager.flags.length; ++s)
                    if ((w = _.map.manager.flags[s]).uid == e) {
                        w.carrier = n,
                        _.moveObj(w, t, r, i);
                        break
                    }
            }
            ,
            this.dropFlag = function(e) {
                if (g && e && e.carrier) {
                    var t = this.players.findBySid(e.carrier);
                    this.updateCarrier(e),
                    t ? (g.broadcast("game" + _.sid, "ac", t.sid, null, "dropped the Flag"),
                    t.flag = null,
                    this.updateObjPos(e, t.x, t.y + a.flagOff, t.z)) : this.updateObjPos(e, e.orgX, e.orgY, e.orgZ)
                }
            }
            ,
            this.pickupFlag = function(e, t) {
                g && _.mode && _.mode.flags && !t.carrier && (e.team == t.team ? (t.x != t.orgX || t.y != t.orgY || t.z != t.orgZ) && (g.broadcast("game" + _.sid, "ac", e.sid, null, "returned the Flag"),
                g.send(e.id, "am", ["Return", 50]),
                this.players.score(e, 50),
                this.resetFlag(t)) : !e.flag && (g.send(e.id, "am", ["Pickup", 20]),
                this.players.score(e, 20),
                this.updateCarrier(t, e),
                g.broadcast("game" + _.sid, "ac", e.sid, null, "got the Flag")))
            }
            ,
            this.syncFlag = function(e) {
                g.broadcast("game" + _.sid, "ufl", e.uid, e.x.round(1), e.y.round(1), e.z.round(1), e.carrier || 0)
            }
            ,
            this.updateCarrier = function(e, t) {
                e.carrier = t ? t.sid : 0,
                t && (t.flag = e),
                this.syncFlag(e)
            }
            ,
            this.resetFlags = function() {
                for (var e = 0; e < _.map.manager.flags.length; ++e)
                    if ((w = _.map.manager.flags[e]).carrier = 0,
                    w.x = w.orgX,
                    w.y = w.orgY,
                    w.z = w.orgZ,
                    w.meshRef) {
                        var t = !(!_.mode || !_.mode.flags);
                        w.meshRef.visible = t,
                        w.meshRef.zoneMesh.visible = t
                    }
            }
            ,
            this.resetFlag = function(e) {
                this.updateObjPos(e, e.orgX, e.orgY, e.orgZ),
                this.updateCarrier(e)
            }
            ,
            this.updatePickup = function(e, t, r, i) {
                if (w = this.map.manager.findByUid(e, this.map.manager.pickups)) {
                    if (d) {
                        x = w.meshRef;
                        var n = i || [x.position.x, x.position.y, x.position.z];
                        d.scene.remove(w.meshRef),
                        w.meshRef = d.loadMesh({
                            src: "weapons/" + this.weapons[t || 0].src,
                            texSrc: "weapons/" + this.weapons[t || 0].src,
                            noGroup: !0,
                            noShadow: !0,
                            transparent: !0,
                            noFog: !0
                        }, ...n, 0, this.weapons[t || 0].scale, d.scene),
                        w.meshRef.rotation.copy(x.rotation.clone()),
                        w.meshRef.visible = null != t
                    }
                    w.x = i ? i[0] : w.orgX,
                    w.y = i ? i[1] : w.orgY,
                    w.z = i ? i[2] : w.orgZ,
                    r && (w.orgPickup = r),
                    w.pickup = t
                }
            }
            ,
            this.resetPickups = function() {
                for (var e = 0; e < _.map.manager.pickups.length; ++e)
                    (w = _.map.manager.pickups[e]).pickup = w.orgPickup,
                    w.x = w.orgX,
                    w.y = w.orgY,
                    w.z = w.orgZ,
                    d && (x = w.meshRef,
                    d.scene.remove(w.meshRef),
                    w.meshRef = d.loadMesh({
                        src: "weapons/" + _.weapons[w.pickup].src,
                        texSrc: "weapons/" + _.weapons[w.pickup].src,
                        noGroup: !0,
                        noShadow: !0,
                        transparent: !0,
                        noFog: !0
                    }, w.x, w.y - a.pickupZoneH / 2 + a.pickupOff, w.z, 0, _.weapons[w.pickup].scale, d.scene),
                    w.meshRef.rotation.copy(x.rotation.clone()),
                    w.meshRef.visible = !0)
            }
            ,
            this.increaseWeapon = function(e, t) {
                (w = null == t.weaponId ? [t.weaponId] : [...e.loadout]).length = 1,
                e.weaponTier++,
                w[0] = e.weaponTier >= this.mode.weaponOrder.length ? this.mode.weaponOrder[this.mode.weaponOrder.length - 1] : this.mode.weaponOrder[e.weaponTier],
                g.broadcast("game" + this.sid, "inat", e.sid, w, 0, void 0, void 0, !1),
                e.updateLoadout(this, 0, !0, ...w)
            }
            ,
            this.decreaseWeapon = function(e) {
                (w = [...e.loadout]).length = 1,
                e.weaponTier--,
                0 > e.weaponTier ? e.weaponTier = 0 : e.setbacks++,
                w[0] = this.mode.weaponOrder[e.weaponTier],
                g.broadcast("game" + this.sid, "inat", e.sid, w, 0, void 0, void 0, !1),
                e.updateLoadout(this, 0, !0, ...w)
            }
            ,
            this.updateGate = function(e, t) {
                for (var r = 0; r < _.map.manager.gates.length; ++r)
                    if ((w = _.map.manager.gates[r]).uid == e) {
                        w.active = t,
                        w.meshRef && (w.meshRef.visible = t),
                        d && d.updateShadowMap();
                        break
                    }
            }
            ,
            this.resetGates = function() {
                for (var e = 0; e < _.map.manager.gates.length; ++e)
                    (w = _.map.manager.gates[e]).active = !w.startClosed,
                    w.meshRef && (w.meshRef.visible = w.active)
            }
            ,
            this.updateBank = function(e, t) {
                for (var r = 0; r < _.map.manager.banks.length; ++r)
                    if ((w = _.map.manager.banks[r]).uid == e) {
                        w.deposited = t;
                        break
                    }
            }
            ,
            this.resetBanks = function() {
                for (var e = 0; e < _.map.manager.banks.length; ++e)
                    (w = _.map.manager.banks[e]).deposited = 0
            }
            ,
            this.updateObjPos = function(e, t, r, i) {
                e.x = t,
                e.y = r,
                e.z = i,
                this.syncFlag(e)
            }
            ,
            this.updateZone = function(e) {
                _.map.zone.update(e)
            }
            ,
            this.resetZone = function() {
                _.map.zone && _.map.zone.reset()
            }
            ,
            this.setObjective = function(e) {
                try {
                    _.activeObjective = e;
                    for (var t = 0; t < _.map.manager.objectives.length; ++t)
                        _.map.manager.objectives[t].mesh.visible = e == t
                } catch (e) {}
            }
            ,
            this.nextObjective = function(e, t) {
                if (this.activeObjective++,
                this.activeObjective >= this.map.manager.objectives.length && (this.activeObjective = 0),
                g.broadcast("game" + this.sid, "obj", this.activeObjective),
                1 < this.map.manager.objectives.length) {
                    var r = {
                        time: 6e4 - (e || 0),
                        contTime: !0,
                        canDMG: !0,
                        msg: "next objective ",
                        trigger: function(e, t) {
                            e.nextObjective(t)
                        }
                    };
                    t && this.waitTimers ? this.waitTimers.push(r) : this.waitTimers = [r]
                }
            }
            ,
            this.setCheckPoint = function(e, t) {
                if (w = {
                    x: t.x,
                    y: t.y,
                    z: t.z,
                    dir: t.dir
                },
                x = Object.values(w).join(","),
                !e.checkPoint || Object.entries(e.checkPoint).toString() !== Object.entries(w).toString()) {
                    if (t.singleUse) {
                        if (e.checkPointList.includes(x))
                            return;
                        e.checkPointList.push(x)
                    }
                    e.checkPoint = w,
                    g && g.send(e.id, "chp")
                }
            }
            ,
            this.checkTeleport = function(e, t) {
                if (!(1 == t.node || 0 < t.telCooldown)) {
                    for (var r = [], i = 0; i < this.map.manager.teleporters.length; ++i)
                        (w = this.map.manager.teleporters[i]).channel == t.channel && 0 < w.node && t.uid != w.uid && r.push(w);
                    if (r.length) {
                        var n = r[0];
                        n && (2 == n.node && (n.telCooldown = 2e3),
                        _.players.changePosition(e, n.x, n.y - n.height, n.z, n.telStopMo))
                    }
                }
            }
            ,
            this.updateTeleporters = function(e) {
                if (_.map.manager.teleporters.length)
                    for (var t = 0; t < _.map.manager.teleporters.length; ++t)
                        (w = _.map.manager.teleporters[t]).telCooldown -= e,
                        0 >= w.telCooldown && (w.telCooldown = 0)
            }
            ,
            this.updateDetructables = function(e) {
                if (g && this.destObjs.length)
                    for (var t = 0; t < this.map.manager.objects.length; ++t)
                        w = this.map.manager.objects[t],
                        -1 < (x = _.destObjs.indexOf(w.uid)) && w.canRespawn && (!w.respawnT && w.respawnR && (w.respawnT = n.randInt(1, 5e3)),
                        w.respawnT -= e,
                        0 >= w.respawnT && (this.destObjs.splice(x, 1),
                        w.active = !0,
                        w.respawnT = w.respawnR ? 0 : w.respawnTStart,
                        null != w.health && (w.health = w.startHealth),
                        g.broadcast("game" + this.sid, "ro", w.uid),
                        w && w.onRespawn && w.destroyedBy && this.onTrigger(w.destroyedBy, w),
                        w.destroyedBy = null))
            }
            ,
            this.updateUI = function() {
                killCount.style.display = this.mode.friendly ? "none" : "inline-block"
            }
            ,
            this.instanceConfig = function() {}
            ,
            this.voteMatch = function(e, t) {
                this.endData.vo && (this.endData.vo[e] = this.endData.vo[e] == t ? null : t,
                g.broadcast("game" + this.sid, "mv", this.endData.vo, this.endData.mts))
            }
            ;
            var A = [];
            this.init = function(e, s, o) {
                this.players.clear(),
                this.teams = {},
                A.length = 0;
                var l = null;
                if (this.endData.mts.length) {
                    for (var p = 0; p < this.endData.mts.length; ++p)
                        if (0,
                        A[p] = 0,
                        this.endData.vo)
                            for (var h in this.endData.vo)
                                this.endData.vo.hasOwnProperty(h) && this.endData.mts[p] == this.endData.vo[h] && A[p]++;
                    var u = 0;
                    for (p = 0; p < A.length; ++p)
                        A[p] > u && (u = A[p],
                        l = this.endData.mts[p]);
                    0 == u && (l = this.endData.mts[0] || null)
                }
                if (null != l) {
                    var d = l.split(",");
                    this.modeIndex = parseInt(d[0]),
                    this.mapIndex = parseInt(d[1])
                } else
                    this.modeIndex = null == s ? this.config.modes ? this.config.modes[n.randInt(0, this.config.modes.length - 1)] : n.randInt(0, 3) : s,
                    this.mapIndex = null == e ? this.config.maps[n.randInt(0, this.config.maps.length - 1)] : e;
                if (this.destObjs.length = 0,
                this.mode = i.modes[this.modeIndex],
                this.map.generate(this.mapIndex, this.mode, o),
                this.resetFlags(),
                this.resetPickups(),
                this.resetGates(),
                this.resetBanks(),
                this.resetZone(),
                this.forceSpawn = this.config.forceSpawn || this.mode.forceSpawn,
                this.minPlayers = this.config.minPlayers || this.mode.minPlayers,
                !this.minPlayers && (this.config.lives || this.mode.lives || 0) && (this.minPlayers = 2),
                this.voteToKick = null,
                this.voteInitiators.length = 0,
                this.needAllTimer = 5e4,
                this.zoneTimer = 0,
                this.nukeTimer = 0,
                this.objectiveTimer = 0,
                this.activeObjective = null,
                this.gameTimer = null == this.mode.gameTime ? 6e4 * this.config.gameTime : this.mode.gameTime,
                this.lastTimer = 0,
                this.lastTimerW = 0,
                this.lastTimerNA = 0,
                this.waitTimers = null,
                this.mode.waitTimers) {
                    this.waitTimers = [];
                    for (p = 0; p < this.mode.waitTimers.length; ++p)
                        this.waitTimers.push({
                            time: this.mode.waitTimers[p].time,
                            trigger: this.mode.waitTimers[p].trigger,
                            noJoin: this.mode.waitTimers[p].noJoin,
                            msg: this.mode.waitTimers[p].msg
                        })
                } else
                    (this.config.lives || this.mode.lives) && (this.waitTimers = [{
                        time: 2e4,
                        msg: "match starts in ",
                        trigger: function(e) {
                            for (var t = 0; t < e.players.list.length; ++t)
                                e.players.list[t].spectating && (e.players.list[t].lives = 0)
                        }
                    }]);
                if (this.config.warmupTime && (this.lockMove(!0),
                !this.waitTimers && (this.waitTimers = []),
                this.waitTimers.unshift({
                    time: 6e4 * this.config.warmupTime,
                    msg: "warmup ends ",
                    trigger: function(e) {
                        e.lockMove(!1)
                    }
                })),
                this.condition = this.mode.condition ? [...this.mode.condition] : null,
                (this.config.lives || this.mode.lives) && (!this.condition && (this.condition = [],
                this.mode.teams ? this.condition.push(function(e) {
                    for (var t = 0, r = 0, i = 0; i < e.players.list.length; ++i)
                        0 < e.players.list[i].lives && (1 == e.players.list[i].team ? t++ : r++);
                    return 1 <= t && 1 <= r
                }) : this.condition.push(function(e) {
                    for (var t = 0, r = 0; r < e.players.list.length; ++r)
                        0 < e.players.list[r].lives && t++;
                    return 1 < t
                })),
                !this.winCondition && (this.mode.teams ? this.winCondition = function(e) {
                    for (var t = 0; t < e.players.list.length; ++t)
                        if (e.players.list[t].team && 0 < e.players.list[t].lives)
                            return e.players.list[t].team;
                    return 1
                }
                : this.winCondition = function(e) {
                    for (var t = 0; t < e.players.list.length; ++t)
                        if (0 < e.players.list[t].lives)
                            return e.players.list[t];
                    return null
                }
                )),
                this.scoreLimit = this.config.scoreLimit || this.mode.scoreLimit || 0,
                this.scoreLimit && (!this.condition && (this.condition = []),
                this.mode.teams ? this.condition.push(function(e) {
                    for (var t = 0; t < e.teams; ++t)
                        if (e.teams[t] >= e.scoreLimit)
                            return 0;
                    return 1
                }) : this.condition.push(function(e) {
                    for (var t = 0; t < e.players.list.length; ++t)
                        if (e.players.list[t].score >= e.scoreLimit)
                            return 0;
                    return 1
                })),
                this.kills = 0,
                g && this.mode.gameStart && this.mode.gameStart(this),
                f) {
                    f.rate = 1;
                    var m = this.mode.ambInd || this.map.maps[this.mapIndex].ambInd || 1;
                    (m = parseInt(m)) != S && (null != S && f.stop("ambient_" + S),
                    S = m,
                    f.play("ambient_" + m, .12, !0, 1))
                }
                if (v) {
                    let e = {
                        mC: this.maxPlayers,
                        pv: this.private,
                        sk: !this.isCustom,
                        pgi: this.pendingGameId,
                        data: {
                            cs: this.isCustom,
                            i: this.getInfo(),
                            v: c
                        }
                    };
                    if (this.gameInstance)
                        this.gameInstance.update(e);
                    else if (this.gameInstance = v.createGame(y, e),
                    this.gameInstance.initiationPromise.then(()=>{
                        this.updatedGameInstance = !0,
                        g.broadcast("game" + this.sid, "inst-id", this.gameInstance.id)
                    }
                    ),
                    g && !a.isProd) {
                        var b = r(79)
                          , w = r(79)
                          , x = b.join(t.cwd(), "version.json");
                        w.watchFile(x, {
                            interval: 100
                        }, ()=>{
                            e.data.v = c = JSON.parse(w.readFileSync(x, "utf8")),
                            this.gameInstance.update(e)
                        }
                        )
                    }
                }
            }
            ,
            this.leaveGame = function(e) {
                var t = this.host == e;
                (this.config.isFromQueue ? 0 >= this.connectedClients : t) ? this.destroyGame(t) : this.mode && this.mode.needAll && this.endGame(3)
            }
            ,
            this.startQueuedGame = function() {
                this.config.isFromQueue
            }
            ,
            this.getTeamScores = function() {
                var e = null;
                return this.mode && this.mode.teams && this.teams && (e = [[1, this.teams[1] || 0], [2, this.teams[2] || 0]]),
                e
            }
            ,
            this.getSyncData = function() {
                for (var e = [], t = [], r = [], i = [], n = 0; n < this.map.manager.flags.length; ++n)
                    w = this.map.manager.flags[n],
                    e.push([w.uid, w.x.round(1), w.y.round(1), w.z.round(1), w.carrier || 0]);
                for (n = 0; n < this.map.manager.pickups.length; ++n)
                    w = this.map.manager.pickups[n],
                    t.push([w.uid, w.pickup, w.orgPickup || 0, [w.x, w.y, w.z]]);
                for (n = 0; n < this.map.manager.gates.length; ++n)
                    w = this.map.manager.gates[n],
                    r.push([w.uid, w.active]);
                for (n = 0; n < this.map.manager.banks.length; ++n)
                    w = this.map.manager.banks[n],
                    i.push([w.uid, w.deposited]);
                return {
                    dest: this.destObjs.length ? this.destObjs : 0,
                    flg: e.length ? e : 0,
                    pkups: t.length ? t : 0,
                    gates: r.length ? r : 0,
                    banks: i.length ? i : 0,
                    zone: this.map.zone ? this.map.zone.scale : 0,
                    lck: this.moveLock ? 1 : 0
                }
            }
            ,
            this.onTrigger = function(e, t) {
                g && this.triggers.actions[t.triggerAction] && this.triggers.actions[t.triggerAction].execute(this, g, e, t)
            }
            ,
            this.endGame = function(e) {
                if (this.endTimer = this.mode.infEndTimer ? "inf" : a.endTimer,
                this.endIndex = null == e ? null : e,
                this.waitTimers = null,
                this.mode.endSort ? this.players.list.sort(this.mode.endSort) : this.players.list.sort(n.orderByScore),
                null != this.endIndex)
                    this.winner = null;
                else if (this.mode.winCondition)
                    this.winner = this.mode.winCondition(this);
                else if (this.mode.teams && this.teams) {
                    var t = 0
                      , r = null;
                    for (var i in this.teams)
                        this.teams.hasOwnProperty(i) && this.teams[i] >= t && (t = this.teams[i],
                        r = i);
                    this.winner = 0 == t ? null : r
                } else
                    this.winner = this.players.list[0];
                for (var s = 0; s < this.players.list.length; ++s)
                    (w = this.players.list[s]).didWin = w.team && w.team == this.winner || w == this.winner;
                if (this.mode.isRanked && this.updateELO(),
                null == this.host && null == this.endIndex)
                    for (s = 0; s < this.players.list.length; ++s)
                        if ((w = this.players.list[s]).reward = 0,
                        w.account && !w.account.hack) {
                            var o = w.score * (this.mode.rewardMlt || 1);
                            w.reward = Math.min(30, Math.floor(o / 100)),
                            w.challMode && (w.reward = Math.floor(1.5 * w.reward))
                        }
                this.endData.ed.length = 0;
                var c = this.mode.endStats || a.endStats;
                for (s = 0; s < this.players.list.length; ++s)
                    for (var l = 0; l < c.length; ++l)
                        this.endData.ed.push(a.endForm[c[l]] ? a.endForm[c[l]](this.players.list[s][c[l]], this, this.players.list[s]) : this.players.list[s][c[l]]);
                this.endData.vo = {},
                this.endData.tms = this.getTeamScores();
                let p = this.config ? this.config.modes || this.map.rotationModes : null
                  , h = this.config.maps || this.map.rotationMaps;
                this.endData.mts.length = 0;
                for (var u = 0, d = -1 < p.indexOf(0); 4 > this.endData.mts.length; ) {
                    let e = 0 == u && d ? 0 : p ? p[n.randInt(0, p.length - 1)] : n.randInt(0, 3)
                      , t = h[n.randInt(0, h.length - 1)];
                    if (0 > this.endData.mts.indexOf(e + "," + t) && this.endData.mts.push(e + "," + t),
                    20 < ++u)
                        break
                }
                for (s = 0; s < this.players.list.length; ++s)
                    (w = this.players.list[s]).reset(),
                    w.account && !this.isCustom && (w.account.playedMatch = !0),
                    g.send(w.id, "end", !1, this.winner ? w.didWin : -1, this.endData, w.account && w.account.playedMatch);
                this.updateAccounts(),
                this.players.clear()
            }
            ,
            this.update = function(e, t, r) {
                if (this.now = t,
                g) {
                    var i = !0;
                    if (0 < this.endTimer ? (i = !1,
                    this.endTimer -= e,
                    0 >= this.endTimer ? (this.init(),
                    this.endTimer = 0,
                    g.broadcast("game" + this.sid, "init", this.mapIndex, this.modeIndex, this.getTeamScores(), this.activeObjective, this.host, this.config, 0, this.customMapData ? 1 : null, this.getSyncData()),
                    this.isPrimary && n.restartIfNeeded(g)) : (M = n.getTime(this.endTimer)) != this.lastTimer && (this.lastTimer = M,
                    g.broadcast("game" + this.sid, "t", M, 1))) : "inf" == this.endTimer ? this.endTimer != this.lastTimer && (this.lastTimer = this.endTimer,
                    g.broadcast("game" + this.sid, "t", "inf", this.endIndex || 2)) : this.waitTimers && (i = !1,
                    !this.waitTimers[0].contTime && this.minPlayers && this.players.activeCount() < this.minPlayers ? this.mode.needAll ? (this.needAllTimer -= e,
                    0 >= this.needAllTimer ? this.endGame(3) : (M = n.getTime(this.needAllTimer)) != this.lastTimerNA && (this.lastTimerNA = M,
                    g.broadcast("game" + this.sid, "gmsg", "wt", M))) : g.broadcast("game" + this.sid, "gmsg", "wt") : (this.waitTimers[0].time -= e,
                    0 >= this.waitTimers[0].time ? (this.waitTimers[0].trigger && this.waitTimers[0].trigger(this, -this.waitTimers[0].time),
                    0 >= this.waitTimers[0].time && (this.waitTimers.splice(0, 1),
                    !this.waitTimers.length && (this.waitTimers = null,
                    g.broadcast("game" + this.sid, "gmsg")))) : (M = n.getTime(this.waitTimers[0].time)) != this.lastTimerW && (this.lastTimerW = M,
                    g.broadcast("game" + this.sid, "gmsg", this.waitTimers[0].msg + M)))),
                    0 >= this.endTimer && (i || this.waitTimers && this.waitTimers[0].contTime)) {
                        if (this.condition)
                            for (var s = 0; s < this.condition.length; s++)
                                if (!this.condition[s](this)) {
                                    this.gameTimer = "skip";
                                    break
                                }
                        "skip" != this.gameTimer && this.mode.timed ? (this.gameTimer += e,
                        (M = n.getTime(this.gameTimer, this.mode.showMS)) != this.lastTimer && (this.lastTimer = M,
                        g.broadcast("game" + this.sid, "t", M))) : (0 < this.gameTimer || "skip" == this.gameTimer) && ("skip" != this.gameTimer && (this.gameTimer -= e),
                        "skip" == this.gameTimer || 0 >= this.gameTimer ? (this.gameTimer = 0,
                        this.endGame()) : (M = n.getTime(this.gameTimer, this.mode.showMS)) != this.lastTimer && (this.lastTimer = M,
                        g.broadcast("game" + this.sid, "t", M)))
                    }
                    if (0 >= this.endTimer && this.nukeTimer && (this.nukeTimer -= e,
                    0 >= this.nukeTimer && (this.nukeTimer = 0,
                    g.broadcast("game" + this.sid, "n", 1),
                    this.nukePlayer))) {
                        var a = 0;
                        for (s = 0; s < this.players.list.length; ++s)
                            (w = this.players.list[s]).active && w != this.nukePlayer && (!w.team || this.nukePlayer.team != w.team) && (a += 50,
                            this.players.kill(w, this.nukePlayer, {
                                streak: 0
                            }, !1, !0));
                        a && (g.send(this.nukePlayer.id, "6", ["Nuke", a], 0, this.nukePlayer.kills, a / 50),
                        g.send(this.nukePlayer.id, "4"),
                        this.players.score(this.nukePlayer, a))
                    }
                    this.voteToKick && (this.voteToKick.timer -= e,
                    0 >= this.voteToKick.timer && (this.voteToKick = null,
                    g.broadcast("game" + this.sid, "vk", null)))
                }
                if (this.players.update(e * this.config.deltaMlt),
                this.updateTeleporters(e),
                this.updateDetructables(e),
                g && this.mode.objective && this.map.manager.objectives.length && this.waitTimers && this.waitTimers[0].contTime && (this.objectiveTimer -= e,
                0 >= this.objectiveTimer)) {
                    this.objectiveTimer = 1500;
                    for (s = 0; s < this.map.manager.objectives.length; ++s)
                        if (w = this.map.manager.objectives[s],
                        s == this.activeObjective)
                            for (var o = 0; o < this.players.list.length; ++o)
                                (x = this.players.list[o]).active && x.collides(w) && this.players.score(x, 10)
                }
                if (this.map.zone)
                    if (!g || this.waitTimers)
                        this.map.zone.animate(e);
                    else if (this.zoneTimer -= e,
                    0 >= this.zoneTimer) {
                        this.zoneTimer = 1e3,
                        this.map.zone.shrink(),
                        g.broadcast("game" + this.sid, "zn", this.map.zone.scale);
                        for (o = 0; o < this.players.list.length; ++o)
                            (x = this.players.list[o]).active && "inf" != x.team && this.map.zone.isOutside(x) && this.players.changeHealth(x, null, 10) && this.players.kill(x, null, {})
                    }
                this.projectiles.update(e * this.config.deltaMlt),
                m && m.update(e * this.config.deltaMlt, r),
                d && d.render(e * this.config.deltaMlt)
            }
            ,
            this.destroyGame = function() {
                g.broadcast("game" + this.sid, "error", "Host ended game"),
                g.clearRoom("game" + this.sid),
                this.gameInstance.destroy();
                var e = b.indexOf(this);
                0 <= e && b.splice(e, 1)
            }
            ,
            this.validateAccountName = function(e) {
                return !this.validAccountNames || !!e && -1 != this.validAccountNames.indexOf(e)
            }
        }
    }
    ).call(this, r(14))
}
, function(e, t, r) {
    var i = r(8)
      , n = r(7)
      , s = function() {
        this.init = function(e, t, r, i, n, s, a, o) {
            this.x = e,
            this.y = t,
            this.z = r,
            i -= Math.PI,
            this.xD = i,
            this.yD = n,
            this.spd = s.spd,
            this.range = s.range,
            this.dmg = s.dmg,
            this.owner = a,
            this.weaponId = o.weaponId,
            this.weapon = o.weapon,
            this.skipMove = !0,
            this.expl = s.explode,
            this.xS = this.spd * Math.sin(i) * Math.cos(n),
            this.zS = this.spd * Math.cos(i) * Math.cos(n),
            this.yS = this.spd * Math.sin(n),
            this.active = !0
        }
        ,
        this.update = function(e) {
            this.active && (this.skipMove ? this.skipMove = !1 : (this.x += this.xS * e,
            this.z += this.zS * e,
            this.y += this.yS * e,
            this.range -= this.spd * e,
            0 >= this.range && (this.active = !1)))
        }
    };
    e.exports = function(e, t) {
        var a, o, c = t ? {} : r(4), l = [];
        this.projectiles = [],
        this.types = [{
            mat: c.MeshBasicMaterial,
            color: 16777179,
            explode: 35,
            dmg: 60,
            spd: .5,
            scale: 1.4,
            length: 10,
            range: 600
        }, {
            mat: c.MeshBasicMaterial,
            color: 16777179,
            dmg: 200,
            spd: .68,
            scale: .7,
            length: 10,
            range: 1e3
        }],
        this.update = function(r) {
            for (var s = 0; s < this.projectiles.length; ++s)
                if ((a = this.projectiles[s]).active) {
                    if (a.update(r),
                    a.active) {
                        l.length = 0;
                        for (var c = 1 / (a.spd * r * Math.sin(a.xD) * Math.cos(a.yD)), p = 1 / (a.spd * r * Math.cos(a.xD) * Math.cos(a.yD)), h = 1 / (a.spd * r * Math.sin(a.yD)), u = 0; u < e.map.manager.objects.length; ++u)
                            !(o = e.map.manager.objects[u]).noShoot && o.active && (tmpDst = i.lineInRect(a.x, a.z, a.y, c, p, h, o.x - o.width, o.z - o.length, o.y - o.height, o.x + o.width, o.z + o.length, o.y + o.height),
                            tmpDst && 1 >= tmpDst && l.push({
                                obj: o,
                                dst: tmpDst
                            }));
                        for (u = 0; u < e.players.list.length; ++u)
                            (o = e.players.list[u]).active && o != a.owner && (tmpDst = i.lineInRect(a.x, a.z, a.y, c, p, h, o.x - o.scale - n.hitBoxPad, o.z - o.scale - n.hitBoxPad, o.y, o.x + o.scale + n.hitBoxPad, o.z + o.scale + n.hitBoxPad, o.y + o.height + n.hitBoxPad),
                            tmpDst && 1 >= tmpDst && l.push({
                                plr: !0,
                                obj: o,
                                dst: tmpDst
                            }));
                        var d = e.map.terrain;
                        if (d) {
                            var f = d.raycast(a.x, -a.z, a.y, 1 / c, -1 / p, 1 / h);
                            if (f) {
                                let e = i.getD3D(a.x, a.y, a.z, f.x, f.z, -f.y);
                                l.push({
                                    dst: e / a.range
                                })
                            }
                        }
                        l.length && (l.sort(i.orderByNum),
                        l[0] && (t && !e.waitTimers && l[0].obj && l[0].obj.health && !l[0].plr && (l[0].obj.health -= a.dmg,
                        t.send(a.owner.id, "4"),
                        0 >= l[0].obj.health && (l[0].obj.active = !1,
                        l[0].obj.health = 0,
                        l[0].obj.destroyedBy = a.owner,
                        e.destObjs.push(l[0].obj.uid),
                        t.broadcast("game" + e.sid, "do", l[0].obj.uid),
                        l[0].obj && l[0].obj.onDestroy && e.onTrigger(a.owner, l[0].obj)),
                        l[0].obj && (l[0].obj.onShoot || l[0].obj.onDamage) && e.onTrigger(a.owner, l[0].obj)),
                        l[0].obj && l[0].plr && e.players.changeHealth(l[0].obj, a.owner, a.dmg) && e.players.kill(l[0].obj, a.owner, {
                            weaponId: a.weaponId,
                            weapon: a.weapon
                        }),
                        a.x += l[0].dst * (a.xS * r),
                        a.y += l[0].dst * (a.yS * r),
                        a.z += l[0].dst * (a.zS * r)),
                        a.active = !1)
                    }
                    if (!a.active) {
                        a.expl && e.explosion(a.x, a.y, a.z, a.expl, a.dmg, a.owner, {
                            weaponId: a.weaponId,
                            weapon: a.weapon
                        });
                        for (u = 0; u < e.players.list.length; ++u)
                            t.send(e.players.list[u].id, "pre", a.sid)
                    }
                }
        }
        ,
        this.init = function(r, i, n, o, c, l, p, h) {
            r = r.round(1),
            i = i.round(1),
            n = n.round(1),
            o = o.round(3),
            c = c.round(3),
            a = null;
            for (var u = 0; u < this.projectiles.length; ++u)
                if (!this.projectiles[u].active) {
                    a = this.projectiles[u];
                    break
                }
            if (a || ((a = new s).sid = this.projectiles.length,
            this.projectiles.push(a)),
            a.init(r, i, n, o, c, this.types[l], p, h),
            t)
                for (u = 0; u < e.players.list.length; ++u)
                    (e.players.list[u].active || e.players.list[u].spectating) && t.send(e.players.list[u].id, "pr", r, i, n, o, c, l, a.sid)
        }
    }
}
, , , , , , , , , , , , , , , , , , , , , , , , , function(e, t, r) {
    r(62),
    console.warn = (()=>{}
    ),
    console.info = (()=>{}
    );
    var i = r(21)
      , n = r(4);
    n.OBJLoader = r(64)(n),
    n.OrbitControls = r(115)(n),
    n.Shaders = r(65)(n);
    r(24);
    var s = r(8)
      , a = r(7)
      , o = new (r(57))(n,s,i,a)
      , c = new (r(74))(o,a)
      , l = r(88).obj;
    l = new l(!1,0,null,o,null,c);
    var p, h = r(70).Player, u = new n.Clock;
    let d;
    var f, m, g, v, y, b = [], w = [], x = new URLSearchParams(window.location.search), M = !!x.has("swap") && x.get("swap"), _ = {
        skinPrim: parseInt(x.get("skinIdP")) || -1,
        hatIndex: parseInt(x.get("hat")) || -1,
        backIndex: parseInt(x.get("back")) || -1,
        meleeIndex: parseInt(x.get("melee")) || -1,
        skinColIndex: parseInt(x.get("skinCol")) || -1,
        secondaryInd: parseInt(x.get("secIndex")) || 2,
        classIndex: parseInt(x.get("class")) || 0,
        attachIndex: parseInt(x.get("attach")) || -1,
        customHat: ()=>H(1),
        customBack: ()=>H(2),
        custom: ()=>H(),
        customHatJson: ()=>(G(1),
        F()),
        customBackJson: ()=>(G(2),
        F()),
        resetJson: ()=>(L.length = 0,
        F()),
        reset: ()=>(o.reset(),
        F()),
        swap: ()=>(M = M ? 0 : -1,
        F()),
        swapMelee: ()=>(M = M ? 0 : 1,
        F()),
        showPlayer: !x.has("hidePlayer"),
        lighting: "In-game",
        season: parseInt(x.get("season")) || a.currentSeason,
        screenshot: ()=>(function() {
            var e = new Image;
            e.onload = function() {
                let t = document.createElement("canvas");
                t.width = d.domElement.width,
                t.height = d.domElement.height;
                let r = t.getContext("2d")
                  , i = r.createLinearGradient(0, 0, 0, t.width);
                i.addColorStop(0, "#7d8fa3"),
                i.addColorStop(1, "#1b1c1e"),
                r.fillStyle = i,
                r.fillRect(0, 0, t.width, t.height),
                r.drawImage(e, 0, 0);
                let n = document.createElement("a");
                n.href = t.toDataURL("image/png"),
                n.download = "render.png",
                n.click()
            }
            ,
            e.src = d.domElement.toDataURL("image/png")
        }
        )(),
        renderWep: ()=>W(),
        renderHat: ()=>(function() {
            p.weaponGeos[0].visible = !1,
            f.position.x = 0,
            f.position.y = 10,
            f.position.z = -15,
            p.objInstances.rotation.y = Math.PI / 6.5;
            var e = new n.Vector3(0,6,0);
            f.lookAt(e),
            m.target = e,
            f.updateProjectionMatrix();
            let t = l.store.skins[_.hatIndex]
              , r = (t ? t.type + "_" + t.id + (t.tex ? "_" + t.tex : "") : "1_default") + ".png";
            setTimeout(function() {
                var e = new Image;
                e.onload = function() {
                    let t = document.createElement("canvas");
                    t.width = 256,
                    t.height = 256;
                    let i = t.getContext("2d");
                    i.drawImage(e, d.domElement.width / 2 - 128, 100, 256, 256, 0, 0, t.width, t.width);
                    let n = document.createElement("a");
                    n.href = t.toDataURL("image/png"),
                    n.download = r,
                    n.click()
                }
                ,
                e.src = d.domElement.toDataURL("image/png")
            }, 500)
        }
        )(),
        renderBack: ()=>(function() {
            p.weaponGeos[0].visible = !1,
            p.objInstances.rotation.y = Math.PI,
            f.position.x = 0,
            f.position.y = 10,
            f.position.z = -15;
            var e = new n.Vector3(0,6,0);
            f.lookAt(e),
            m.target = e,
            f.updateProjectionMatrix();
            let t = l.store.skins[_.backIndex]
              , r = (t ? t.type + "_" + t.id + (t.tex ? "_" + t.tex : "") : "2_default") + ".png";
            setTimeout(function() {
                var e = new Image;
                e.onload = function() {
                    let t = document.createElement("canvas");
                    t.width = 256,
                    t.height = 256;
                    let i = t.getContext("2d");
                    i.drawImage(e, d.domElement.width / 2 - 256, 100, 512, 512, 0, 0, t.width, t.width);
                    let n = document.createElement("a");
                    n.href = t.toDataURL("image/png"),
                    n.download = r,
                    n.click()
                }
                ,
                e.src = d.domElement.toDataURL("image/png")
            }, 500)
        }
        )()
    };
    let S, T = [[0, 150, 0], [150, 0, 0], [0, 0, 150]], E = [], A = parseInt(x.get("cosmetic")), P = null, O = s.isNumber(A) || x.get("dev"), R = x.has("auto"), C = x.has("nosup"), L = [];
    function I(e) {
        var t = !1;
        if (l.store.skins[e] && l.store.skins[e].weapon && (t = !0),
        l.store.skins[e] && l.store.skins[e].type && 3 == l.store.skins[e].type && (t = !0),
        !t)
            return R ? ++A >= l.store.skins.length ? (A = 0,
            void (R = !1)) : I(A) : void 0;
        P && (g.remove(P),
        P = null);
        let r = l.store.skins[e];
        var i = l.weapons[(r.weapon || 1) - 1]
          , s = r.type ? r : l.store.previews[r.weapon] || {};
        (P = o.genObj3D(0, 1 + (s.yOff || 0), s.xOff || 0)).rotateX(-.25 * (r.type && 3 == r.type ? 2.5 : 1)),
        P.rotateY(Math.PI + .5 + (s.zRota || 0)),
        P.rotateZ(6 == r.weapon ? 0 : -.25),
        P.orgXR = P.rotation.x,
        P.orgYP = P.position.y,
        r.type && 3 == r.type && (i.expScale = 3 == r.id ? 1.1 : 2 == r.id ? .875 : 1 == r.id ? .9 : 1.2),
        o.loadMesh({
            src: l.store.types[r.type || 0] + (r.type ? r.id : r.weapon) + (null == r.mid ? "" : "_" + r.mid),
            texSrc: null == r.mid ? r.type && 3 == r.type ? "melee/melee_" + (r.id || 0) + (r.tex ? "_" + r.tex : "") : r.tex ? r.tex : r.type ? r.tex ? (1 == r.type ? "hats/hat_" : "body/body_") + r.id + "_" + r.tex : null : "weapons/skins/weapon_" + r.weapon + "_" + r.id : r.midT,
            mat: n.MeshPhongMaterial,
            shininess: 60,
            movT: r.movT,
            pulsT: r.pulsT,
            frames: r.frames,
            frameT: r.frameT,
            sameGlow: r.sameGlow,
            glowText: !(r.type && 3 > r.type) && (r.glow || r.sameGlow),
            emissive: r.glow || r.sameGlow ? 16777215 : null,
            noGreen: !0,
            uv2: !0,
            fillScale: 60,
            centerZ: !0
        }, 0, 0, 0, (r.type && 3 != r.type ? Math.PI : Math.PI / 2) + (s.xRot || 0), 2.2 * (s.scl || 1) * (i.expScale || 1), P),
        g.add(P)
    }
    function k() {
        for (let e in S && g.remove(S),
        E)
            g.remove(E[e]);
        if (E.length = 0,
        "Viewer" == _.lighting && !s.isNumber(A))
            for (let e, t = 0; t < T.length; t++) {
                (e = new n.SpotLight(16777215)).position.set(...T[t]),
                e.target.position.set(0, 0, 0),
                g.add(e),
                E.push(e);
                let r = new n.SpotLight(16777215);
                r.position.set(...T[t].map(e=>-Math.abs(e))),
                r.target.position.set(0, 0, 0),
                g.add(r),
                E.push(r)
            }
        if ("In-game" == _.lighting || s.isNumber(A)) {
            (S = new n.DirectionalLight(15923452,1.2)).layers.enable(1),
            g.add(S);
            var e = -.3 * Math.PI
              , t = 2 * Math.PI * -.25;
            S.position.x = a.lightDistance * Math.cos(t),
            S.position.y = a.lightDistance * Math.sin(t) * Math.sin(e),
            S.position.z = a.lightDistance * Math.sin(t) * Math.cos(e),
            S.castShadow = !0,
            S.shadow.mapSize.width = a.shadowRes,
            S.shadow.mapSize.height = a.shadowRes,
            S.shadow.camera.right = Math.round(Math.abs(0) / 2.5),
            S.shadow.camera.left = -Math.round(Math.abs(0) / 2.5),
            S.shadow.camera.top = Math.round(Math.abs(0) / 2.5),
            S.shadow.camera.bottom = -Math.round(Math.abs(0) / 2.5),
            S.shadow.camera.far = a.shadowDst
        }
        if (s.isNumber(A)) {
            var r = new n.DirectionalLight(16777215,.5);
            r.position.set(3, 1, 0),
            g.add(r)
        }
    }
    function D() {
        let e = new dat.GUI;
        if (e.width = 322,
        e.open(),
        s.isNumber(A))
            e.add(_, "renderWep").name("Render");
        else {
            for (var t = {
                All: 0
            }, r = 1; r <= a.currentSeason; r++)
                t[r] = r;
            e.add(_, "season").options(t).name("Season").listen().onChange(()=>{
                z(),
                B()
            }
            ),
            y = e.addFolder("Player"),
            z(),
            v = e.addFolder("Weapons"),
            B(!0),
            e.add(_, "lighting").options(["Viewer", "In-game"]).name("Lighting").listen().onChange(()=>k()),
            e.add(_, "screenshot").name("Take a Screenshot")
        }
    }
    function z() {
        for (let e of w)
            e instanceof dat.GUI ? y.removeFolder(e) : y.remove(e);
        let e;
        w.length = 0,
        e = y.add(_, "showPlayer").name("Show Model").listen().onChange(e=>{
            F();
            var t = e ? new n.Vector3(0,5,0) : new n.Vector3(p.weaponMeshes[0].position.x + 3,p.weaponMeshes[0].position.y + 6,p.weaponMeshes[0].position.z + 3);
            f.position.z = 0,
            f.position.x = 15,
            f.position.y = 5,
            f.lookAt(t),
            m.target = t,
            m.update(),
            f.updateProjectionMatrix()
        }
        ),
        w.push(e),
        e = y.add(_, "classIndex").options(function() {
            let e = {};
            for (let t in l.classes)
                e[l.classes[t].name] = parseInt(t);
            return e
        }()).name("Class").listen().onChange(()=>(M = 0,
        B())),
        w.push(e),
        e = y.add(_, "hatIndex").options(U(1)).name("Hat").listen().onChange(()=>F()),
        w.push(e),
        e = y.add(_, "customHatJson").name("Hat Config"),
        w.push(e),
        e = y.add(_, "customHat").name("Load Custom Hat"),
        w.push(e),
        x.has("dev") && (e = y.add(_, "renderHat").name("Render Hat"),
        w.push(e)),
        e = y.add(_, "backIndex").options(U(2)).name("Back").listen().onChange(()=>F()),
        w.push(e),
        e = y.add(_, "customBackJson").name("Back Config"),
        w.push(e),
        e = y.add(_, "customBack").name("Load Custom Back"),
        w.push(e),
        x.has("dev") && (e = y.add(_, "renderBack").name("Render Back"),
        w.push(e)),
        e = y.add(_, "skinColIndex").options(function() {
            let e = {
                Default: -1
            };
            for (let t in a.skinColors)
                e["Skin Tone #" + t] = parseInt(t);
            return e
        }()).name("Skin Color").listen().onChange(()=>F()),
        w.push(e),
        e = y.add(_, "resetJson").name("Reset Config"),
        w.push(e),
        y.open()
    }
    function B(e) {
        for (let e of b)
            e instanceof dat.GUI ? v.removeFolder(e) : v.remove(e);
        let t;
        if (b.length = 0,
        C || (_.skinPrim = -1),
        t = v.add(_, "skinPrim").options(function(e=null) {
            let t = (e || l.classes[_.classIndex].loadout[0]) + 1
              , r = l.store.skins.filter(e=>e && e.weapon == t && (0 == _.season || _.season == (e.seas || 1))).sort((e,t)=>e.id > t.id ? 1 : t.id > e.id ? -1 : 0).sort((e,t)=>e.rarity > t.rarity ? 1 : t.rarity > e.rarity ? -1 : 0).sort((e,t)=>e.seas > t.seas ? 1 : t.seas > e.seas ? -1 : 0).reverse()
              , i = {
                Default: -1
            };
            for (let e of r)
                i[e.name + " [" + l.store.rarities[e.rarity].name + "]"] = l.store.skins.findIndex(r=>r && r.weapon && r.weapon == t && r.id == e.id && r.name == e.name);
            return i
        }()).name("Primary Skin").listen().onChange(()=>F()),
        b.push(t),
        t = v.add(_, "attachIndex").options(function() {
            let e = {
                None: -1
            };
            if (null == l.weapons[l.classes[_.classIndex].loadout[0]].attach)
                return e;
            for (let t in l.attach)
                e[l.attach[t].name] = parseInt(t);
            return e
        }()).name("Attachments").listen().onChange(()=>F()),
        b.push(t),
        l.classes[_.classIndex].secondary && (t = v.add(_, "secondaryInd").options(function() {
            let e = {};
            for (let t in l.weapons)
                l.weapons[t].secondary && (e[l.weapons[t].name] = parseInt(t));
            return e
        }()).name("Secondary").listen().onChange(()=>F()),
        b.push(t)),
        t = v.add(_, "meleeIndex").options(function() {
            let e = l.store.skins.filter(e=>e && 3 == e.type && (0 == _.season || _.season == (e.seas || 1))).sort((e,t)=>e.id > t.id ? 1 : t.id > e.id ? -1 : 0).sort((e,t)=>e.rarity > t.rarity ? 1 : t.rarity > e.rarity ? -1 : 0).sort((e,t)=>e.seas > t.seas ? 1 : t.seas > e.seas ? -1 : 0).reverse()
              , t = {
                Default: -1
            };
            for (let r of e)
                t[r.name + " [" + l.store.rarities[r.rarity].name + "]"] = l.store.skins.findIndex(e=>e && 3 == e.type && e.id == r.id && e.tex == r.tex);
            return t
        }()).name("Melee").listen().onChange(()=>F()),
        b.push(t),
        l.classes[_.classIndex].secondary && (t = v.add(_, "swap").name("Swap Secondary"),
        b.push(t)),
        t = v.add(_, "swapMelee").name("Swap Melee"),
        b.push(t),
        t = v.add(_, "custom").name("Load Skin"),
        b.push(t),
        t = v.add(_, "reset").name("Reset Skins"),
        b.push(t),
        v.open(),
        F(),
        !_.showPlayer && e) {
            var r = new n.Vector3(p.weaponMeshes[0].position.x + 3,p.weaponMeshes[0].position.y + 6,p.weaponMeshes[0].position.z + 3);
            f.position.z = 0,
            f.position.x = 15,
            f.position.y = 5,
            f.lookAt(r),
            m.target = r,
            m.update(),
            f.updateProjectionMatrix()
        }
    }
    function N() {
        f.aspect = container.offsetWidth / container.offsetHeight,
        f.updateProjectionMatrix(),
        d.setSize(window.innerWidth, window.innerHeight),
        j()
    }
    function j() {
        d.clear(),
        d.render(g, f)
    }
    function F() {
        p && p.objInstances && (g.remove(p.objInstances),
        p.objInstances = null,
        p.hatMesh = null,
        p.backMesh = null,
        p.weaponMeshes.length = 0,
        p.weaponGeos = {},
        p.armMeshes.length = 0,
        p.legMeshes.length = 0),
        (p = new h(-1,this,s,i,a,l)).sid = -1,
        p.init(_.showPlayer ? 0 : 3, _.showPlayer ? 0 : -3, 3, "preview", !1),
        p.skins = [_.skinPrim, -1],
        p.hatIndex = parseInt(_.hatIndex),
        p.backIndex = parseInt(_.backIndex),
        p.meleeIndex = parseInt(_.meleeIndex),
        p.skinColIndex = parseInt(_.skinColIndex),
        p.attachIndex = parseInt(_.attachIndex),
        p.secIndex = parseInt(_.secondaryInd),
        p.setClass(l, parseInt(_.classIndex), parseInt(_.secondaryInd), !0),
        l.players.swapWeapon(p, 0, !0),
        g.add(l.players.generateMeshes(p, !1, !0, L)),
        p.swapTime = 0,
        p.weaponMeshes[0].visible = !0,
        -1 == M && l.players.swapSecondary(p),
        1 == M && l.players.swapMelee(p),
        l.players.updateMsh(p, !0)
    }
    function U(e) {
        let t = l.store.skins.filter(t=>t && t.type == parseInt(e) && (0 == _.season || _.season == (t.seas || 1))).sort((e,t)=>e.id > t.id ? 1 : t.id > e.id ? -1 : 0).sort((e,t)=>e.rarity > t.rarity ? 1 : t.rarity > e.rarity ? -1 : 0).sort((e,t)=>e.seas > t.seas ? 1 : t.seas > e.seas ? -1 : 0).reverse()
          , r = {
            Default: -1
        };
        for (let i of t)
            r[i.name + " [" + l.store.rarities[i.rarity].name + "]"] = l.store.skins.findIndex(t=>t && t.type == e && t.id == i.id && t.name == i.name);
        return r
    }
    function G(e) {
        let t = prompt("Import Skin Json", "");
        if (null != t && "" != t)
            try {
                let r = JSON.parse(t);
                L[e] = r
            } catch (e) {
                alert("Invalid Config")
            }
    }
    function H(e) {
        let t = document.createElement("input");
        t.type = "file",
        t.id = "jsonInput",
        t.addEventListener("change", t=>V(t, e ? 3 : 1, e), !1),
        t.click()
    }
    function V(e, t=1, r) {
        let i = event.dataTransfer || e.target
          , n = i.items || i.files;
        if (!n.length || n.length > t)
            return alert("Please select 1 file");
        for (var s = 0; s < t; s++) {
            let e = i.items ? n[s].getAsFile() : n[s];
            if (!e)
                return;
            let t = new FileReader;
            e.name.endsWith(".zip") ? (t.onload = function(e) {
                q(e.target.result)
            }
            ,
            t.readAsDataURL(e)) : e.name.endsWith(".obj") ? (t.addEventListener("loadend", e=>{
                if (r) {
                    let t = l.store.skins[1 == r ? p.hatIndex : p.backIndex];
                    t && (o.updateMesh(l.store.types[r] + t.id + (t.tex ? "_" + t.tex : ""), e.srcElement.result),
                    F())
                } else
                    p.weapon && (o.updateMesh("weapons/" + p.weapon.src, e.srcElement.result),
                    F())
            }
            ),
            t.readAsText(e)) : (t.onload = (()=>e=>{
                let t = new Image;
                t.onload = function() {
                    let e = document.createElement("canvas");
                    if (e.width = this.width,
                    e.height = this.height,
                    e.getContext("2d").drawImage(this, 0, 0),
                    r) {
                        let t = l.store.skins[1 == r ? p.hatIndex : p.backIndex];
                        t && o.updateTexture(l.store.types[r] + t.id + (t.tex ? "_" + t.tex : ""), e)
                    } else if (l.weapons[p.loadout[p.weaponIndex]].melee) {
                        let t = -1 == p.meleeIndex ? {
                            id: 0
                        } : l.store.skins[p.meleeIndex];
                        o.updateTexture("melee/melee_" + (t.id || 0) + (t.tex ? "_" + t.tex : ""), e)
                    } else {
                        let t = l.store.skins[p.skins[p.weaponIndex]];
                        o.updateTexture(t ? t.tex ? t.tex : "weapons/skins/" + p.weapon.src + "_" + t.id : "weapons/" + p.weapon.src, e)
                    }
                }
                ,
                t.src = e.target.result
            }
            )(),
            t.readAsDataURL(e))
        }
    }
    function W() {
        let e = l.store.skins[A];
        if (e)
            if (null != e.weapon || e.type && 3 == e.type) {
                let t = {
                    0: [210, 256],
                    1: [null == e.mid ? 400 : 350, 400],
                    2: [310, 310],
                    4: [235, 256],
                    5: [225, 300],
                    7: [256, 300],
                    8: [310, 310],
                    10: [210, 270],
                    15: [210, 220]
                };
                e.type && 3 == e.type && (1 == e.id ? t[0][0] = 170 : 3 == e.id && (t[0][0] = 145));
                let r = (e.type && 3 == e.type ? "melee_" : "weapon_" + (e.weapon || 0) + "_") + (null == e.id ? null == e.mid ? "c" + e.tex.replace("weapons/pat/", "") : "m" + e.mid + (null == e.midT ? "" : "_" + e.midT.split("_").slice(-1)[0]) : e.type && 3 == e.type ? e.id + (null == e.tex ? "" : "_" + e.tex) : e.tex ? e.tex : e.id) + ".png";
                setTimeout(function() {
                    var i = new Image;
                    i.onload = function() {
                        let n = document.createElement("canvas");
                        n.width = x.get("size") || 256,
                        n.height = x.get("size") || 256,
                        n.getContext("2d").drawImage(i, t[e.weapon || 0] ? t[e.weapon || 0][0] : 256, t[e.weapon || 0] ? t[e.weapon || 0][1] : 256, 550, 550, 0, 0, n.width, n.width);
                        let s = document.createElement("a");
                        s.href = n.toDataURL("image/png"),
                        s.download = r,
                        s.click(),
                        R && (I(++A),
                        R && W())
                    }
                    ,
                    i.src = d.domElement.toDataURL("image/png")
                }, 500)
            } else
                R && (I(++A),
                R && W())
    }
    function Y(e) {
        this.imgAsDataURL = "",
        this.process = function(t) {
            if (this.imgAsDataURL = URL.createObjectURL(t),
            this.imgAsDataURL && e) {
                try {
                    var r = new Image;
                    r.onload = function() {
                        o.updateTexture(e.replace("https://hoodgail.github.io/krunker_assets/", "").replace(".png", ""), this)
                    }
                    ,
                    r.src = this.imgAsDataURL
                } catch (e) {}
                X.close()
            }
        }
    }
    function Z(e) {
        this.process = function(t) {
            if (e) {
                try {
                    const r = new FileReader;
                    r.addEventListener("loadend", t=>{
                        const r = t.srcElement.result;
                        o.updateMesh(e.replace("models/", "").replace(".obj", ""), r)
                    }
                    ),
                    r.readAsText(t)
                } catch (e) {}
                X.close()
            }
        }
    }
    (function() {
        g = new n.Scene;
        let e = new n.AmbientLight(9937064);
        e.layers.enable(1),
        g.add(e),
        (d = new n.WebGLRenderer({
            preserveDrawingBuffer: !0,
            precision: "mediump",
            powerPreference: "high-performance",
            alpha: !0,
            antialias: O
        })).setClearColor(0, 0),
        d.setPixelRatio(window.devicePixelRatio * (O ? 2 : 1)),
        d.setSize(s.isNumber(A) ? 512 : window.innerWidth, s.isNumber(A) ? 512 : window.innerHeight),
        d.autoClear = !1,
        d.shadowMap.enabled = !0,
        d.shadowMap.autoUpdate = !1,
        d.shadowMap.type = n.BasicShadowMap;
        var t = document.getElementById("container");
        if (t.appendChild(d.domElement),
        s.isNumber(A))
            (f = new n.PerspectiveCamera(45,1,.1,100)).position.x = 30,
            f.lookAt(g.position);
        else {
            var r = t.offsetWidth / t.offsetHeight;
            f = new n.PerspectiveCamera(60,r,.01,50),
            (m = new n.OrbitControls(f,t)).addEventListener("change", j),
            f.position.z = 0,
            f.position.x = 15,
            f.position.y = 5;
            var i = new n.Vector3(0,5,0);
            f.lookAt(i),
            m.target = i,
            f.updateProjectionMatrix(),
            t.addEventListener("drop", ()=>{
                event.preventDefault(),
                t.style.boxShadow = "none",
                V(event)
            }
            , !1),
            t.addEventListener("dragover", ()=>{
                event.preventDefault(),
                t.style.boxShadow = "#666666 0px 0px 100px inset"
            }
            , !1),
            t.addEventListener("dragleave", ()=>{
                event.preventDefault(),
                t.style.boxShadow = "none"
            }
            , !1),
            window.addEventListener("resize", N, !1)
        }
    }
    )(),
    k(),
    s.isNumber(A) ? (D(),
    I(A)) : x.has("nogui") ? F() : D(),

    function e() {
    	 F();
            
        requestAnimationFrame(e),
        p && p.objInstances && (p.legMeshes[0].visible = _.showPlayer,
        p.legMeshes[1].visible = _.showPlayer,
        p.lowerBody.children[0].visible = _.showPlayer,
        p.lowerBody.children[1].children[0].children[0].visible = _.showPlayer,
        p.lowerBody.children[1].children[1] && (p.lowerBody.children[1].children[1].children[0].visible = _.showPlayer),
        p.lowerBody.children[1].children[2] && (p.lowerBody.children[1].children[2].children[0].visible = _.showPlayer),
        p.lowerBody.children[2] && (p.lowerBody.children[2].visible = _.showPlayer),
        p.lowerBody.children[3] && (p.lowerBody.children[3].visible = _.showPlayer)),
        o.render(1e3 * u.getDelta(), !0),
        j()
    }(),
    s.isNumber(A) && R && W(),
    zip.workerScriptsPath = "./libs/";
    var X = new function() {
        this.init = function(e, t) {
            this.numFiles = t,
            this.progress = 0,
            this.reader = e
        }
        ,
        this.close = function() {
            this.reader && (this.progress++,
            this.numFiles === this.progress && (spriteIndex = 0,
            this.reader.close(),
            this.reader = void 0,
            setTimeout(function() {
                F()
            }, 1e3)))
        }
    }
    ;
    function q(e) {
        try {
            var t = ""
              , r = new zip.Data64URIReader(e);
            zip.createReader(r, function(e) {
                e.getEntries(function(r) {
                    if (r.length) {
                        X.init(e, r.length);
                        for (var i, n = 0; n < r.length; n++)
                            (i = r[n]).directory ? X.close() : "https://hoodgail.github.io/krunker_assets" == (t = i.filename.split("/")[0]) ? i.getData(new zip.BlobWriter("image/png"), new Y(i.filename).process, function() {}) : "models" == t && i.getData(new zip.BlobWriter("application/x-tgif"), new Z(i.filename).process, function() {})
                    }
                })
            }, function() {
                alert("Issues loading mode zip")
            })
        } catch (e) {
            alert("Issues loading mode zip")
        }
    }
}
, function(e, t) {
    e.exports = function(e) {
        function t(t, r) {
            function i() {
                return Math.pow(.95, y.zoomSpeed)
            }
            function n(e) {
                E.theta -= e
            }
            function s(e) {
                E.phi -= e
            }
            function a(e) {
                y.object.isPerspectiveCamera ? A /= e : y.object.isOrthographicCamera ? (y.object.zoom = Math.max(y.minZoom, Math.min(y.maxZoom, y.object.zoom * e)),
                y.object.updateProjectionMatrix(),
                O = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                y.enableZoom = !1)
            }
            function o(e) {
                y.object.isPerspectiveCamera ? A *= e : y.object.isOrthographicCamera ? (y.object.zoom = Math.max(y.minZoom, Math.min(y.maxZoom, y.object.zoom / e)),
                y.object.updateProjectionMatrix(),
                O = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                y.enableZoom = !1)
            }
            function c(e) {
                I.set(e.clientX, e.clientY)
            }
            function l(e) {
                if (!1 !== y.enabled) {
                    switch (e.preventDefault(),
                    y.domElement.focus ? y.domElement.focus() : window.focus(),
                    e.button) {
                    case y.mouseButtons.LEFT:
                        if (e.ctrlKey || e.metaKey || e.shiftKey) {
                            if (!1 === y.enablePan)
                                return;
                            c(e),
                            _ = M.PAN
                        } else {
                            if (!1 === y.enableRotate)
                                return;
                            (function(e) {
                                R.set(e.clientX, e.clientY)
                            }
                            )(e),
                            _ = M.ROTATE
                        }
                        break;
                    case y.mouseButtons.MIDDLE:
                        if (!1 === y.enableZoom)
                            return;
                        (function(e) {
                            z.set(e.clientX, e.clientY)
                        }
                        )(e),
                        _ = M.DOLLY;
                        break;
                    case y.mouseButtons.RIGHT:
                        if (!1 === y.enablePan)
                            return;
                        c(e),
                        _ = M.PAN
                    }
                    _ !== M.NONE && (document.addEventListener("mousemove", p, !1),
                    document.addEventListener("mouseup", h, !1),
                    y.dispatchEvent(w))
                }
            }
            function p(e) {
                if (!1 !== y.enabled)
                    switch (e.preventDefault(),
                    _) {
                    case M.ROTATE:
                        if (!1 === y.enableRotate)
                            return;
                        !function(e) {
                            C.set(e.clientX, e.clientY),
                            L.subVectors(C, R).multiplyScalar(y.rotateSpeed);
                            var t = y.domElement === document ? y.domElement.body : y.domElement;
                            n(2 * Math.PI * L.x / t.clientHeight),
                            s(2 * Math.PI * L.y / t.clientHeight),
                            R.copy(C),
                            y.update()
                        }(e);
                        break;
                    case M.DOLLY:
                        if (!1 === y.enableZoom)
                            return;
                        !function(e) {
                            B.set(e.clientX, e.clientY),
                            N.subVectors(B, z),
                            0 < N.y ? a(i()) : 0 > N.y && o(i()),
                            z.copy(B),
                            y.update()
                        }(e);
                        break;
                    case M.PAN:
                        if (!1 === y.enablePan)
                            return;
                        !function(e) {
                            k.set(e.clientX, e.clientY),
                            D.subVectors(k, I).multiplyScalar(y.panSpeed),
                            U(D.x, D.y),
                            I.copy(k),
                            y.update()
                        }(e)
                    }
            }
            function h(e) {
                !1 === y.enabled || (document.removeEventListener("mousemove", p, !1),
                document.removeEventListener("mouseup", h, !1),
                y.dispatchEvent(x),
                _ = M.NONE)
            }
            function u(e) {
                !1 === y.enabled || !1 === y.enableZoom || _ !== M.NONE && _ !== M.ROTATE || (e.preventDefault(),
                e.stopPropagation(),
                y.dispatchEvent(w),
                function(e) {
                    0 > e.deltaY ? o(i()) : 0 < e.deltaY && a(i()),
                    y.update()
                }(e),
                y.dispatchEvent(x))
            }
            function d(e) {
                !1 === y.enabled || !1 === y.enableKeys || !1 === y.enablePan || function(e) {
                    var t = !1;
                    switch (e.keyCode) {
                    case y.keys.UP:
                        U(0, y.keyPanSpeed),
                        t = !0;
                        break;
                    case y.keys.BOTTOM:
                        U(0, -y.keyPanSpeed),
                        t = !0;
                        break;
                    case y.keys.LEFT:
                        U(y.keyPanSpeed, 0),
                        t = !0;
                        break;
                    case y.keys.RIGHT:
                        U(-y.keyPanSpeed, 0),
                        t = !0
                    }
                    t && (e.preventDefault(),
                    y.update())
                }(e)
            }
            function f(e) {
                if (!1 !== y.enabled) {
                    switch (e.preventDefault(),
                    e.touches.length) {
                    case 1:
                        if (!1 === y.enableRotate)
                            return;
                        (function(e) {
                            R.set(e.touches[0].pageX, e.touches[0].pageY)
                        }
                        )(e),
                        _ = M.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === y.enableZoom && !1 === y.enablePan)
                            return;
                        (function(e) {
                            if (y.enableZoom) {
                                var t = e.touches[0].pageX - e.touches[1].pageX
                                  , r = e.touches[0].pageY - e.touches[1].pageY
                                  , i = Math.sqrt(t * t + r * r);
                                z.set(0, i)
                            }
                            if (y.enablePan) {
                                var n = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                                  , s = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                                I.set(n, s)
                            }
                        }
                        )(e),
                        _ = M.TOUCH_DOLLY_PAN;
                        break;
                    default:
                        _ = M.NONE
                    }
                    _ !== M.NONE && y.dispatchEvent(w)
                }
            }
            function m(e) {
                if (!1 !== y.enabled)
                    switch (e.preventDefault(),
                    e.stopPropagation(),
                    e.touches.length) {
                    case 1:
                        if (!1 === y.enableRotate)
                            return;
                        if (_ !== M.TOUCH_ROTATE)
                            return;
                        !function(e) {
                            C.set(e.touches[0].pageX, e.touches[0].pageY),
                            L.subVectors(C, R).multiplyScalar(y.rotateSpeed);
                            var t = y.domElement === document ? y.domElement.body : y.domElement;
                            n(2 * Math.PI * L.x / t.clientHeight),
                            s(2 * Math.PI * L.y / t.clientHeight),
                            R.copy(C),
                            y.update()
                        }(e);
                        break;
                    case 2:
                        if (!1 === y.enableZoom && !1 === y.enablePan)
                            return;
                        if (_ !== M.TOUCH_DOLLY_PAN)
                            return;
                        !function(e) {
                            if (y.enableZoom) {
                                var t = e.touches[0].pageX - e.touches[1].pageX
                                  , r = e.touches[0].pageY - e.touches[1].pageY
                                  , i = Math.sqrt(t * t + r * r);
                                B.set(0, i),
                                N.set(0, Math.pow(B.y / z.y, y.zoomSpeed)),
                                a(N.y),
                                z.copy(B)
                            }
                            if (y.enablePan) {
                                var n = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                                  , s = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                                k.set(n, s),
                                D.subVectors(k, I).multiplyScalar(y.panSpeed),
                                U(D.x, D.y),
                                I.copy(k)
                            }
                            y.update()
                        }(e);
                        break;
                    default:
                        _ = M.NONE
                    }
            }
            function g(e) {
                !1 === y.enabled || (y.dispatchEvent(x),
                _ = M.NONE)
            }
            function v(e) {
                !1 === y.enabled || e.preventDefault()
            }
            this.object = t,
            this.domElement = void 0 === r ? document : r,
            this.enabled = !0,
            this.target = new e.Vector3,
            this.minDistance = 0,
            this.maxDistance = 1 / 0,
            this.minZoom = 0,
            this.maxZoom = 1 / 0,
            this.minPolarAngle = 0,
            this.maxPolarAngle = Math.PI,
            this.minAzimuthAngle = -1 / 0,
            this.maxAzimuthAngle = 1 / 0,
            this.enableDamping = !1,
            this.dampingFactor = .25,
            this.enableZoom = !0,
            this.zoomSpeed = 1,
            this.enableRotate = !0,
            this.rotateSpeed = 1,
            this.enablePan = !0,
            this.panSpeed = 1,
            this.screenSpacePanning = !0,
            this.keyPanSpeed = 7,
            this.autoRotate = !1,
            this.autoRotateSpeed = 2,
            this.enableKeys = !0,
            this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            },
            this.mouseButtons = {
                LEFT: e.MOUSE.LEFT,
                MIDDLE: e.MOUSE.MIDDLE,
                RIGHT: e.MOUSE.RIGHT
            },
            this.target0 = this.target.clone(),
            this.position0 = this.object.position.clone(),
            this.zoom0 = this.object.zoom,
            this.getPolarAngle = function() {
                return T.phi
            }
            ,
            this.getAzimuthalAngle = function() {
                return T.theta
            }
            ,
            this.saveState = function() {
                y.target0.copy(y.target),
                y.position0.copy(y.object.position),
                y.zoom0 = y.object.zoom
            }
            ,
            this.reset = function() {
                y.target.copy(y.target0),
                y.object.position.copy(y.position0),
                y.object.zoom = y.zoom0,
                y.object.updateProjectionMatrix(),
                y.dispatchEvent(b),
                y.update(),
                _ = M.NONE
            }
            ,
            this.update = function() {
                var r = new e.Vector3
                  , i = (new e.Quaternion).setFromUnitVectors(t.up, new e.Vector3(0,1,0))
                  , s = i.clone().inverse()
                  , a = new e.Vector3
                  , o = new e.Quaternion;
                return function() {
                    var e = y.object.position;
                    return r.copy(e).sub(y.target),
                    r.applyQuaternion(i),
                    T.setFromVector3(r),
                    y.autoRotate && _ === M.NONE && n(2 * Math.PI / 60 / 60 * y.autoRotateSpeed),
                    T.theta += E.theta,
                    T.phi += E.phi,
                    T.theta = Math.max(y.minAzimuthAngle, Math.min(y.maxAzimuthAngle, T.theta)),
                    T.phi = Math.max(y.minPolarAngle, Math.min(y.maxPolarAngle, T.phi)),
                    T.makeSafe(),
                    T.radius *= A,
                    T.radius = Math.max(y.minDistance, Math.min(y.maxDistance, T.radius)),
                    y.target.add(P),
                    r.setFromSpherical(T),
                    r.applyQuaternion(s),
                    e.copy(y.target).add(r),
                    y.object.lookAt(y.target),
                    !0 === y.enableDamping ? (E.theta *= 1 - y.dampingFactor,
                    E.phi *= 1 - y.dampingFactor,
                    P.multiplyScalar(1 - y.dampingFactor)) : (E.set(0, 0, 0),
                    P.set(0, 0, 0)),
                    A = 1,
                    !!(O || a.distanceToSquared(y.object.position) > S || 8 * (1 - o.dot(y.object.quaternion)) > S) && (y.dispatchEvent(b),
                    a.copy(y.object.position),
                    o.copy(y.object.quaternion),
                    O = !1,
                    !0)
                }
            }(),
            this.dispose = function() {
                y.domElement.removeEventListener("contextmenu", v, !1),
                y.domElement.removeEventListener("mousedown", l, !1),
                y.domElement.removeEventListener("wheel", u, !1),
                y.domElement.removeEventListener("touchstart", f, !1),
                y.domElement.removeEventListener("touchend", g, !1),
                y.domElement.removeEventListener("touchmove", m, !1),
                document.removeEventListener("mousemove", p, !1),
                document.removeEventListener("mouseup", h, !1),
                window.removeEventListener("keydown", d, !1)
            }
            ;
            var y = this
              , b = {
                type: "change"
            }
              , w = {
                type: "start"
            }
              , x = {
                type: "end"
            }
              , M = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY_PAN: 4
            }
              , _ = M.NONE
              , S = 1e-6
              , T = new e.Spherical
              , E = new e.Spherical
              , A = 1
              , P = new e.Vector3
              , O = !1
              , R = new e.Vector2
              , C = new e.Vector2
              , L = new e.Vector2
              , I = new e.Vector2
              , k = new e.Vector2
              , D = new e.Vector2
              , z = new e.Vector2
              , B = new e.Vector2
              , N = new e.Vector2
              , j = function() {
                var t = new e.Vector3;
                return function(e, r) {
                    t.setFromMatrixColumn(r, 0),
                    t.multiplyScalar(-e),
                    P.add(t)
                }
            }()
              , F = function() {
                var t = new e.Vector3;
                return function(e, r) {
                    !0 === y.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0),
                    t.crossVectors(y.object.up, t)),
                    t.multiplyScalar(e),
                    P.add(t)
                }
            }()
              , U = function() {
                var t = new e.Vector3;
                return function(e, r) {
                    var i = y.domElement === document ? y.domElement.body : y.domElement;
                    if (y.object.isPerspectiveCamera) {
                        var n = y.object.position;
                        t.copy(n).sub(y.target);
                        var s = t.length();
                        s *= Math.tan(y.object.fov / 2 * Math.PI / 180),
                        j(2 * e * s / i.clientHeight, y.object.matrix),
                        F(2 * r * s / i.clientHeight, y.object.matrix)
                    } else
                        y.object.isOrthographicCamera ? (j(e * (y.object.right - y.object.left) / y.object.zoom / i.clientWidth, y.object.matrix),
                        F(r * (y.object.top - y.object.bottom) / y.object.zoom / i.clientHeight, y.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                        y.enablePan = !1)
                }
            }();
            y.domElement.addEventListener("contextmenu", v, !1),
            y.domElement.addEventListener("mousedown", l, !1),
            y.domElement.addEventListener("wheel", u, !1),
            y.domElement.addEventListener("touchstart", f, !1),
            y.domElement.addEventListener("touchend", g, !1),
            y.domElement.addEventListener("touchmove", m, !1),
            window.addEventListener("keydown", d, !1),
            this.update()
        }
        return t.prototype = Object.create(e.EventDispatcher.prototype),
        t.prototype.constructor = t,
        Object.defineProperties(t.prototype, {
            center: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .center has been renamed to .target"),
                    this.target
                }
            },
            noZoom: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                    !this.enableZoom
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                    this.enableZoom = !e
                }
            },
            noRotate: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                    !this.enableRotate
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                    this.enableRotate = !e
                }
            },
            noPan: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                    !this.enablePan
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                    this.enablePan = !e
                }
            },
            noKeys: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                    !this.enableKeys
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                    this.enableKeys = !e
                }
            },
            staticMoving: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                    !this.enableDamping
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                    this.enableDamping = !e
                }
            },
            dynamicDampingFactor: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                    this.dampingFactor
                },
                set: function(e) {
                    console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                    this.dampingFactor = e
                }
            }
        }),
        t
    }
}
]);
